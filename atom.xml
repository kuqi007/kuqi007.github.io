<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Elfred&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5a77481cd50da835fa2a71acfab9dc93</icon>
  <subtitle>上善若水</subtitle>
  <link href="https://blog.elfred.top/atom.xml" rel="self"/>
  
  <link href="https://blog.elfred.top/"/>
  <updated>2025-03-09T15:25:07.759Z</updated>
  <id>https://blog.elfred.top/</id>
  
  <author>
    <name>Elfred</name>
    <email>elfred2096@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>盈立证券-香港-2025开户与入金教程-3月最高可享HK$460新户奖励</title>
    <link href="https://blog.elfred.top/posts/a02c942b.html"/>
    <id>https://blog.elfred.top/posts/a02c942b.html</id>
    <published>2025-03-09T14:05:00.000Z</published>
    <updated>2025-03-09T15:25:07.759Z</updated>
    
    <content type="html"><![CDATA[<p><strong>盈立证券是香港、新加坡持牌券商，成立于2018年，</strong>uSMART APP<strong>是企业旗下指定官方美、港股智能投资交易软件。 <strong>本文主要介绍盈立香港-开户，</strong>，并且同一身份只能领取一次新户奖励。</strong> **盈立证券几乎没有开户门槛，只要有新加坡、香港银行账户即可，可以直接买卖港美股、BTC ETF相关产品，交易手续费也较低，有这方面需求的可以考虑使用。</p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2025/20250309215852304.png" style="zoom:38%;" /><p><strong>通过下面的链接注册，3月最高可享HK$460新户奖励</strong></p><p><a href="https://m.usmart66.com/webapp/marketing/jump-register.html?register-ct=ic&register-cid=4546&ICode=264140#/register">https://m.usmart66.com/webapp/marketing/jump-register.html?register-ct=ic&amp;register-cid=4546&amp;ICode=264140#/register</a></p><p><strong>（建议直接通过上面链接注册，无需填写邀请码）</strong> <strong>邀请码：264140</strong></p><p><strong>或者扫二维码注册：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2025/20250309220339580.png" alt="img"></p><span id="more"></span><p><strong>活动会持续更新，可以持续关注</strong></p><p><strong>2025年3月新人礼（仅通过链接注册可享）：</strong></p><ul><li><p><strong>1、注册奖励：</strong></p><ul><li>免费美股、港股实时行情</li></ul><p><strong>2、开户奖励：</strong></p><ul><li><strong>HK$160</strong> 现金券</li></ul><p><strong>3、入金奖励：</strong></p><ul><li>① <strong>HK$300</strong> 现金券：自首次入金起月均余额 <strong>10000 HKD</strong> 并维持 6 个月，每月完成 1 笔交易，即可逐月激活 1 张 50 HKD 现金券</li><li>② 美股 0 佣金 + 平台费最高 $0.99&#x2F;笔</li><li>③ 美股期权 0 佣金且无最低收费</li><li>④ 100 只港股 ETF 免佣金</li></ul></li></ul><h3 id="开户条件"><a href="#开户条件" class="headerlink" title="开户条件"></a>开户条件</h3><ul><li><p><strong>身份证</strong></p></li><li><p><strong>香港或者新加坡银行账户（入金用）</strong></p></li></ul><h3 id="开户流程"><a href="#开户流程" class="headerlink" title="开户流程"></a><strong>开户流程</strong></h3><p><strong>先直接注册链接（通过此链接注册才能享受新户奖励）：</strong></p><p><a href="https://m.usmart66.com/webapp/marketing/jump-register.html?register-ct=ic&register-cid=4546&ICode=264140#/register">https://m.usmart66.com/webapp/marketing/jump-register.html?register-ct=ic&amp;register-cid=4546&amp;ICode=264140#/register</a></p><p>先在网页端注册账号信息</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F330e1136-d4f7-47d9-9cd9-b39fed78d6bf%2FUntitled.png?table=block&id=5db0d873-6f99-40b2-8ea8-353323c29206&t=5db0d873-6f99-40b2-8ea8-353323c29206&width=560&cache=v2" alt="notion image"></p><p><strong>注册完成后，下载APP</strong></p><p><strong>AppStore：</strong></p><p><a href="https://apps.apple.com/hk/app/%E9%A6%99%E6%B8%AF%E7%9B%88%E7%AB%8B%E8%AD%89%E5%88%B8-%E9%A0%98%E5%85%88%E7%A7%91%E6%8A%80%E6%B8%AF%E8%B3%87%E5%88%B8%E5%95%86/id1463024118">https://apps.apple.com/hk/app/%E9%A6%99%E6%B8%AF%E7%9B%88%E7%AB%8B%E8%AD%89%E5%88%B8-%E9%A0%98%E5%85%88%E7%A7%91%E6%8A%80%E6%B8%AF%E8%B3%87%E5%88%B8%E5%95%86/id1463024118</a></p><p><strong>GooglePlay：</strong></p><p><a href="https://play.google.com/store/apps/details?id=com.usmart.stock">https://play.google.com/store/apps/details?id=com.usmart.stock</a></p><p>登录刚刚注册的账户</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F18d88cce-9b58-407e-9ba5-f063aa915a84%2F2.png?table=block&id=d836dba1-1c72-4939-aea1-efc95d4af2da&t=d836dba1-1c72-4939-aea1-efc95d4af2da&width=331.984375&cache=v2" alt="notion image"></p><p>补充邮箱信息</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fe924cd4b-4771-40c8-8609-2bfa68a1a56a%2F3.png?table=block&id=61d6675e-c4bd-4576-83db-a3c75634380e&t=61d6675e-c4bd-4576-83db-a3c75634380e&width=590&cache=v2" alt="notion image"></p><p>这里选择开立个人账户</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F2c757b93-93aa-44a5-bca2-9ee46536d771%2F5.png?table=block&id=d066c614-78d1-4ef1-bb73-3c3b6ddfd380&t=d066c614-78d1-4ef1-bb73-3c3b6ddfd380&width=590&cache=v2" alt="notion image"></p><p>选择其他国籍</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F96d26a52-c850-4de1-b1c7-d3ca22d3e21d%2F6.png?table=block&id=b9dbf942-3551-4d73-97f6-ad244b10fa2e&t=b9dbf942-3551-4d73-97f6-ad244b10fa2e&width=590&cache=v2" alt="notion image"></p><p>填写身份证信息</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F28b926aa-bf98-4a51-8d61-370196ad8fba%2F7.png?table=block&id=e7940aea-ca82-4ce5-8649-d8e0d475e9d9&t=e7940aea-ca82-4ce5-8649-d8e0d475e9d9&width=590&cache=v2" alt="notion image"></p><p>填写其他职业税务信息等</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F39b9356f-53c5-400a-8c1c-0fb0134c2bea%2F8.png?table=block&id=508ddf2e-04b4-4afa-a5d7-1d089875b979&t=508ddf2e-04b4-4afa-a5d7-1d089875b979&width=331.984375&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fc2059bf4-bba2-4808-9482-993e0b815ab9%2F9.png?table=block&id=719e62c5-2d46-4e97-8fe8-752f97311af2&t=719e62c5-2d46-4e97-8fe8-752f97311af2&width=331&cache=v2" alt="notion image"></p><p>需要上传身份证件</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F7d73665f-0a64-477c-a333-ba147cedf4ed%2F10.png?table=block&id=6e6dd056-af65-4d3e-b780-412aeb9901c2&t=6e6dd056-af65-4d3e-b780-412aeb9901c2&width=590&cache=v2" alt="notion image"></p><p><strong>对于住址如果和身份证地址不一致，还需要提交住址证明</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fd81da8c2-7d89-49b4-bcc2-9f3a6862f11b%2F11.png?table=block&id=71989052-9fcf-4026-a452-14a08b7ad732&t=71989052-9fcf-4026-a452-14a08b7ad732&width=590&cache=v2" alt="notion image"></p><p>其他一些个人基本情况</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fc0335ca8-a0ff-4c90-98f6-724eb9450d0c%2F12.png?table=block&id=49b24196-03cb-43ee-b861-eb1515adf309&t=49b24196-03cb-43ee-b861-eb1515adf309&width=331&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F968b0124-3d3c-46a7-98a2-de438244eb7c%2F13.png?table=block&id=f0210706-1036-4810-a0d4-c6793d8698ba&t=f0210706-1036-4810-a0d4-c6793d8698ba&width=331&cache=v2" alt="notion image"></p><p>最后需要做一下人脸验证</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F6f31fcc0-ef27-48d6-a697-d30e9c12ff00%2F14.png?table=block&id=582f6d9d-e792-4ff1-9f28-20a045fc65e4&t=582f6d9d-e792-4ff1-9f28-20a045fc65e4&width=331.984375&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Ffc411ac2-510b-4043-be9b-9dc6e6d7766f%2F15.png?table=block&id=83dc9035-bffd-4ee1-85de-537b3720b7f2&t=83dc9035-bffd-4ee1-85de-537b3720b7f2&width=331.984375&cache=v2" alt="notion image"></p><p>确认一些资料</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F7f707c71-fc0c-4904-b96e-ffe64809e769%2F16.png?table=block&id=a3add167-f289-48aa-ac63-205cd77d55ad&t=a3add167-f289-48aa-ac63-205cd77d55ad&width=331&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F953d99d8-6074-4444-a959-68a360e4cc10%2F17.png?table=block&id=f001c98c-56b0-44b7-a881-3b4f3b8148da&t=f001c98c-56b0-44b7-a881-3b4f3b8148da&width=331.984375&cache=v2" alt="notion image"></p><p><strong>这里建议开标准账户：交易佣金低！</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F8ce279a6-4d85-4ee4-95d4-6ff4c203f01d%2F18.png?table=block&id=b64df52f-7646-4707-8fe3-8047d585c2e3&t=b64df52f-7646-4707-8fe3-8047d585c2e3&width=590&cache=v2" alt="notion image"></p><p>最后等待资料审核即可</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fbf24596a-6c52-4a35-99c1-489d58f0622c%2F19.png?table=block&id=edec7d3e-25f5-4a2a-89be-4f692f0d4f89&t=edec7d3e-25f5-4a2a-89be-4f692f0d4f89&width=590&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F2bab7bec-1c3b-454e-804f-9cf040265a00%2F20.png?table=block&id=50cb1767-51da-44dc-b88a-16f8dd31cb15&t=50cb1767-51da-44dc-b88a-16f8dd31cb15&width=708&cache=v2" alt="notion image"></p><h2 id="入金"><a href="#入金" class="headerlink" title="入金"></a><strong>入金</strong></h2><p><strong>入金可以选择香港银行、新加坡银行入金（wise也可以如今）</strong></p><p><strong>我这里演示一下香港银行入金港币</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F1942f663-3331-4929-bb14-5842b52a3449%2F21.png?table=block&id=1b2e6712-61d1-407d-899b-46f23b34725d&t=1b2e6712-61d1-407d-899b-46f23b34725d&width=331&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F3935e151-5634-4690-b143-4ee6c981f310%2F22.png?table=block&id=9a52c542-e2e7-4c02-8651-18ea086f85d6&t=9a52c542-e2e7-4c02-8651-18ea086f85d6&width=332&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F012e28e4-c553-42cb-9df1-2af81d44d998%2F23.png?table=block&id=44289f58-b60a-4abc-9a6b-826459bad0a3&t=44289f58-b60a-4abc-9a6b-826459bad0a3&width=332&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F5ed00e9e-096f-4119-ae6a-b498c4a31844%2F24.png?table=block&id=66127bb6-9d33-4e44-90e5-e003074865f5&t=66127bb6-9d33-4e44-90e5-e003074865f5&width=332&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Ff37ae521-dc56-4ed0-b13b-fb36cb23a3a6%2F25.png?table=block&id=2a43af99-af06-4848-832b-12fdbe9d896b&t=2a43af99-af06-4848-832b-12fdbe9d896b&width=709.984375&cache=v2" alt="notion image"></p><p><strong>完成入金后需要选择奖励，如果逾期未选择会自动选择第一档</strong></p><p><strong>请根据自己打算的入金情况选择</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2025/20250309215343080.png" alt="notion image"></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2025/20250309215358087.png" alt="notion image"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>盈立证券没有类似其他券商的现金宝之类的货币基金可以购买，只能购买股票、ETF，如果您对股市不熟悉并且只是想为了拿新户奖励的话，推荐下面几支稳定的ETF股票购买。</strong></p><p><strong>我这里港美股均推荐一支货币基金股票：</strong></p><ul><li><p><strong>港股</strong> <strong>A南方港元，港股代码：03053</strong></p></li><li><p><strong>美股</strong></p><ul><li><strong>美国国债1-3月ETF，美股代码：BIL</strong></li></ul></li></ul><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F3986a61f-3d36-4980-a7b7-a562578ce0c3%2F28(1).png?table=block&id=95344a44-1282-4aad-a76f-90594cbeaa3e&t=95344a44-1282-4aad-a76f-90594cbeaa3e&width=332&cache=v2" alt="notion image"></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2025/20250309215404858.png" alt="notion image"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;盈立证券是香港、新加坡持牌券商，成立于2018年，&lt;/strong&gt;uSMART APP&lt;strong&gt;是企业旗下指定官方美、港股智能投资交易软件。 &lt;strong&gt;本文主要介绍盈立香港-开户，&lt;/strong&gt;，并且同一身份只能领取一次新户奖励。&lt;/strong&gt; **盈立证券几乎没有开户门槛，只要有新加坡、香港银行账户即可，可以直接买卖港美股、BTC ETF相关产品，交易手续费也较低，有这方面需求的可以考虑使用。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kuqi007/picGo/2025/20250309215852304.png&quot; style=&quot;zoom:38%;&quot; /&gt;




&lt;p&gt;&lt;strong&gt;通过下面的链接注册，3月最高可享HK$460新户奖励&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://m.usmart66.com/webapp/marketing/jump-register.html?register-ct=ic&amp;register-cid=4546&amp;ICode=264140#/register&quot;&gt;https://m.usmart66.com/webapp/marketing/jump-register.html?register-ct=ic&amp;amp;register-cid=4546&amp;amp;ICode=264140#/register&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（建议直接通过上面链接注册，无需填写邀请码）&lt;/strong&gt; &lt;strong&gt;邀请码：264140&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;或者扫二维码注册：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kuqi007/picGo/2025/20250309220339580.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="港美股券商" scheme="https://blog.elfred.top/categories/%E6%B8%AF%E7%BE%8E%E8%82%A1%E5%88%B8%E5%95%86/"/>
    
    
    <category term="美港股开户" scheme="https://blog.elfred.top/tags/%E7%BE%8E%E6%B8%AF%E8%82%A1%E5%BC%80%E6%88%B7/"/>
    
    <category term="盈立证券" scheme="https://blog.elfred.top/tags/%E7%9B%88%E7%AB%8B%E8%AF%81%E5%88%B8/"/>
    
  </entry>
  
  <entry>
    <title>盈透证券IBKR-无入金门槛无管理费，最高可享1000$奖励，2025开户教程</title>
    <link href="https://blog.elfred.top/posts/76e4bf48.html"/>
    <id>https://blog.elfred.top/posts/76e4bf48.html</id>
    <published>2025-03-07T11:04:00.000Z</published>
    <updated>2025-03-09T15:00:21.848Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="盈透证券IBKR-无入金门槛无管理费，最高可享1000-奖励，2025开户教程"><a href="#盈透证券IBKR-无入金门槛无管理费，最高可享1000-奖励，2025开户教程" class="headerlink" title="盈透证券IBKR-无入金门槛无管理费，最高可享1000$奖励，2025开户教程"></a>盈透证券IBKR-无入金门槛无管理费，最高可享1000$奖励，2025开户教程</h1><p><strong>IB现在应该是最快就能审核下户的券商了吧，支持wise入金激活，有其他境外银行的也可直接入金，不支持第三方入金，无最低入金门槛。</strong> <strong>可作为其他等券商，比如富途，存量用户开户证明吧</strong></p><p><strong>如果你要玩美股，或者全球投资，那么IB盈透证券是你必须拥有的一个账户。</strong></p><p>作为美国交易量排第一的互联网券商，只要是你想交易的金融资产，盈透证券都可以满足你。</p><p>像我们比较熟知的雪盈、老虎证券底层都是用的盈透的API。</p><p><strong>平台特点：</strong></p><ul><li><p><strong>盈透证券为全球 33 个国家的135 个市场，提供每周 6 天、每天 24 小时数据访问和投资交易</strong></p></li><li><p><strong>无管理费、无最低入金门槛要求，支持碎股交易</strong></p></li><li><p><strong>极低的货币换汇费用，且每月首笔电汇费用免费</strong></p></li><li><p><strong>中文支持友好</strong></p></li></ul><h2 id="准备资料"><a href="#准备资料" class="headerlink" title="准备资料"></a>准备资料</h2><ul><li><p><strong>护照</strong>（<strong>国外的账户能护照的优先用护照开户</strong>）</p></li><li><p><strong>身份证（也可开户）</strong></p></li></ul><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p><strong>点击下方链接注册，！！不用梯子！！（新用户注册最高可获得1000$的IBKR股票）：</strong></p><p><a href="https://ibkr.com.cn/referral/qiqi219">https://ibkr.com.cn/referral/qiqi219</a></p><p><strong>人在海外的用可以用这个：</strong><br><a href="https://ibkr.com/referral/qiqi219">https://ibkr.com/referral/qiqi219</a></p><span id="more"></span><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F846d705d-e300-4610-be45-382126317e0f%2FUntitled.png?table=block&id=6713e5be-76cd-470d-b387-c8701226f5e1&t=6713e5be-76cd-470d-b387-c8701226f5e1&width=1614&cache=v2" alt="notion image"></p><p><strong>此时会收到邮件，需要验证一下邮箱</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fc026a1cb-e16b-4ba6-9c66-ffbf0a275bd6%2FUntitled.png?table=block&id=8ab553ea-0c84-4e7d-a4a9-b8498335e2dd&t=8ab553ea-0c84-4e7d-a4a9-b8498335e2dd&width=808&cache=v2" alt="notion image"></p><p><strong>接下来我们选择开通个人账户，用中文输入资料</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F3ade26a9-b474-46b6-9138-bff3c1aeed1e%2FUntitled.png?table=block&id=6fcd8be7-acf2-4f85-9c7a-903e1d4bc20c&t=6fcd8be7-acf2-4f85-9c7a-903e1d4bc20c&width=1443&cache=v2" alt="notion image"></p><p><strong>填写个人信息，注意这里现在无需上传地址证明了，填写了护照号码就能开户</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F053e9ec9-4418-40e2-89d7-709b64e0886b%2FUntitled.png?table=block&id=13c636ac-bd59-4cac-b3c7-d9fc74b88e70&t=13c636ac-bd59-4cac-b3c7-d9fc74b88e70&width=1432&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F0c24f31a-984f-43b8-a42b-12a827440a11%2FUntitled.png?table=block&id=81ba6003-857a-489b-8b63-d109ff913d2d&t=81ba6003-857a-489b-8b63-d109ff913d2d&width=1298&cache=v2" alt="notion image"></p><p><strong>填写雇佣信息</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Ff112ee74-8198-4f5e-8c70-f459a4161a3c%2FUntitled.png?table=block&id=193d1ab5-abe4-42f1-8a4f-e220fa88644b&t=193d1ab5-abe4-42f1-8a4f-e220fa88644b&width=1390&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Ffce8a1c5-11c0-4e0a-85ab-817942bdbe25%2FUntitled.png?table=block&id=51031b54-5609-4041-9a66-564fced15549&t=51031b54-5609-4041-9a66-564fced15549&width=1051&cache=v2" alt="notion image"></p><p>短信接码验证</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fa09e4136-5ce0-4bea-8caf-b6e13d552c6c%2FUntitled.png?table=block&id=e6fcbb95-46d3-4ee4-880b-db095e951ccb&t=e6fcbb95-46d3-4ee4-880b-db095e951ccb&width=1446&cache=v2" alt="notion image"></p><p>账户设置</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F456be6ca-6136-4957-ad1d-2359ff91ce0a%2FUntitled.png?table=block&id=69a98cca-0105-4ce8-bc89-45d68c8906d3&t=69a98cca-0105-4ce8-bc89-45d68c8906d3&width=1232&cache=v2" alt="notion image"></p><p><strong>交易经验与许可尽量申请时全部勾选（根据自己实际情况来就好，这个后面也可以另外开通，需要你填写的收入和要开的服务项目符合才能进行下一步）</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fdfbd30f3-cdcc-410b-a123-bc5faefe3bed%2FUntitled.png?table=block&id=be3aa092-9b69-4119-8a40-ebe192672ee0&t=be3aa092-9b69-4119-8a40-ebe192672ee0&width=913&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F0f6d0894-0a28-4e78-bcf6-6c171387d371%2FUntitled.png?table=block&id=86b7e755-017e-4727-a75d-dbfd686f58ba&t=86b7e755-017e-4727-a75d-dbfd686f58ba&width=993&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F9a4497a8-ee0b-4f24-9600-42db61a0844f%2FUntitled.png?table=block&id=c644562f-bda8-40f4-ab40-1f71983287c8&t=c644562f-bda8-40f4-ab40-1f71983287c8&width=1006&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F2df1d900-dca2-4ab4-935d-7249cc3df224%2FUntitled.png?table=block&id=559c4ac3-4b9e-4a3b-a3e8-624f61d96fc0&t=559c4ac3-4b9e-4a3b-a3e8-624f61d96fc0&width=1054&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F1beb6f9f-3ab1-47d2-8268-9cd4dbab6f97%2FUntitled.png?table=block&id=b73742e2-d164-4018-9689-ad6433660685&t=b73742e2-d164-4018-9689-ad6433660685&width=1033&cache=v2" alt="notion image"></p><p><strong>确认税务相关内容</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F518a45a3-6733-491f-9288-79c7ede3aac2%2FUntitled.png?table=block&id=99ef60ca-1e3e-4acc-9788-02450264a0cf&t=99ef60ca-1e3e-4acc-9788-02450264a0cf&width=1306&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F3eeadd29-992d-4c03-8ef0-25789f704088%2FUntitled.png?table=block&id=3ad38ab5-9e2f-450b-af95-7f13bfd383bc&t=3ad38ab5-9e2f-450b-af95-7f13bfd383bc&width=1383&cache=v2" alt="notion image"></p><p><strong>同意所有相关协议</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F12b41270-38ec-4da8-88fb-631b2d877a5b%2FUntitled.png?table=block&id=1fa847f3-e7b3-4eb5-8c28-446cfb77e3e6&t=1fa847f3-e7b3-4eb5-8c28-446cfb77e3e6&width=1383&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F44727c41-05ee-40bf-861e-2d6becb1ba5a%2FUntitled.png?table=block&id=fba1f754-582d-4d7e-984d-db8d663c825f&t=fba1f754-582d-4d7e-984d-db8d663c825f&width=1112&cache=v2" alt="notion image"></p><p><strong>需要入金完成最后的激活（只接受同名账户入金）</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F3456040a-9ba4-49a4-8f3a-202190ecac00%2FUntitled.png?table=block&id=1ef82988-e50f-4dbe-9194-996a14a8d32f&t=1ef82988-e50f-4dbe-9194-996a14a8d32f&width=1101&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fd5d919e6-2839-4585-a86c-0938bf9e209e%2FUntitled.png?table=block&id=51d9a7a1-6500-4af7-a05d-582c79ff83d8&t=51d9a7a1-6500-4af7-a05d-582c79ff83d8&width=1259&cache=v2" alt="notion image"></p><p><strong>我这里使用汇丰银行转账入金（FPS的话，看说明最低是需要10000HKD）</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fe3964a3d-8112-4c5b-8c96-9f379e1d5ba9%2FUntitled.png?table=block&id=9ae50542-0f74-49d6-8d21-1ee68194a95f&t=9ae50542-0f74-49d6-8d21-1ee68194a95f&width=1380&cache=v2" alt="notion image"></p><p><strong>银行转账时</strong> <strong>转到006 花旗银行，填写银行账号以及用户名 Interactive Brokers LLC 注意填写转账附言</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F688854b5-64e8-4dbd-ab7b-fcfdfc9352d4%2FUntitled.png?table=block&id=2fda77a0-d330-4d38-bba5-cd22f916e60c&t=2fda77a0-d330-4d38-bba5-cd22f916e60c&width=1143&cache=v2" alt="notion image"></p><p>剩下的就是等待审核完成即可</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F7d3f89a1-c1f1-4566-8104-6d04bc234359%2FUntitled.png?table=block&id=ffd55940-5e3f-4957-95cc-32c84961106c&t=ffd55940-5e3f-4957-95cc-32c84961106c&width=1197&cache=v2" alt="notion image"></p><p><strong>注意</strong> 账户开通后是会收到邮件通知的，在审查期间可以登录APP，但是只能看模拟账户 <strong>交易账户需要审核通过后才能打开</strong></p><h2 id="APP与二步验证"><a href="#APP与二步验证" class="headerlink" title="APP与二步验证"></a>APP与二步验证</h2><p><strong>下载APP</strong></p><p><strong>GooglePlay：</strong></p><p>IBKR Mobile - Apps on Google Play</p><p>Trade stocks, options, futures, forex, and more worldwide, at your fingertips.</p><p><a href="https://play.google.com/store/apps/details?id=atws.app">https://play.google.com/store/apps/details?id=atws.app</a></p><p><strong>AppStore：</strong></p><p>‎IBKR Mobile - Invest Worldwide</p><p>‎An intuitive, ergonomic mobile trading platform. Monitor market activity and trade with real-time quotes, charts, and market scanners. Both standard order types and complex option spreads are supported. Thinking about opening an account at IBKR? Take our mobile platform for a test drive: no registr…</p><p><a href="https://apps.apple.com/us/app/ibkr-mobile-invest-worldwide/id454558592">https://apps.apple.com/us/app/ibkr-mobile-invest-worldwide/id454558592</a></p><p>如果还没有审核通过的话，此时是可以登录APP的，会进入模拟盘</p><p><strong>登陆后会提示是否开启IB Key验证，建议开启，后续网页登陆只需要手机点一下授权即可</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F62991997-e90c-4ab8-be9d-0e318db56448%2FUntitled.png?table=block&id=fdcdf7b8-fd6d-4fad-bcbf-f22752821759&t=fdcdf7b8-fd6d-4fad-bcbf-f22752821759&width=1242&cache=v2" alt="notion image"></p><h2 id="开户成功后"><a href="#开户成功后" class="headerlink" title="开户成功后"></a>开户成功后</h2><p><strong>存款入账更新</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F0052740f-baac-46f4-80e9-245e13915300%2FUntitled.png?table=block&id=9a1561b6-0edd-4745-a7b0-2e583c92d6f8&t=9a1561b6-0edd-4745-a7b0-2e583c92d6f8&width=736&cache=v2" alt="notion image"></p><p><strong>账户审核通过</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fabf086c7-a96e-42c0-89c3-0dc54fae78bc%2FUntitled.png?table=block&id=56bc8fd5-ce78-4370-a36d-674b149e4b16&t=56bc8fd5-ce78-4370-a36d-674b149e4b16&width=743&cache=v2" alt="notion image"></p><p><strong>注意此时还不能登录移动手机，因为需要1-2个工作日初始化账户</strong></p><p>此时如果你登录手机应用会报错</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F505f477d-4047-4a31-b974-6324761085c5%2FUntitled.png?table=block&id=8b77ed97-c316-4bee-b2fb-d3eeeac8e0d9&t=8b77ed97-c316-4bee-b2fb-d3eeeac8e0d9&width=1242&cache=v2" alt="notion image"></p><h2 id="关于获取开户证明"><a href="#关于获取开户证明" class="headerlink" title="关于获取开户证明"></a>关于获取开户证明</h2><p>登录网页版，<strong>业绩与报告→其他报告→账户确认书</strong></p><p>Your Session Has Expired.</p><p><a href="https://www.ibkr.com.cn/AccountManagement/AmAuthentication?action=OtherReports">https://www.ibkr.com.cn/AccountManagement/AmAuthentication?action=OtherReports</a></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F0ac58bd8-2e0f-41dc-8508-1516100e4eb4%2FUntitled.png?table=block&id=60780f5c-6f5b-41fb-a4e1-18481614e7c6&t=60780f5c-6f5b-41fb-a4e1-18481614e7c6&width=1238&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F27662947-e012-41e1-b8f3-d45a6ad9c7be%2FUntitled.png?table=block&id=07da2e81-1cfa-4afd-bf6c-eb6ffb1ebbc2&t=07da2e81-1cfa-4afd-bf6c-eb6ffb1ebbc2&width=1459&cache=v2" alt="notion image"></p><p>一天即可下户</p><h2 id="关于获取结单"><a href="#关于获取结单" class="headerlink" title="关于获取结单"></a>关于获取结单</h2><p>登录网页版，<strong>业绩与报告→报表→活动</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fa9f5b028-a5ba-4340-8870-047d89f54195%2FUntitled.png?table=block&id=6624b70d-c87c-4f32-9808-375de02be195&t=6624b70d-c87c-4f32-9808-375de02be195&width=1236&cache=v2" alt="notion image"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2F2cff39f3-cdeb-4148-985a-67f9978ff804%2FUntitled.png?table=block&id=b0d40e7d-9090-4f57-aad1-b65123bb9fbf&t=b0d40e7d-9090-4f57-aad1-b65123bb9fbf&width=1034&cache=v2" alt="notion image"></p><h2 id="活期账户利率"><a href="#活期账户利率" class="headerlink" title="活期账户利率"></a>活期账户利率</h2><p>以美元账户为例： <strong>1w美元一下为0% 1w美元以上的部分可享受 4.83%的活期年化利率</strong></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe63edc06-9ce7-4877-990b-2efe658d9c01%2Fa4522e14-4db8-4026-b529-9a410494f938%2FUntitled.png?table=block&id=80b5610b-f3e0-48be-b6a8-e255f4d1d9c3&t=80b5610b-f3e0-48be-b6a8-e255f4d1d9c3&width=1325&cache=v2" alt="notion image"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;盈透证券IBKR-无入金门槛无管理费，最高可享1000-奖励，2025开户教程&quot;&gt;&lt;a href=&quot;#盈透证券IBKR-无入金门槛无管理费，最高可享1000-奖励，2025开户教程&quot; class=&quot;headerlink&quot; title=&quot;盈透证券IBKR-无入金门槛无管理费，最高可享1000$奖励，2025开户教程&quot;&gt;&lt;/a&gt;盈透证券IBKR-无入金门槛无管理费，最高可享1000$奖励，2025开户教程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;IB现在应该是最快就能审核下户的券商了吧，支持wise入金激活，有其他境外银行的也可直接入金，不支持第三方入金，无最低入金门槛。&lt;/strong&gt; &lt;strong&gt;可作为其他等券商，比如富途，存量用户开户证明吧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你要玩美股，或者全球投资，那么IB盈透证券是你必须拥有的一个账户。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为美国交易量排第一的互联网券商，只要是你想交易的金融资产，盈透证券都可以满足你。&lt;/p&gt;
&lt;p&gt;像我们比较熟知的雪盈、老虎证券底层都是用的盈透的API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;盈透证券为全球 33 个国家的135 个市场，提供每周 6 天、每天 24 小时数据访问和投资交易&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;无管理费、无最低入金门槛要求，支持碎股交易&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;极低的货币换汇费用，且每月首笔电汇费用免费&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;中文支持友好&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;准备资料&quot;&gt;&lt;a href=&quot;#准备资料&quot; class=&quot;headerlink&quot; title=&quot;准备资料&quot;&gt;&lt;/a&gt;准备资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;护照&lt;/strong&gt;（&lt;strong&gt;国外的账户能护照的优先用护照开户&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;身份证（也可开户）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;注册账号&quot;&gt;&lt;a href=&quot;#注册账号&quot; class=&quot;headerlink&quot; title=&quot;注册账号&quot;&gt;&lt;/a&gt;注册账号&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;点击下方链接注册，！！不用梯子！！（新用户注册最高可获得1000$的IBKR股票）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ibkr.com.cn/referral/qiqi219&quot;&gt;https://ibkr.com.cn/referral/qiqi219&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人在海外的用可以用这个：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://ibkr.com/referral/qiqi219&quot;&gt;https://ibkr.com/referral/qiqi219&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="港美股券商" scheme="https://blog.elfred.top/categories/%E6%B8%AF%E7%BE%8E%E8%82%A1%E5%88%B8%E5%95%86/"/>
    
    
    <category term="盈透开户" scheme="https://blog.elfred.top/tags/%E7%9B%88%E9%80%8F%E5%BC%80%E6%88%B7/"/>
    
    <category term="美港股开户" scheme="https://blog.elfred.top/tags/%E7%BE%8E%E6%B8%AF%E8%82%A1%E5%BC%80%E6%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>Why you should stop apologising for your poor English (and what to do instead)</title>
    <link href="https://blog.elfred.top/posts/5dff8a92.html"/>
    <id>https://blog.elfred.top/posts/5dff8a92.html</id>
    <published>2022-06-30T07:27:00.000Z</published>
    <updated>2025-03-08T14:46:55.123Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Why-you-should-stop-apologising-for-your-poor-English-and-what-to-do-instead"><a href="#Why-you-should-stop-apologising-for-your-poor-English-and-what-to-do-instead" class="headerlink" title="Why you should stop apologising for your poor English (and what to do instead)."></a>Why you should stop apologising for your poor English (and what to do instead).</h1><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2022/202206301528723.jpeg" alt="img"></p><p><a href="https://unsplash.com/photos/meAZ6fJZ9eg">Photo by Zachary Spears in Unsplash</a></p><p>Have you ever apologised for your ‘bad’ English?</p><p>You know, those situations where:</p><ul><li>You’ve written an email to a supplier requesting information and you end the email with “Sorry for my English. I hope you can understand my email.”</li><li>You’re on the telephone to a client and they ask you “what do you mean” and you respond by apologising first “ Sorry, my English is not very good. What I mean is…”</li><li>You’re in a meeting and you’ve just given a brief update on a project your team’s working on. One of your colleagues asks you a question that you don’t understand. You automatically assume it’s because of your ‘bad’ English skills and reply: “I’m sorry, but my English is not very good. Can you repeat that?”</li></ul><p>Why did you apologise? Let me guess.</p><ul><li>You were so conscious of making mistakes in English that you thought by blaming your ‘bad’ English for those mistakes, the other person would understand better why you’re making those mistakes and have more sympathy for you.</li><li>You so badly wanted to make a positive impression on your audience that you thought if you apologised for your ‘poor’ English, they would treat you more leniently and give you a chance.</li><li>You thought if you apologised beforehand for your English, any lack of clarity would be blamed on your language mistakes and NOT on your message. This, you think, would be more acceptable.</li></ul><span id="more"></span><h1 id="Why-“ritual-apologies”-don’t-bring-forgiveness"><a href="#Why-“ritual-apologies”-don’t-bring-forgiveness" class="headerlink" title="Why “ritual apologies” don’t bring forgiveness."></a><strong>Why “ritual apologies” don’t bring forgiveness.</strong></h1><p>We all have a deep need to be approved by our peers, and one way we seek their approval is by apologising for our weaknesses in the hope that they (our weaknesses) and, in turn, we will be accepted.</p><p>The problem with, what some people call, “ritual apologies” is that they end up making us look <strong>weak</strong>, <strong>less confident</strong> and, worse still, <strong>annoy our listener</strong>. Let’s face it, no one wants to hear whiny excuses, especially in the corporate world.</p><p>Furthermore, by apologising for your English, you’re placing the spotlight on something they may NOT have noticed in the first place.</p><p>But now you’ve highlighted your ‘bad’ English, the spotlight will stay there and NOT on <strong>your true message</strong>. Every grammar, pronunciation or word mistake will be scrutinised and picked out like a shining beacon for the world to see!</p><p>The very thing you didn’t want to happen has happened. You’re being judged not for your professional expertise, but for your ‘bad’ English.</p><p>In this post, I’m going to share:</p><ul><li>how my business clients define their ‘bad’ English,</li><li>why speaking mistake-free English will not help you achieve your professional goals: negotiate deals, get the promotion you’re seeking, make an impact at presentations.</li><li>what you should focus on instead to make you a valuable and key player in your career.</li></ul><h1 id="What’s-Bad-English-Anyway"><a href="#What’s-Bad-English-Anyway" class="headerlink" title="What’s Bad English, Anyway?"></a><strong>What’s Bad English, Anyway?</strong></h1><p>Many of my business clients define their ‘bad’ English as:</p><ul><li>“Using the wrong English tenses when I’m speaking.”</li><li>“Not having enough sophisticated vocabulary to impress my audience.”</li><li>“Not knowing when to use the present perfect tense in my meeting.”</li><li>“Always using the same, simple words.”</li><li>“Getting prepositions confused.”</li><li>“Not being able to pronounce certain words.”</li><li>“Having a heavy accent.”</li></ul><p>In essence, the reasons they give as to why they’re not able to get that promotion; negotiate that important deal; impress their audience with their presentation or win over their bosses with that business proposal is <strong>because</strong> of their poor English grammar, pronunciation and vocabulary.</p><p>Because, of course, knowing how to use the past perfect tense would clinch that deal for them, wouldn’t it?</p><p>Or creating that complex sentence with impressive words and perfect grammar would persuade their client that they’re the one for the job.</p><p><em>They</em> believe it would, so what they do is ‘self-medicate’.</p><p>They:</p><ul><li>buy grammar and vocabulary courses;</li><li>memorise long lists of phrasal verbs or new vocabulary;</li><li>watch lots of films in English;</li><li>look for shortcuts</li></ul><p>They do all this in the hope it will magically turn them into a confident, mistake-free English speaker when what they should be focusing on is <strong>learning how to communicate.</strong></p><p>*<strong>“To speak or to communicate: that is the question.”*</strong></p><p>What does it mean, to communicate? Surely if you’re a confident speaker, you’re an effective communicator? The terms are interchangeable, aren’t they?</p><p>Well, not exactly.</p><p><a href="https://www.etymonline.com/word/communicate">Etymonline</a> has a wonderful definition of ‘communicate’&#x3D;&#x3D; to make common.</p><p>In other words, to make accessible.</p><p>So, when you try and use sophisticated words or jargon and people don’t understand or follow you, you’ve forgotten to ‘make things common’. In other words, you’re not communicating. You need to break things down, simplify your message, help others understand you.</p><p>Here’s how you know that you <strong>communicate effectively</strong> (when your grammar or pronunciation ceases to exist):</p><ul><li>When you clearly identify the <strong>outcome</strong> you wish to accomplish before doing anything. All business communication is goal oriented. <em>For example, getting that promotion, getting your clients to agree the deal, getting an agreement on a contract, getting your managing director to accept your proposal for more investment.</em></li><li>When you give your thoughts and ideas <strong>a structure</strong> that will help you achieve your outcome, including the words you want your listeners to hear, the order in which you want them to hear your ideas (cohesion + clarity).</li><li>When you put yourself in your <strong>listener’s shoes</strong>. Imagine what information they need&#x2F;would want to hear from you to take the action you want them to take, and what information to leave out. (content + conciseness)</li><li>When you <strong>actively listen</strong> to the responses — cutting out the excess noise and <strong>allowing silences</strong> to fill in the space instead of more talk. (mutual respect)</li><li>When you <strong>summarise</strong> what the other person has said to demonstrate you were listening and reassure them you have understood.</li><li>When you’re not sure you’ve understood correctly, you <strong>formulate</strong> (and offer them) a <strong>hypothesis</strong> allowing them to correct you. (checking understanding)</li></ul><p>These are the qualities that demonstrate you’re an effective business communicator in English, <strong>not</strong> perfect grammar, sophisticated vocabulary or accentless pronunciation.</p><p>And in each case, not a whiff of an apology for your ‘bad’ English is required.</p><p>By contrast, this is what happens if you <strong>focus only on speaking</strong> and not on communicating</p><ul><li><strong>You don’t pay attention</strong> — you’re so focused on talking that you forget to stop to check if the person is still listening to you. Are they still interested? Are they following what you’re saying or have you lost them?</li><li><strong>Your message is not heard</strong> — You’re so intent on speaking ‘fluently’ you forget to check if the other person has heard your message correctly or in the way you want it to be heard.</li><li><strong>You ignore the other person</strong>- because you’re already thinking about what (and how) you’re going to say next <em>while</em> the other person is talking. That’s infuriating for the other person and shows a lack of respect, even if that’s <strong>not</strong> your intention.</li><li><strong>You end up rambling</strong> — You’re so focused on getting your grammar right, on finding the perfect word, on speaking ‘fluently’ that you lose sight of what your goal is for talking in the first place and end up rambling (talking with no purpose). No one likes a rambler because they’re time wasters, confusing and a barrier to good communication.</li></ul><p><em>“</em><a href="https://www.grbj.com/articles/78105-the-big-difference-between-conversation-and-communication"><em>Talk is cheap</em></a><em>. It’s intended to fill time and space with words — nothing else.”</em></p><h1 id="Here’s-What-I’d-Like-You-To-Do-Instead"><a href="#Here’s-What-I’d-Like-You-To-Do-Instead" class="headerlink" title="Here’s What I’d Like You To Do Instead"></a><strong>Here’s What I’d Like You To Do Instead</strong></h1><p><strong>Stop apologising</strong> for your ‘bad’ English. Your apologies won’t bring you forgiveness but will make you look weak, less confident and annoy your listener.</p><p><strong>Stop blaming</strong> your ‘bad’ English for that failed deal or being turned down for that promotion.</p><p><strong>Stop thinking</strong> that if you <strong>learn to speak more, mistake-free and grammar-perfect English</strong>, you will make more of an impact as a presenter.</p><p><strong>Start focusing on learning how to communicate</strong>, not on speaking more. The sooner you start doing this, the more confident and valued you’ll become.</p><p>As Plato says: <em>“Wise men speak because they have something to say; Fools because they have to say something.”</em></p><p><em>Originally published in</em> <a href="https://englishwithatwist.com/2018/09/06/stop-apologising/"><em>English with a Twist</em></a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;Why-you-should-stop-apologising-for-your-poor-English-and-what-to-do-instead&quot;&gt;&lt;a href=&quot;#Why-you-should-stop-apologising-for-your-poor-English-and-what-to-do-instead&quot; class=&quot;headerlink&quot; title=&quot;Why you should stop apologising for your poor English (and what to do instead).&quot;&gt;&lt;/a&gt;Why you should stop apologising for your poor English (and what to do instead).&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kuqi007/picGo/2022/202206301528723.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://unsplash.com/photos/meAZ6fJZ9eg&quot;&gt;Photo by Zachary Spears in Unsplash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Have you ever apologised for your ‘bad’ English?&lt;/p&gt;
&lt;p&gt;You know, those situations where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You’ve written an email to a supplier requesting information and you end the email with “Sorry for my English. I hope you can understand my email.”&lt;/li&gt;
&lt;li&gt;You’re on the telephone to a client and they ask you “what do you mean” and you respond by apologising first “ Sorry, my English is not very good. What I mean is…”&lt;/li&gt;
&lt;li&gt;You’re in a meeting and you’ve just given a brief update on a project your team’s working on. One of your colleagues asks you a question that you don’t understand. You automatically assume it’s because of your ‘bad’ English skills and reply: “I’m sorry, but my English is not very good. Can you repeat that?”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Why did you apologise? Let me guess.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You were so conscious of making mistakes in English that you thought by blaming your ‘bad’ English for those mistakes, the other person would understand better why you’re making those mistakes and have more sympathy for you.&lt;/li&gt;
&lt;li&gt;You so badly wanted to make a positive impression on your audience that you thought if you apologised for your ‘poor’ English, they would treat you more leniently and give you a chance.&lt;/li&gt;
&lt;li&gt;You thought if you apologised beforehand for your English, any lack of clarity would be blamed on your language mistakes and NOT on your message. This, you think, would be more acceptable.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="enligsh learning" scheme="https://blog.elfred.top/tags/enligsh-learning/"/>
    
  </entry>
  
  <entry>
    <title>快速复习指南</title>
    <link href="https://blog.elfred.top/posts/b44a5d7a.html"/>
    <id>https://blog.elfred.top/posts/b44a5d7a.html</id>
    <published>2022-05-26T03:31:00.000Z</published>
    <updated>2025-03-08T14:46:55.122Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><a href="https://blog.elfred.top/2021/01/30/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">操作系统面试题</a></li></ul><h2 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><a href="https://blog.elfred.top/2021/01/23/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/">多线程面试题</a></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li><a href="https://blog.elfred.top/2021/01/23/interview/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/">JVM面试题</a></li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul><li><a href="https://blog.elfred.top/2021/01/23/interview/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">redis常见面试题</a></li><li><a href="https://mp.weixin.qq.com/s/O1W2CJ9T-bVj0t-E5gihRA">妈妈再也不担心我面试被Redis问得脸都绿了</a></li></ul><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><ul><li><a href="https://blog.elfred.top/2022/05/24/internet/redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9E%B6%E6%9E%84%E3%80%81%E9%97%AE%E9%A2%98/">redis集群及架构</a></li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><ul><li><a href="https://blog.elfred.top/2021/04/27/interview/MySQL%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">MySQL常见面试题</a></li></ul><h4 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h4><ul><li><a href="https://mp.weixin.qq.com/s/YQFHclmKQGlZtvBkSINpsw">InnoDB解决幻读的方案–LBCC&amp;MVCC</a></li></ul><h4 id="分库分表最佳实践"><a href="#分库分表最佳实践" class="headerlink" title="分库分表最佳实践"></a>分库分表最佳实践</h4><p>TODO</p><h2 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h2><ul><li><a href="https://blog.elfred.top/2021/01/30/interview/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">系统架构设计面试题</a></li></ul><h3 id="场景设计题"><a href="#场景设计题" class="headerlink" title="场景设计题"></a>场景设计题</h3><ul><li><a href="https://zq99299.github.io/note-architect/hc/07/03.html#%E8%AE%BE%E8%AE%A1%E4%BF%A1%E6%81%AF%E6%B5%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E6%B3%A8%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B">如何设计微博feeds流</a></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="刷题网站"><a href="#刷题网站" class="headerlink" title="刷题网站"></a>刷题网站</h3><ul><li><a href="https://codetop.cc/home">codetop</a></li><li><a href="https://www.programmercarl.com/">代码随想录</a></li><li><a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.html">CS-Notes 剑指 Offer 题解</a></li><li><a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.html">CS-Notes Leetcode 题解</a></li></ul><h2 id="综合面经"><a href="#综合面经" class="headerlink" title="综合面经"></a>综合面经</h2><ul><li><a href="https://blog.elfred.top/2021/01/20/interview/2021%E9%9D%A2%E7%BB%8F/">2021面经</a></li><li><a href="https://blog.elfred.top/2021/05/09/interview/2021%E9%9D%A2%E7%BB%8F%E7%AC%AC%E4%BA%8C%E6%B3%A2/">2021面经第二波</a></li><li><a href="https://mp.weixin.qq.com/s/cciIzLMXVs28vBHaapdvfw">20+互联网公司面试总结</a></li></ul><h2 id="快速检索："><a href="#快速检索：" class="headerlink" title="快速检索："></a>快速检索：</h2><ul><li><a href="https://blog.elfred.top/2022/05/21/internet/JAVA/">那些年我们背过的JAVA面试题</a></li><li><a href="https://blog.elfred.top/2022/05/21/internet/DESIGN/">系统设计面试题</a></li><li><a href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide</a></li><li><a href="http://www.cyc2018.xyz/">CS-Notes</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;计算机基础&quot;&gt;&lt;a href=&quot;#计算机基础&quot; class=&quot;headerlink&quot; title=&quot;计算机基础&quot;&gt;&lt;/a&gt;计算机基础&lt;/h2&gt;&lt;h3 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;</summary>
      
    
    
    
    
    <category term="快速复习指南" scheme="https://blog.elfred.top/tags/%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>redis集群的架构、问题，附脑洞</title>
    <link href="https://blog.elfred.top/posts/a2aadf50.html"/>
    <id>https://blog.elfred.top/posts/a2aadf50.html</id>
    <published>2022-05-24T12:52:00.000Z</published>
    <updated>2025-03-08T14:46:55.113Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="redis集群的架构、问题，附脑洞"><a href="#redis集群的架构、问题，附脑洞" class="headerlink" title="redis集群的架构、问题，附脑洞"></a><strong>redis集群的架构、问题，附脑洞</strong></h1><p>Redis 是一种开源（BSD 许可）、数据结构存储在内存中的系统，用作数据库、缓存和消息队列。Redis 提供了诸如字符串、散列、列表、集合、带范围查询的排序集合、位图、超级日志、地理空间索引和流等数据结构。Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久化，并通过 Redis Sentinel 和 Redis Cluster 自动分区提供高可用性。</p><h2 id="1-集群的优势"><a href="#1-集群的优势" class="headerlink" title="1 集群的优势"></a>1 集群的优势</h2><p>下面是redis集群的几个明显优势。</p><h3 id="1-1-伸缩性，数据规模不断增大的时候，容易扩容"><a href="#1-1-伸缩性，数据规模不断增大的时候，容易扩容" class="headerlink" title="1.1 伸缩性，数据规模不断增大的时候，容易扩容"></a>1.1 伸缩性，数据规模不断增大的时候，容易扩容</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d28640001ba3d07320377.jpg"></p><p>单实例模式：只能垂直扩展，增大机器内存的容量；</p><p>集群模式：支持垂直扩展，也支持水平扩展，有更好的灵活性，也可以支持更大的容量；</p><span id="more"></span><h3 id="1-2-高可用，服务故障的情况，影响范围小"><a href="#1-2-高可用，服务故障的情况，影响范围小" class="headerlink" title="1. 2 高可用，服务故障的情况，影响范围小"></a>1. 2 高可用，服务故障的情况，影响范围小</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d28940001004e04560316.jpg"></p><p>单实例模式：故障转移前100%不可用(slave转换为master之前)；</p><p>集群模式：故障转移前部分不可用(集群规模越大，故障影响越小); </p><h3 id="1-3-高性能，查询和写入的性能"><a href="#1-3-高性能，查询和写入的性能" class="headerlink" title="1. 3 高性能，查询和写入的性能"></a>1. 3 高性能，查询和写入的性能</h3><p>单实例模式：查询可以分散在多个slave，写入却只有一个master；</p><p>集群模式：查询有多个master和多个slave，写入也有多个master；</p><h2 id="2-数据分片，一致性hash"><a href="#2-数据分片，一致性hash" class="headerlink" title="2 数据分片，一致性hash"></a>2 数据分片，一致性hash</h2><p>实现redis集群的核心点，是针对数据的分片，这里的一致性hash算法就非常关键。</p><h3 id="2-1-普通的hash-算法"><a href="#2-1-普通的hash-算法" class="headerlink" title="2.1 普通的hash 算法"></a>2.1 普通的hash 算法</h3><p><strong>node&#x3D;hash(key)%number</strong></p><p>数量变化和node顺序变化，导致node选择的差异性巨大，造成巨大的缓存失效。</p><h3 id="2-2-一致性hash"><a href="#2-2-一致性hash" class="headerlink" title="2.2 一致性hash"></a>2.2 一致性hash</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d28b100011c7a06470481.jpg"></p><p>hash(node) 形成虚拟节点环,hash(key)落在虚拟节点环，找到对应的node。</p><p>由于hash(node)的稳定性，与node顺序无关。node变更只影响一小部分数据。</p><h3 id="2-3-redis-cluster的hash-slot算法"><a href="#2-3-redis-cluster的hash-slot算法" class="headerlink" title="2.3 redis cluster的hash slot算法"></a>2.3 redis cluster的hash slot算法</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d28d90001c3c507320566.jpg"></p><p>关系: cluster &gt; node &gt; slot &gt; key</p><p>Redis Cluster在设计中没有使用一致性哈希（Consistency Hashing），而是使用数据分片引入哈希槽（hash slot）来实现。</p><p>一个 Redis Cluster包含16384（0~16383）个哈希槽，存储在Redis Cluster中的所有键都会被映射到这些slot中。</p><p>集群中的每个键都属于这16384个哈希槽中的一个，集群使用公式slot&#x3D;CRC16（key）&#x2F;16384来计算key属于哪个槽，其中CRC16(key)语句用于计算key的CRC16 校验和。</p><p>按照槽来进行分片，通过为每个节点指派不同数量的槽，可以控制不同节点负责的数据量和请求数。</p><h2 id="3-集群元数据的一致性"><a href="#3-集群元数据的一致性" class="headerlink" title="3 集群元数据的一致性"></a>3 集群元数据的一致性</h2><h3 id="3-1-对比：集中式存储元数据"><a href="#3-1-对比：集中式存储元数据" class="headerlink" title="3.1 对比：集中式存储元数据"></a>3.1 对比：集中式存储元数据</h3><p><img src="https://img3.sycdn.imooc.com/618d28f90001dd9205030256.jpg" alt="https://img3.sycdn.imooc.com/618d28f90001dd9205030256.jpg"></p><p>依赖外部的集中式存储服务，比如：zookeeper, etcd等，会增加运维负担和系统复杂度。</p><p>集中式的好处在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；不好在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p><h3 id="3-2-gossip-协议来广播自己的状态以及自己对整个集群认知的改变"><a href="#3-2-gossip-协议来广播自己的状态以及自己对整个集群认知的改变" class="headerlink" title="3.2 gossip 协议来广播自己的状态以及自己对整个集群认知的改变"></a>3.2 gossip 协议来广播自己的状态以及自己对整个集群认知的改变</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d29440001b49909960994.jpg"></p><p>ping &#x2F; pong 消息来确认节点的存活和同步全部的集群元数据。</p><p>集群元数据，包括：master&#x2F;slave node列表和状态, slot与node关系。</p><p>每个master node每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。</p><p>定时检查全部节点，如果发现某个节点通信延时达到了 cluster_node_timeout &#x2F; 2，那么立即发送 ping，避免数据交换延时过长。</p><h3 id="3-3-增加新节点"><a href="#3-3-增加新节点" class="headerlink" title="3.3 增加新节点"></a>3.3 增加新节点</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d297100012b8303820732.jpg"></p><p>命令 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt; </code></p><p>向一个节点 node 发送 CLUSTER MEET 命令，可以让 node 节点与 ip 和 port 所指定的节点进行握手（handshake），当握手成功时，node 节点就会将 ip 和 port 所指定的节点添加到 node 节点当前所在的集群中。</p><p>按照gossip协议，广播meet消息，全部节点接收新节点。</p><p>重新hash(node)，分配和转移相应的slot给到新节点。</p><h2 id="4-客户端如何调用"><a href="#4-客户端如何调用" class="headerlink" title="4 客户端如何调用"></a>4 客户端如何调用</h2><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d299700012be907320478.jpg"></p><h3 id="4-1-hash-slot-信息"><a href="#4-1-hash-slot-信息" class="headerlink" title="4.1 hash slot 信息"></a>4.1 hash slot 信息</h3><p>当客户端连接任何一个实例，实例就将哈希槽与实例的映射关系响应给客户端，客户端就会将哈希槽与实例映射信息缓存在本地。</p><h3 id="4-2-请求数据"><a href="#4-2-请求数据" class="headerlink" title="4.2 请求数据"></a>4.2 请求数据</h3><p>当客户端请求时，会计算出键所对应的哈希槽，在通过本地缓存的哈希槽实例映射信息定位到数据所在实例上，再将请求发送给对应的实例。 </p><h3 id="4-3-重定向机制"><a href="#4-3-重定向机制" class="headerlink" title="4.3 重定向机制"></a>4.3 重定向机制</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d29b7000197ca07320599.jpg"></p><p>客户端将请求发送到实例上，这个实例没有相应的数据，该 Redis 实例会告诉客户端更新本地的哈希槽与映射信息的缓存，将请求发送到其他的实例上。</p><h2 id="5-新的节点加入集群-扩容"><a href="#5-新的节点加入集群-扩容" class="headerlink" title="5 新的节点加入集群(扩容)"></a>5 新的节点加入集群(扩容)</h2><p>同3.3 增加新节点的前序步骤是一样的。</p><p>这里详细了解下重新扩容时slot迁移和数据。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d29e4000181d407940754.jpg"></p><h3 id="5-1-每个slot的迁移过程如下所示："><a href="#5-1-每个slot的迁移过程如下所示：" class="headerlink" title="5.1 每个slot的迁移过程如下所示："></a>5.1 每个slot的迁移过程如下所示：</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/20212021618d29fe0001b5fc04100474.jpg"></p><ul><li>对目标节点发送cluster setslot {slot_id} importing {sourceNodeId}命令，目标节点的状态被标记为”importing”，准备导入这个slot的数据。</li><li>对源节点发送cluster setslot {slot_id} migrating {targetNodeID}命令，源节点的状态被标记为”migrating”，准备迁出slot的数据。</li><li>源节点执行cluster getkeysinslot {slot_id} {count}命令，获取这个slot的所有的key列表(分批获取，count指定一次获取的个数)，然后针对每个key进行迁移。</li><li>在源节点执行migrate {targetIp} {targetPort} “” 0 {timeout} keys {keys}命令，把一批批key迁移到目标节点(redis-3.0.6之前一次只能迁移一个key)，具体来说，源节点对迁移的key执行dump指令得到序列化内容，然后通过客户端向目标节点发送携带着序列化内容的restore指令，目标节点进行反序列化后将接收到的内容存入自己的内存中，目标节点给客户端返回”OK”，然后源节点删除这个key，这样，一个key的迁移过程就结束了。</li><li>所有的key都迁移完成后，一个slot的迁移就结束了。</li><li>迁移所有的slot(应该被迁移的那些)，所有的slot迁移完成后，新的集群的slot就重新分配完成了，向集群内所有master发送cluster setslot {slot_id} node {targetNodeId}命令，通知他们哪些槽被迁移到了哪些master上，让它们更新自己的信息。</li></ul><h3 id="5-2-slot迁移的其他说明"><a href="#5-2-slot迁移的其他说明" class="headerlink" title="5.2 slot迁移的其他说明"></a>5.2 slot迁移的其他说明</h3><ul><li>迁移过程是同步的，在目标节点执行restore指令到原节点删除key之间，原节点的主线程处于阻塞状态，直到key被删除成功。</li><li>如果迁移过程突然出现网路故障，整个slot迁移只进行了一半，这时两个节点仍然会被标记为中间过滤状态，即”migrating”和”importing”，下次迁移工具连接上之后，会继续进行迁移。</li><li>在迁移过程中，如果每个key的内容都很小，那么迁移过程很快，不会影响到客户端的正常访问。</li><li>如果key的内容很大，由于迁移一个key的迁移过程是阻塞的，就会同时导致原节点和目标节点的卡顿，影响集群的稳定性，所以，集群环境下，业务逻辑要尽可能的避免大key的产生 。</li></ul><h3 id="5-3-slot编号"><a href="#5-3-slot编号" class="headerlink" title="5.3 slot编号"></a>5.3 slot编号</h3><p>无需要求每个master的slot编号是连续的，只要每个master管理的slot的数量均衡就可以。</p><h3 id="5-4-减少节点-缩容"><a href="#5-4-减少节点-缩容" class="headerlink" title="5.4 减少节点(缩容)"></a>5.4 减少节点(缩容)</h3><p>缩容的过程与扩容类似，只是slot和数据从下线的节点内转移到其他的节点上。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2a440001f7e408040754.jpg"></p><h2 id="6-集群中机器出现故障"><a href="#6-集群中机器出现故障" class="headerlink" title="6 集群中机器出现故障"></a>6 集群中机器出现故障</h2><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2a620001c82915881552.jpg"></p><h3 id="6-1-故障检测，节点失效"><a href="#6-1-故障检测，节点失效" class="headerlink" title="6.1 故障检测，节点失效"></a>6.1 故障检测，节点失效</h3><p>如果一个节点认为另外一个节点宕机，那么就是 pfail，主观宕机；</p><p>如果超过半数的节点都认为另外一个节点宕机了，那么就是 fail，客观宕机；</p><h3 id="6-2-故障转移，节点选举"><a href="#6-2-故障转移，节点选举" class="headerlink" title="6.2 故障转移，节点选举"></a>6.2 故障转移，节点选举</h3><p>每个slave节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p><p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node（N&#x2F;2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。</p><p>从节点执行主备切换，从节点切换为主节点。</p><h2 id="7-主从同步以及高可用"><a href="#7-主从同步以及高可用" class="headerlink" title="7 主从同步以及高可用"></a>7 主从同步以及高可用</h2><p>redis的主从同步在cluster版本之前就存在了，既可以提供更高的查询效率(多slave可以查询)，又可以增加服务的可用性(master挂机后可以启用slave成为master)。</p><h3 id="7-1-使用主从架构时"><a href="#7-1-使用主从架构时" class="headerlink" title="7.1 使用主从架构时"></a>7.1 使用主从架构时</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2a7f00014f8907000367.jpg"></p><p>将只有一个 Master 和多个从属用于复制。</p><p>所有写入都转到主节点，这会在主节点上产生更多负载。</p><p>如果Master宕机，整个架构容易出现SPOF（单点故障）。</p><p>当您的用户群增长时，MS 架构无助于扩展。</p><p>所以我们需要一个进程来在发生故障或关闭的情况下监控 Master，那就是 Sentinel。</p><h3 id="7-2-Redis哨兵"><a href="#7-2-Redis哨兵" class="headerlink" title="7.2 Redis哨兵"></a>7.2 Redis哨兵</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2aac000172c310240561.jpg"></p><p><strong>故障转移处理</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2acc0001dd0307000388.jpg"></strong></p><h2 id="8-主从同步与数据一致性"><a href="#8-主从同步与数据一致性" class="headerlink" title="8 主从同步与数据一致性"></a>8 主从同步与数据一致性</h2><h3 id="8-1-主从同步的实现过程"><a href="#8-1-主从同步的实现过程" class="headerlink" title="8.1 主从同步的实现过程"></a>8.1 主从同步的实现过程</h3><p>主从同步分为 2 个步骤：同步和命令传播。</p><p>数据同步有sync和psync。</p><p>sync全量同步，性能比较差；psync增量同步，速度和实时性好很多。</p><h3 id="8-2-全量同步-sync"><a href="#8-2-全量同步-sync" class="headerlink" title="8.2 全量同步 sync"></a>8.2 全量同步 sync</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2ae90001d7d505120257.jpg"></p><p>从服务器对主服务的同步操作，需要通过 sync 命令来实现，以下是 sync 命令的执行步骤：</p><ul><li>从服务器向主服务器发送 sync 命令</li><li>收到 sync 命令后，主服务器执行 bgsave 命令，用来生成 rdb 文件，并在一个缓冲区中记录从现在开始执行的写命令。</li><li>bgsave 执行完成后，将生成的 rdb 文件发送给从服务器，用来给从服务器更新数据</li><li>主服务器再将缓冲区记录的写命令发送给从服务器，从服务器执行完这些写命令后，此时的数据库状态便和主服务器一致了。</li></ul><h3 id="8-3-部分重同步-psync"><a href="#8-3-部分重同步-psync" class="headerlink" title="8.3 部分重同步 psync"></a>8.3 部分重同步 psync</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2afc00015a1808000549.jpg"></p><p>部分重同步功能由以下 3 部分组成：</p><ul><li>主从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区</li><li>服务器的运行 id（run id）</li></ul><h3 id="8-4-心跳检测"><a href="#8-4-心跳检测" class="headerlink" title="8.4 心跳检测"></a>8.4 心跳检测</h3><p>当完成了同步之后，主从服务器就会进入命令传播阶段，此时从服务器会以每秒 1 次的频率，向主服务器发送命令：REPLCONF ACK <replication_offset> 其中 replication_offset 是从服务器当前的复制偏移量</p><p><strong>发送这个命令主要有三个作用：</strong></p><ul><li>检测主从服务器的网络状态</li><li>辅助实现 min-slaves 选项</li><li>检测命令丢失（若丢失，主服务器会将丢失的写命令重新发给从服务器）</li></ul><h3 id="8-5-主从同步总结"><a href="#8-5-主从同步总结" class="headerlink" title="8.5 主从同步总结"></a>8.5 主从同步总结</h3><p>发送 SLAVEOF 命令可以进行主从同步，比如：SLAVEOF 127.0.0.1 6379</p><p><strong>主从同步有同步和命令传播 2 个步骤</strong></p><ul><li>同步：将从服务器的数据库状态更新成主服务器当前的数据库状态（一个消耗资源的操作）</li><li>命令传播：当主服务器数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的过程</li></ul><p><strong>主从同步分初次复制和断线后重复制两种情况</strong></p><ul><li>从 2.8 版本开始，在出现断线后重复制情况时，主服务器会根据复制偏移量、复制积压缓冲区和 run id，来确定执行完整重同步还是部分重同步</li><li>2.8 版本使用 psync 命令来代替 sync 命令去执行同步操作。目的是为了解决同步（sync 命令）的低效操作</li></ul><h2 id="问题1：集群的规模能否无限大，比如：1w台机器？"><a href="#问题1：集群的规模能否无限大，比如：1w台机器？" class="headerlink" title="问题1：集群的规模能否无限大，比如：1w台机器？"></a>问题1：集群的规模能否无限大，比如：1w台机器？</h2><p>答案是否定的，redis 官方给的 Redis Cluster 的规模上限是 1000 个实例。</p><p>限制的原因，关键在于实例间的通信开销，集群中的每个节点都保存所有哈希槽与节点对应关系信息（Slot 映射到节点的表），以及自身的状态信息。</p><p>参照3.2gossip协议广播方式，节点越多，广播风暴对于网络以及服务器压力也就越大。</p><p>虽然可以设置广播消息同步的超时时间，但是节点增多、超时时间变长之后，数据一致性的消息同步延时也会更大，出现元数据不一致的可能性也会增加。</p><h2 id="问题2：从库的使用，以及如何权衡？"><a href="#问题2：从库的使用，以及如何权衡？" class="headerlink" title="问题2：从库的使用，以及如何权衡？"></a>问题2：从库的使用，以及如何权衡？</h2><p>从库的作用，一是提高可用性，当主库宕机之后，可以立即启用从库作为主库提供服务；一是提高伸缩性，提高了数据查询并发能力，从库提供查询服务就增加了服务资源，更多的节点来支持查询。</p><p>由于主从同步存在数据一致性问题，所以在使用从库的过程中，相应的也就会遇到一些问题。</p><p>比如：因为从库数据同步慢了，这时候主库宕机了，数据不完整的从库作为主库，就会出现数据丢失的情况。从库用来查询也有类似问题，实时写入的新数据，同步到从库可能会有延时，在数据没有同步到从库的时候查询从库，也会出现查询无数据的情况。</p><p>所以在使用从库的情况下，需要考虑到上面的问题。</p><p>面对宕机的时候，数据丢失的问题，内存型数据库都会存在的风险，使用redis都需要面对这个风险，否则就要牺牲性能高正数据一致性，redis数据先持久化再提供服务，这样性能就会下降非常明显了，没法满足内存性数据库的优势了。</p><p>启用从库查询，可以针对一些数据更新的实时性较低，对于脏数据不那么敏感的业务，或者查询量实在太大而可以忽略部分数据延时的影响。</p><h2 id="问题3：redis集群化之后，代理的必要性？"><a href="#问题3：redis集群化之后，代理的必要性？" class="headerlink" title="问题3：redis集群化之后，代理的必要性？"></a>问题3：redis集群化之后，代理的必要性？</h2><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2b1e0001dedc09140761.jpg"></p><p>代理的性能和稳定性同样是问题所在。</p><p>产品的运维难度以及持续的维护，还是官方的redis cluster更加可靠。</p><p>有条件的团队，针对redis cluster的不足，还会有更深入的优化，比如咱们自己研发的tendis。</p><h2 id="问题4：单key的百万qps限频问题？（待解）"><a href="#问题4：单key的百万qps限频问题？（待解）" class="headerlink" title="问题4：单key的百万qps限频问题？（待解）"></a>问题4：单key的百万qps限频问题？（待解）</h2><p>单key的频繁更新，由于单个key有且只能落地到一个master节点的一个slot上面，无法通过增加节点增加slave的方法扩容，性能瓶颈就会受限于机器的CPU&#x2F;内存的读写能力了。</p><p>假设单机最高10w的写如速度，那么，要实现接口的100w的qps限频功能，要怎么实现呢？</p><p><strong>请输出你的解答。。。</strong></p><h2 id="附-脑洞：三体人来到地球，要消灭近半的地球人（待解）"><a href="#附-脑洞：三体人来到地球，要消灭近半的地球人（待解）" class="headerlink" title="附-脑洞：三体人来到地球，要消灭近半的地球人（待解）"></a>附-脑洞：三体人来到地球，要消灭近半的地球人（待解）</h2><p>三体人不像灭霸，直接用手套简单粗暴的一个响指就毁灭一半生灵，而是给每个人一个选择，选择对的人就有机会生存下来。</p><p>这个选择的方法也特别简单，但是需要开发一套系统来支持。</p><p>那么这套系统的开发工作就落在了地球人最聪明的程序员你的头上。</p><p>开发好了可以让自己以及家人获得豁免权而生存下来，开发的不好，直接咔嚓。</p><h3 id="这个选择的描述如下"><a href="#这个选择的描述如下" class="headerlink" title="这个选择的描述如下"></a>这个选择的描述如下</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2f7100013d8503780236.jpg" alt="https://img3.sycdn.imooc.com/618d2f7100013d8503780236.jpg"></p><p>全球有一个三体人的灯球，默认是熄灭状态。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d2f8200019e2805120246.jpg" alt="https://img3.sycdn.imooc.com/618d2f8200019e2805120246.jpg"></p><p>每个人会有一个三体人的开关，上面会显示当前灯球的状态(熄灭或者亮起)，有两个操作按钮，分别是控制灯球的熄灭和亮起。每个人只有一次选择机会，两个按钮只能选择一个按钮，按一次。如果一个按钮都不选择，不按的话，无论灯球最终状态如何，都是要被消灭。小孩子或者老人、残疾人，可以由监护人来辅助其完成选择。</p><h3 id="系统实现的前提条件和需求"><a href="#系统实现的前提条件和需求" class="headerlink" title="系统实现的前提条件和需求"></a>系统实现的前提条件和需求</h3><p><strong>前提条件说明</strong></p><p>1 全球80亿人口，必须同时在1分钟时间内完成选择（三体人的开关，全球实时状态同步，无时间偏差，无时延），规定时间范围之外无法操作；</p><p>2 三体人提供1000台128核256G内存1T磁盘的服务器，三体人的开关与服务器的网络是直连的，没有时延，没有网络开销；</p><p>3 全球80亿人，每个人都有一个唯一的从0开始自增的数字ID，与三体人的开关也是一一对应的；</p><p>4 每个人的ID%1000指向特定服务器，请求系统提供的接口 &#x2F;vote</p><p><strong>系统需求</strong></p><p>功能，开发这个投票接口(所有请求只会在这1分钟内请求)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/vote?uid=1111&amp;click=1&amp;t=1234143134134134134</span><br></pre></td></tr></table></figure><p><strong>参数</strong> </p><p>uid 长整型，每个人的唯一ID</p><p>click 枚举值，按钮选择，0 熄灭，1 亮起</p><p>t 长整型，操作时间，单位纳秒</p><p><strong>处理</strong></p><p>1 在同一个时刻(同一纳秒)，如果有多个人操作，选择次数多的生效，如果2个选择次数相同，状态不变。如：熄灭2次，亮起3次，这个时刻的状态是亮起。</p><p><strong>结果数据</strong></p><p>1 最终灯球的状态，是熄灭，还是亮起；</p><p>2 选择正确的人(ID集合);</p><p>3 选择错误的人(ID集合);</p><p>4 没有做出选择的人(ID集合)；</p><p><strong>最终执行</strong></p><p>调用三体人在服务器上安装的系统程序 ，完成地球人消灭计划。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill uid</span><br></pre></td></tr></table></figure><p>调用三体人的系统程序无延时，等同于内存读取的效率。</p><p>要求在1分钟时间内，把选择错误的人和没有做出选择的人消灭掉。</p><p><strong>模拟测试</strong></p><p>1 三体人在1分钟内导入测试用例，完成80亿人的选择。</p><p>2 1分钟正确执行完成 kill 调用。</p><p>如果无法实现上述工作，失败。</p><p><strong>请输出你的解答。。。</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;redis集群的架构、问题，附脑洞&quot;&gt;&lt;a href=&quot;#redis集群的架构、问题，附脑洞&quot; class=&quot;headerlink&quot; title=&quot;redis集群的架构、问题，附脑洞&quot;&gt;&lt;/a&gt;&lt;strong&gt;redis集群的架构、问题，附脑洞&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;Redis 是一种开源（BSD 许可）、数据结构存储在内存中的系统，用作数据库、缓存和消息队列。Redis 提供了诸如字符串、散列、列表、集合、带范围查询的排序集合、位图、超级日志、地理空间索引和流等数据结构。Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久化，并通过 Redis Sentinel 和 Redis Cluster 自动分区提供高可用性。&lt;/p&gt;
&lt;h2 id=&quot;1-集群的优势&quot;&gt;&lt;a href=&quot;#1-集群的优势&quot; class=&quot;headerlink&quot; title=&quot;1 集群的优势&quot;&gt;&lt;/a&gt;1 集群的优势&lt;/h2&gt;&lt;p&gt;下面是redis集群的几个明显优势。&lt;/p&gt;
&lt;h3 id=&quot;1-1-伸缩性，数据规模不断增大的时候，容易扩容&quot;&gt;&lt;a href=&quot;#1-1-伸缩性，数据规模不断增大的时候，容易扩容&quot; class=&quot;headerlink&quot; title=&quot;1.1 伸缩性，数据规模不断增大的时候，容易扩容&quot;&gt;&lt;/a&gt;1.1 伸缩性，数据规模不断增大的时候，容易扩容&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021618d28640001ba3d07320377.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;单实例模式：只能垂直扩展，增大机器内存的容量；&lt;/p&gt;
&lt;p&gt;集群模式：支持垂直扩展，也支持水平扩展，有更好的灵活性，也可以支持更大的容量；&lt;/p&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="redis" scheme="https://blog.elfred.top/tags/redis/"/>
    
    <category term="redis集群" scheme="https://blog.elfred.top/tags/redis%E9%9B%86%E7%BE%A4/"/>
    
    <category term="架构" scheme="https://blog.elfred.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring常见面试题</title>
    <link href="https://blog.elfred.top/posts/5dd00982.html"/>
    <id>https://blog.elfred.top/posts/5dd00982.html</id>
    <published>2022-05-21T14:32:00.000Z</published>
    <updated>2025-03-08T14:46:55.121Z</updated>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><h3 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h3><h3 id="AOP动态代理"><a href="#AOP动态代理" class="headerlink" title="AOP动态代理"></a>AOP动态代理</h3><h4 id="AOP的原理是什么？"><a href="#AOP的原理是什么？" class="headerlink" title="AOP的原理是什么？"></a>AOP的原理是什么？</h4><h4 id="JDK动态代理和CGLIB动态代理在实现上有什么区别？各有什么优劣"><a href="#JDK动态代理和CGLIB动态代理在实现上有什么区别？各有什么优劣" class="headerlink" title="JDK动态代理和CGLIB动态代理在实现上有什么区别？各有什么优劣"></a>JDK动态代理和CGLIB动态代理在实现上有什么区别？各有什么优劣</h4><h2 id="流程以及Bean生命周期"><a href="#流程以及Bean生命周期" class="headerlink" title="流程以及Bean生命周期"></a>流程以及Bean生命周期</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><h4 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h4><ol><li>用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。</li><li>DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）</li><li>DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</li><li>HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。</li><li>DispatcherServlet将模型数据填充到视图中</li><li>DispatcherServlet将结果响应给用户</li></ol><h3 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h3><h4 id="Spring-Bean-的完整生命周期"><a href="#Spring-Bean-的完整生命周期" class="headerlink" title="Spring Bean 的完整生命周期"></a>Spring Bean 的完整生命周期</h4><ol><li>Bean容器&#x2F;BeanFactory 通过对象的构造器或工厂方法先实例化 Bean；</li><li>再根据 Resource 中的信息再通过设定好的方法（典型的有setter，统称为BeanWrapper）对 Bean 设置属性值，得到 BeanDefintion 对象，然后 put 到 beanDefinitionMap 中，调用 getBean 的时候，从  beanDefinitionMap 里，拿出 Class 对象进行注入，同时，如果有依赖关系，将递归调用 getBean 方法，即依赖注入的过程。 </li><li>检查 xxxAware 相关接口，比如 BeanNameAware，BeanClassLoaderAware，ApplicationContextAware（ BeanFactoryAware）等等，如果有就调用相应的 setxxx 方法把所需要的xxx传入到 Bean 中。<br><strong>补充</strong>：关于 Aware ，Aware 就是感知的意思， Aware 的目的是为了让Bean获得Spring容器的服务。 实现了这类接口的 bean 会存在“意识感”，从而让容器调用 setxxx 方法把所需要的 xxx 传到 Bean 中。</li><li>此时检查是否存在有于 Bean 关联的任何  BeanPostProcessors， 执行 postProcessBeforeInitialization() 方法（前置处理器）。</li><li>如果 Bean 实现了InitializingBean接口（正在初始化的 Bean），执行 afterPropertiesSet() 方法。</li><li>检查是否配置了自定义的 init-method 方法，如果有就调用。</li><li>此时检查是否存在有于 Bean 关联的任何  BeanPostProcessors， 执行 postProcessAfterInitialization() 方法（后置处理器）。返回 wrapperBean（包装后的 Bean）。</li><li>这时就可以开始使用 Bean 了，当容器关闭时，会检查 Bean 是否实现了 DisposableBean 接口，如果有就调用 destory() 方法。</li><li>如果 Bean 配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ol><h4 id="Spring-是如何解决循环依赖的"><a href="#Spring-是如何解决循环依赖的" class="headerlink" title="Spring 是如何解决循环依赖的"></a>Spring 是如何解决循环依赖的</h4><p>三级缓存</p><h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h4 id="Resource和-Autowired注解有什么区别"><a href="#Resource和-Autowired注解有什么区别" class="headerlink" title="@Resource和@Autowired注解有什么区别"></a>@Resource和@Autowired注解有什么区别</h4><p>一、@Autowired有个required属性，可以配置为false，这种情况下如果没有找到对应的bean是不会抛异常的。@Inject和@Resource没有提供对应的配置，所以必须找到否则会抛异常。</p><p>二、 @Autowired和@Inject基本是一样的，因为两者都是使用AutowiredAnnotationBeanPostProcessor来处理依赖注入。但是@Resource是个例外，它使用的是CommonAnnotationBeanPostProcessor来处理依赖注入。当然，两者都是BeanPostProcessor。</p><p>@Autowired和@Inject</p><ul><li>默认 autowired by type</li><li>可以 通过@Qualifier 显式指定 autowired by qualifier name。</li><li>如果 autowired by type 失败（找不到或者找到多个实现），则退化为autowired by field name</li></ul><p>@Resource</p><ul><li>默认 autowired by field name</li><li>如果 autowired by field name失败，会退化为 autowired by type</li><li>可以 通过@Qualifier 显式指定 autowired by qualifier name</li><li>如果 autowired by qualifier name失败，会退化为 autowired by field name。但是这时候如果 autowired by field name失败，就不会再退化为autowired by type了。</li></ul><h2 id="Spring组件"><a href="#Spring组件" class="headerlink" title="Spring组件"></a>Spring组件</h2><h3 id="Filter和Interceptor的区别"><a href="#Filter和Interceptor的区别" class="headerlink" title="Filter和Interceptor的区别"></a>Filter和Interceptor的区别</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2022/202207042134792.webp" alt="mvc"></p><h4 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h4><p>主要作用：拦截用户请求，进行处理，比如判断用户登录情况、权限验证，只要针对Controller请求进行处理，是通过<code>HandlerInterceptor</code>。</p><p>Interceptor分两种情况，一种是对会话的拦截，实现spring的HandlerInterceptor接口并注册到mvc的拦截队列中，其中<code>preHandle()</code>方法在调用Handler之前进行拦截(上图步骤③)，<code>postHandle()</code>方法在视图渲染之前调用(上图步骤⑤)，<code>afterCompletion()</code>方法在返回相应之前执行；另一种是对方法的拦截，需要使用<code>@Aspect</code>注解，在每次调用指定方法的前、后进行拦截。</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>主要作用：过滤字符编码、做一些业务逻辑判断，主要用于对用户请求进行预处理，同时也可进行逻辑判断。</p><p>Filter在请求进入servlet容器执行service()方法之前就会经过filter过滤（上图步骤①），不像Intreceptor一样依赖于SpringMVC框架，只需要依赖于servlet。Filter启动是随WEB应用的启动而启动，只需要初始化一次，以后都可以进行拦截。</p><p>Filter有如下几个种类：</p><ul><li>用户授权Filter：检查用户请求，根据请求过滤用户非法请求；</li><li>日志Filter：记录某些特殊的用户请求；</li><li>解码Filter：对非标准编码的请求解码。</li></ul><h4 id="Filter和Interceptor的区别-1"><a href="#Filter和Interceptor的区别-1" class="headerlink" title="Filter和Interceptor的区别"></a>Filter和Interceptor的区别</h4><ol><li>Filter是基于函数回调（doFilter()方法）的，而Interceptor则是基于Java反射的（AOP思想）。</li><li>Filter依赖于Servlet容器，而Interceptor不依赖于Servlet容器。</li><li>Filter对几乎所有的请求起作用，而Interceptor只能对action请求起作用。</li><li>Interceptor可以访问Action的上下文，值栈里的对象，而Filter不能。</li><li>在action的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次。</li><li>Filter在过滤是只能对request和response进行操作，而interceptor可以对request、response、handler、modelAndView、exception进行操作。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903811874553869">Filter和Interceptor的区别</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="Spring" scheme="https://blog.elfred.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>系统设计面试题</title>
    <link href="https://blog.elfred.top/posts/ec3caae2.html"/>
    <id>https://blog.elfred.top/posts/ec3caae2.html</id>
    <published>2022-05-21T03:24:00.000Z</published>
    <updated>2025-03-08T14:46:55.112Z</updated>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="一、ES篇"><a href="#一、ES篇" class="headerlink" title="一、ES篇"></a>一、ES篇</h1><blockquote><p>Elasticsearch可以实现<strong>秒级</strong>的搜索，cluster是一种分布式的部署，极<strong>易扩展(scale )<strong>这样很容易使它处理PB级的数据库容量。最重要的是Elasticsearch是它搜索的结果可以按照分数进行排序，它能提供我们最</strong>相关</strong>的搜索结果（<strong>relevance</strong>) 。</p></blockquote><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>安装方便</strong>：没有其他依赖，下载后安装非常方便；只用修改几个参数就可以搭建起来一个集群</p></li><li><p><strong>JSON</strong>：输入&#x2F;输出格式为 JSON，意味着不需要定义 Schema，快捷方便</p></li><li><p><strong>RESTful</strong>：基本所有操作 ( 索引、查询、甚至是配置 ) 都可以通过 HTTP 接口进行</p></li><li><p><strong>分布式</strong>：节点对外表现对等（每个节点都可以用来做入口） 加入节点自动负载均衡</p></li><li><p><strong>多租户</strong>：可根据不同的用途分索引，可以同时操作多个索引</p></li><li><p><strong>支持超大数据</strong>： 可以扩展到 PB 级的结构化和非结构化数据 海量数据的近实时处理</p></li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><p><strong>分布式的搜索引擎</strong></p><p>分布式：Elasticsearch自动将海量数据分散到多台服务器上去存储和检索</p></li><li><p><strong>全文检索</strong></p><p>提供模糊搜索等自动度很高的查询方式，并进行相关性排名，高亮等功能</p></li><li><p><strong>数据分析引擎（分组聚合）</strong></p><p>社区网站，最近一周用户登录、最近一个月各功能使用情况</p></li><li><p><strong>对海量数据进行近实时（秒级）的处理</strong></p><p>海量数据的处理：因为是分布式架构，可以采用大量的服务器去存储和检索数据</p></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li><p><strong>搜索类</strong>场景</p><p>比如说人员检索、设备检索、App内的搜索、订单搜索。</p></li><li><p><strong>日志分析</strong>类场景</p><p>经典的ELK组合（<strong>Elasticsearch</strong>&#x2F;<strong>Logstash</strong>&#x2F;<strong>Kibana</strong>），实现<strong>日志收集</strong>，<strong>日志存储</strong>，<strong>日志分析</strong></p></li><li><p><strong>数据预警平台</strong>及数据分析场景</p><p>例如社区团购提示，当优惠的价格低于某个值时，自动触发通知消息，通知用户购买。</p><p>分析竞争对手商品销量Top10，供运营分析等等。</p></li><li><p>**商业BI(Business Intelligence)**系统</p><p>比如社区周边，需要分析某一地区用户消费金额及商品类别，输出相应的报表数据，并预测该地区的热卖商品，通过区域和人群特征划分进行定向推荐。Elasticsearch执行数据分析和挖掘，Kibana做数据可视化。</p></li></ul><h3 id="竞品分析"><a href="#竞品分析" class="headerlink" title="竞品分析"></a>竞品分析</h3><p><strong>Lucene</strong></p><p>Java编写的信息搜索工具包（Jar包），Lucene只是一个框架，熟练运用Lucene非常复杂。</p><p><strong>Solr</strong></p><p>基于<strong>Lucene</strong>的HTTP接口查询服务器，是一个封装了很多Lucene细节搜索引擎系统</p><p><strong>Elasticsearch</strong></p><p>基于<strong>Lucene</strong>分布式海量数据近实时搜索引擎。采用的策略是将每一个字段都编入索引，使其可以被搜索。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>1）Solr利用Zookeeper进行分布式管理，而Elasticsearch自身带有分布式协调管理功能</p><p>2）Solr比Elasticsearch实现更加全面，而Elasticsearch本身更注重于核心功能， 高级功能多由第三方插件提供</p><p>3）Solr在传统的搜索应用中表现好于Elasticsearch，而Elasticsearch在实时搜索应用方面比Solr表现好</p><p>目前主流依然是<strong>Elasticsearch</strong>7.x 最新的是7.8</p><p>​优化：<strong>默认集成JDK</strong>、升级Lucene8大幅提升<strong>TopK性能</strong>、引入熔断机制<strong>避免OOM</strong>发生</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h3><p>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。新版本的IKAnalyzer3.0则发展为 面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。</p><p>IK分词器3.0的特性如下：</p><ol><li>采用了特有的“正向迭代<strong>最细粒度</strong>切分算法“，具有<strong>60万</strong>字&#x2F;秒的高速处理能力。</li><li>采用了<strong>多子处理器</strong>分析模式，支持：英文字母（IP地址、Email、URL）、数字（日期，常用中文数量词，罗马数字，科学计数法），中文词汇（姓名、地名处理）等分词处理。</li><li>支持<strong>个人词条的优化</strong>的词典存储，更小的内存占用。</li><li>针对Lucene<strong>全文检索优化</strong>的查询分析器IKQueryParser；采用歧义分析算法优化查询关键字的搜索</li><li>排列组合，能极大的提高Lucene检索的命中率。</li></ol><ul><li><strong>扩展词典</strong>：ext_dict </li><li><strong>停用词典</strong>：stop_dict</li><li><strong>同义词典</strong>：same_dict</li></ul><h3 id="索引（类数据库）"><a href="#索引（类数据库）" class="headerlink" title="索引（类数据库）"></a>索引（类数据库）</h3><p>settings：设置索引库，定义索引库的分片数副本数等</p><h3 id="映射（类表设计）"><a href="#映射（类表设计）" class="headerlink" title="映射（类表设计）"></a>映射（类表设计）</h3><ul><li>字段的数据类型</li><li>分词器类型</li><li>是否要进行存储或者创造索引</li></ul><h3 id="文档（数据）"><a href="#文档（数据）" class="headerlink" title="文档（数据）"></a>文档（数据）</h3><ul><li>全量更新用Put</li><li>局部更新用Post</li></ul><h2 id="3、高级特性"><a href="#3、高级特性" class="headerlink" title="3、高级特性"></a>3、高级特性</h2><h3 id="映射高级"><a href="#映射高级" class="headerlink" title="映射高级"></a>映射高级</h3><h4 id="地理坐标点数据类型"><a href="#地理坐标点数据类型" class="headerlink" title="地理坐标点数据类型"></a><strong>地理坐标点数据类型</strong></h4><blockquote><p>地理坐标点是指地球表面可以用经纬度描述的一个点。 地理坐标点可以用来计算两个坐标间的距离，还可以判断一个坐标是否在一个区域中。地理坐标点需要显式声明对应字段类型为 geo_point</p></blockquote><h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h4><blockquote><p>使用dynamic mapping 来确定字段的数据类型并自动把新的字段添加到类型映射</p></blockquote><h3 id="DSL高级"><a href="#DSL高级" class="headerlink" title="DSL高级"></a>DSL高级</h3><ul><li><p><strong>查询所有(match_all query)</strong></p></li><li><p><strong>全文搜索(full-text query)</strong></p><ul><li>匹配搜索(match query)</li><li>短语搜索(match phrase query)</li><li>默认查询(query string)</li><li>多字段匹配搜索(multi match query)</li></ul></li><li><p><strong>词条级搜索(term-level query)</strong></p><ul><li>精确搜索term</li><li>集合搜索idx</li><li>范围搜索range</li><li>前缀搜索prefix</li><li>通配符搜索wildcard</li><li>正则搜索regexp</li><li>模糊搜索fuzzy</li></ul></li><li><p>复合搜索</p></li><li><p>排序<strong>sort</strong>&amp;分页<strong>size</strong>&amp;高亮<strong>highLight</strong>&amp;批量<strong>bluk</strong></p></li></ul><h3 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a><strong>聚合分析</strong></h3><blockquote><p>聚合分析是数据库中重要的功能特性，完成对一个查询的数据集中数据的聚合计算，如：找出某字段（或计算表达式的结果）的最大值、最小值，计算和、平均值等</p></blockquote><ul><li>对一个数据集求最大、最小、和、平均值等指标的聚合，在ES中称为<strong>指标聚合</strong> <strong>metric</strong></li><li>对查询出的数据进行<strong>分桶</strong>group by，再在<strong>桶</strong>上进行指标<strong>桶聚合</strong> <strong>bucketing</strong></li></ul><h3 id="智能搜索"><a href="#智能搜索" class="headerlink" title="智能搜索"></a><strong>智能搜索</strong></h3><ul><li>Term Suggester</li><li>Phrase Suggester</li><li>Completion Suggester</li><li>Context Suggester</li></ul><p>如果<strong>Completion Suggester</strong>已经到了零匹配，可以猜测用户有输入错误，这时候可以尝试一下<strong>Phrase Suggester</strong>。如果还是未匹配则尝试<strong>Term Suggester</strong>。</p><p>精准程度上(<strong>Precision</strong>)看： <strong>Completion &gt; Phrase &gt; Term</strong>， 而召回率上(Recall)则反之。</p><p>从性能上看，Completion Suggester是最快的，如果能满足业务需求，只用Completion Suggester做前缀匹配是最理想的。 Phrase和Term由于是做倒排索引的搜索，相比较而言性能应该要低不少，应尽量控制Suggester用到的索引的数据量，最理想的状况是经过一定时间预热后，索引可以全量map到内存。</p><h2 id="4、实战"><a href="#4、实战" class="headerlink" title="4、实战"></a>4、实战</h2><h3 id="写优化"><a href="#写优化" class="headerlink" title="写优化"></a>写优化</h3><ul><li><p><strong>副本数量</strong>0</p><p>首次 初始化数据时，将副本设置为0，写入完毕再改回，避免了副本建立索引的过程</p></li><li><p><strong>自动生成id</strong></p><p>可以避免写前判断是否存在的过程</p></li><li><p><strong>合理使用分词器</strong></p><p>binary类型不适用，title和text使用不同的分词器加快速度</p></li><li><p><strong>禁用评分，延长索引刷新间隔</strong></p></li><li><p><strong>将多个索引操作放入到batch进行处理</strong></p></li></ul><h3 id="读优化"><a href="#读优化" class="headerlink" title="读优化"></a>读优化</h3><ul><li><p>使用<strong>Filter</strong>代替Query，减少打分缓解，使用<strong>bool</strong>组合query和filter查询</p></li><li><p>对数据进行<strong>分组</strong>，按照日，月，年不同维度分组，查询可集中在局部index中</p></li></ul><h3 id="零停机索引重建方案"><a href="#零停机索引重建方案" class="headerlink" title="零停机索引重建方案"></a>零停机索引重建方案</h3><ul><li><p><strong>外部数据导入</strong></p><ul><li>通过MQ的web控制台或cli命令行，发送指定的MQ消息</li><li>MQ消息被微服务模块的消费者消费，触发ES数据重新导入功能</li><li>微服务模块从数据库里查询数据的总数及分页信息，并发送至MQ</li><li>微服务从MQ中根据分页信息从数据库获取到数据后，根据索引结构的定义，将数据组装成ES支持的JSON格式，并通过bulk命令将数据发送给Elasticsearch集群进行索引的重建工作。</li></ul></li><li><p><strong>基于Scroll+bulk+索引别名的方案</strong></p><ul><li><p>新建索引book_new，将mapping信息，settings信息等按新的要求全部定义好</p></li><li><p>使用scroll api将数据批量查询出来，指定scroll查询持续时间</p></li><li><p>采用bulk api将scoll查出来的一批数据，批量写入新索引</p></li><li><p>查询一批导入一批，注意每次都使用上次结束时的scoll_id</p></li><li><p>切换别名book_alias到新的索引book_new上面，此时Java客户端仍然使用别名访问，也不需要修</p><p>改任何代码，不需要停机。验证别名查询的是否为新索引的数据</p></li></ul></li><li><p><strong>Reindex API方案</strong></p><ul><li>Elasticsearch v6.3.1已经支持Reindex API，它对scroll、bulk做了一层封装，能够 对文档重建索引而不需要任何插件或外部工具。</li></ul></li></ul><p><strong>参与度</strong> &amp; <strong>灵活性</strong>：自研 &gt; scroll+bulk &gt; reindex</p><p><strong>稳定性</strong> &amp; <strong>可靠性</strong>：自研 &lt; scroll+bulk &lt; reindex</p><h3 id="DeepPaging性能解决方案"><a href="#DeepPaging性能解决方案" class="headerlink" title="DeepPaging性能解决方案"></a>DeepPaging性能解决方案</h3><blockquote><p>比如超级管理员，要给某个省份用户发送公告或者广告，最容易想到的就是利用 from + size 来实现，但这是不现实的</p></blockquote><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gne4vx9hu4j30x60gw0w5.jpg" alt="image-20210206212712493" style="zoom:60%;" /><h1 id="二：Docker-K8S篇"><a href="#二：Docker-K8S篇" class="headerlink" title="二：Docker&amp;K8S篇"></a>二：Docker&amp;K8S篇</h1><blockquote><p>chroot 是在 Unix 和 Linux 系统的一个操作，针对正在运作的软件行程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由 chroot 设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p></blockquote><p><strong>虚拟化技术_VMware 、VirtualBox、KVM</strong></p><p>虚拟化技术就是在操作系统上多加了一个虚拟化层（Hypervisor），可以将物理机的CPU、内存、硬盘、网络等资源进行虚拟化，再通过虚拟化出来的空间上安装操作系统，构建虚拟的应用程序执行环境。这就是我们通常说的虚拟机。</p><p>虚拟机的优点：</p><ul><li>提升IT效率、降低运维成本</li><li>更快地部署工作负责</li><li>提高服务器可用性</li></ul><p>虚拟机的缺点：</p><ul><li>占用资源较多、性能较差</li><li>扩展、迁移能力较差</li></ul><h3 id="Why-Docker"><a href="#Why-Docker" class="headerlink" title="Why Docker"></a>Why Docker</h3><p><strong>场景</strong></p><ul><li>开发人员在本地编写代码，并使用Docker容器与其他同事共享劳动成果。</li><li>使用Docker将应用程序推送到测试环境中，并执行自动和手动测试。</li><li>开发人员可以在开发环境中对其进行修复，然后将其重新部署到测试环境中以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境就像将更新的镜像推送到生产环境一样简单。</li></ul><p><strong>需求</strong></p><blockquote><p>快速，一致地交付应用程序、镜像打包环境，避免了环境不一致的问题，简化开发的生命周期，适合于快速迭代敏捷开发的场景</p></blockquote><img src="https://i.loli.net/2021/02/20/7hx2RcvUPKgXpma.png" alt="image-20210220140837929" style="zoom: 50%;" /><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>Docker引擎-守护进程</strong></p><p>​Docker使用C &#x2F; S架构 ：用户通过<strong>Docker客户端</strong>与Docker守护进程（Docker引擎）通过Unix套接字或者RESTAPI进行通信，<strong>Docker引擎</strong>完成了构建，运行和分发Docker容器的繁重工作</p><p><strong>Docker镜像-Dockerfile</strong></p><p>​Docker镜像类似于虚拟机镜像，是一个只读的模板，是创建Docker容器的基础</p><p>​镜像是基于联合（Union）文件系统的一种层式的结构，由一系列指令一步一步构建出来。</p><p>​比如：拷贝文件、执行命令</p><p><strong>Docker仓库-Hub</strong></p><p>Docker仓库可以分为<strong>公开仓库 （Public）</strong>和<strong>私有仓库（Private）</strong>两种形式。</p><p>最大的公开仓库是官方提供的<strong>Docker Hub</strong>，其中存放了数量庞大的镜像供用户下载。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>镜像</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull mysql:5.7.30</span></span><br><span class="line"><span class="number">5.7</span>.<span class="number">30</span>: Pulling <span class="keyword">from</span> library/mysql ……</span><br><span class="line">[root@localhost ~]<span class="comment"># docker images </span></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE </span><br><span class="line">mysql <span class="number">5.7</span>.<span class="number">30</span> <span class="number">9</span>cfcce23593a <span class="number">6</span> weeks ago <span class="number">448</span>MB</span><br><span class="line">[root@localhost ~]<span class="comment"># docker tag mysql:5.7.30 mysql5 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images </span></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE </span><br><span class="line">mysql5 latest <span class="number">9</span>cfcce23593a <span class="number">6</span> weeks ago <span class="number">448</span>MB </span><br><span class="line">mysql <span class="number">5.7</span>.<span class="number">30</span> <span class="number">9</span>cfcce23593a <span class="number">6</span> weeks ago <span class="number">448</span>MB</span><br><span class="line">[root@localhost ~]<span class="comment"># docker inspect mysql:5.7.30 </span></span><br><span class="line">[&#123;显示docker 详细信息&#125;]</span><br><span class="line">[root@localhost ~]<span class="comment"># docker search mysql</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker rmi mysql:5.7.30</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker push mysql[:TAG]</span></span><br></pre></td></tr></table></figure><p><strong>容器</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker create -it nginx</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker start 9cfcce23593a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看运行的容器 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps </span></span><br><span class="line"><span class="comment">#查看所有容器 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br><span class="line"><span class="comment">#新建并启动容器</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -it --rm --network host tomcat:8.5.56-jdk8-openjdk</span></span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ol><li><p>创建一个卷，待后边使用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="language-bash"> create test_volume</span></span><br></pre></td></tr></table></figure></li><li><p>分别启动2个容器挂在上卷,</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在<span class="number">2</span>个终端窗口启动<span class="number">2</span>个容器 </span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -it --<span class="built_in">rm</span> -v test_volume:/test nginx:latest /bin/bash</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -it --<span class="built_in">rm</span> -v test_volume:/test nginx:latest /bin/bash </span></span><br><span class="line">cd /test; </span><br><span class="line">touch a.txt </span><br><span class="line">ls /test <span class="comment"># 在两个容器中我们均可以看到我们创建的文件，shixian在多个容器之间实现数据共享</span></span><br></pre></td></tr></table></figure></li></ol><p>挂载在容器 &#x2F;test 目录内创建。 Docker <strong>不支持容器内安装点的相对路径</strong>。 多个容器可以在同一时间段内使用相同的卷。如果两个容器需要访问共享数据，例如，如果一个容器写入而另一个容器读取数据。 卷名 在驱动程序test必须唯一。这意味着不能将<strong>相同的卷名</strong>与两个不同的驱动程序一起使用。 如果我们指定了当前test_volume程序上已在使用的卷名，则Docker会假定我们要重用现有卷，并且不会返回错误。如果开始无 test_volume 则会创建这个卷当然除了使用卷，也可以使用将宿主机的文件映射到容器的卷，命令类似，只不过不用提前创建卷，而且数据会映射到宿主机上注意如果宿主机上的目录可以不存在，会在启动容器的时候创建</p><h1 id="三、Netty篇"><a href="#三、Netty篇" class="headerlink" title="三、Netty篇"></a>三、Netty篇</h1><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><h4 id="1、整体结构"><a href="#1、整体结构" class="headerlink" title="1、整体结构"></a>1、整体结构</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ijej9w7j30p00doaim.jpg" alt="image-20210504171606057" style="zoom:50%;" /><p>​</p><p>​<strong>Core 核心层</strong><br>​Core 核心层是 Netty 最精华的内容，它提供了底层网络通信的通用抽象和实现，包括事件模型、通用API、支持零拷贝的 ByteBuf 等。</p><p>​<strong>Protocol Support 协议支持层</strong><br>​协议支持层基本上覆盖了主流协议的编解码实现，如 HTTP、Protobuf、WebSocket、二进制等主流协议，此外 Netty 还支持自定义应用层协议。Netty 丰富的协议支持降低了用户的开发成本，基于 Netty 我们可以快速开发 HTTP、WebSocket 等服务。</p><p>​<strong>Transport Service 传输服务层</strong><br>​传输服务层提供了网络传输能力的定义和实现方法。它支持 Socket、HTTP 隧道、虚拟机管道等传输方式。Netty 对 TCP、UDP 等数据传输做了抽象和封装，用户可以更聚焦在业务逻辑实现上，而不必关系底层数据传输的细节。</p><h4 id="2、逻辑架构"><a href="#2、逻辑架构" class="headerlink" title="2、逻辑架构"></a>2、逻辑架构</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iiju6h8j30ry0o6dj0.jpg" alt="image-20210504171514089" style="zoom:50%;" /><p>​</p><p>​<strong>网络通信层</strong><br>​网络通信层的职责是执行网络 I&#x2F;O 的操作。它支持多种网络协议和 I&#x2F;O 模型的连接操作。当网络数据读取到内核缓冲区后，会触发各种网络事件，这些网络事件会分发给事件调度层进行处理。</p><p>网络通信层的核心组件包含<strong>BootStrap、ServerBootStrap、Channel</strong>三个组件。</p><p>​Bootstrap 是“引导”的意思，负责 Netty <strong>客户端程序</strong>的启动、初始化、服务器连接等过程，串联了 Netty 的其他核心组件。</p><p>​ServerBootStrap 用于<strong>服务端启动</strong>绑定本地端口，会绑定Boss 和 Worker两个 EventLoopGroup。</p><p>​Channel 的是“<strong>通道</strong>”，Netty Channel提供了基于NIO更高层次的抽象，如 register、bind、connect、read、write、flush 等。</p><p>​</p><p>​<strong>事件调度层</strong><br>​事件调度层的职责是通过 Reactor 线程模型对各类事件进行聚合处理，通过 Selector 主循环线程集成多种事件（ I&#x2F;O 事件、信号事件、定时事件等），实际的业务处理逻辑是交由服务编排层中相关的 Handler 完成。</p><p>事件调度层的核心组件包括 <strong>EventLoopGroup、EventLoop</strong>。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ijuqesxj30ke0ekgpj.jpg" alt="image-20210504171631793" style="zoom:50%;" /><p>​</p><p>​<strong>EventLoop</strong> 负责处理 Channel 生命周期内的所有 I&#x2F;O 事件，如 accept、connect、read、write 等 I&#x2F;O 事件</p><p>​①一个 EventLoopGroup 往往包含<strong>一个或者多个</strong> EventLoop。</p><p>​②EventLoop 同一时间会与一个Channel绑定，每个 EventLoop 负责<strong>处理一种类型 Channel</strong>。</p><p>​③Channel 在生命周期内可以对和多个 EventLoop 进行<strong>多次绑定和解绑</strong>。</p><p>​<strong>EventLoopGroup</strong> 是Netty 的<strong>核心处理引擎</strong>，本质是一个线程池，主要负责接收 I&#x2F;O 请求，并分配线程执行处理请求。通过创建不同的 EventLoopGroup 参数配置，就可以支持 Reactor 的三种线程模型：</p><p>​<strong>单线程模型</strong>：EventLoopGroup 只包含一个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</p><p>​<strong>多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</p><p>​<strong>主从多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 是主 Reactor，Worker 是从 Reactor，它们分别使用不同的 EventLoopGroup，主 Reactor 负责新的网络连接 Channel 创建，然后把 Channel 注册到从 Reactor。</p><p>​<strong>服务编排层</strong><br>​服务编排层的职责是负责组装各类服务，它是 Netty 的核心处理链，用以实现网络事件的动态编排和有序传播。</p><p>服务编排层的核心组件包括 <strong>ChannelPipeline、ChannelHandler、ChannelHandlerContext</strong>。</p><p>​<strong>ChannelPipeline</strong> 是 Netty 的核心编排组件，负责组装各种 ChannelHandler，ChannelPipeline 内部通过双向链表将不同的 ChannelHandler 链接在一起。当 I&#x2F;O 读写事件触发时，Pipeline 会依次调用 Handler 列表对 Channel 的数据进行拦截和处理。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6il759apj313s068abj.jpg" alt="image-20210504171749533" style="zoom:50%;" /><p>​</p><p>​客户端和服务端都有各自的 ChannelPipeline。客户端和服务端一次完整的请求：客户端出站（Encoder 请求数据）、服务端入站（Decoder接收数据并执行业务逻辑）、服务端出站（Encoder响应结果）。</p><p>​<strong>ChannelHandler</strong> 完成数据的编解码以及处理工作。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ilvuhupj30ye08e0vd.jpg" alt="image-20210504171829071" style="zoom:50%;" /><p>​<strong>ChannelHandlerContext</strong> 用于保存Handler 上下文，通过 HandlerContext 我们可以知道 Pipeline 和 Handler 的关联关系。HandlerContext 可以实现 Handler 之间的交互，HandlerContext 包含了 Handler 生命周期的所有事件，如 connect、bind、read、flush、write、close 等。同时，HandlerContext 实现了Handler通用的逻辑的模型抽象。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6imu2khlj31080gu0xc.jpg" alt="image-20210504171924019" style="zoom:50%;" /><h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><h4 id="1、五种IO模型的区别"><a href="#1、五种IO模型的区别" class="headerlink" title="1、五种IO模型的区别"></a><strong>1、五种IO模型的区别</strong></h4><p><strong>阻塞I&#x2F;O：（BIO）</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ingki0yj30kw0d6gmr.jpg" alt="image-20210504171959821" style="zoom:50%;" /><p>​</p><p>​应用进程向内核发起 I&#x2F;O 请求，发起调用的线程一直等待内核返回结果。一次完整的 I&#x2F;O 请求称为BIO（Blocking IO，阻塞 I&#x2F;O），所以 BIO 在实现异步操作时，只能使用多线程模型，一个请求对应一个线程。但是，<strong>线程的资源是有限且宝贵的，创建过多的线程会增加线程切换的开销。</strong></p><p><strong>同步非阻塞I&#x2F;O（NIO）：</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6inzsk9xj30lg0cign1.jpg" alt="image-20210504172029418" style="zoom:50%;" /><p>​</p><p>​应用进程向内核发起 I&#x2F;O 请求后不再会同步等待结果，而是会立即返回，通过轮询的方式获取请求结果。NIO 相比 BIO 虽然大幅提升了性能，但是轮询过程中大量的系统调用导致上下文切换开销很大。所以，单独使用非阻塞 I&#x2F;O 时效率并不高，而且<strong>随着并发量的提升，非阻塞 I&#x2F;O 会存在严重的性能浪费。</strong></p><p><strong>多路复用I&#x2F;O（select和poll）：</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iogl9x0j30ja0cqdh7.jpg" alt="image-20210504172057237" style="zoom:50%;" /><p>​</p><p>​多路复用实现了<strong>一个线程处理多个 I&#x2F;O 句柄的操作</strong>。多路指的是多个数据通道，复用指的是使用一个或多个固定线程来处理每一个 Socket。select、poll、epoll 都是 I&#x2F;O 多路复用的具体实现，线程一次 select 调用可以获取内核态中多个数据通道的数据状态。其中，select只负责等，recvfrom只负责拷贝，阻塞IO中可以对多个文件描述符进行阻塞监听，是一种非常高效的 I&#x2F;O 模型。</p><p><strong>信号驱动I&#x2F;O（SIGIO）：</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ioxthajj30ii0cemyk.jpg" alt="image-20210504172124965" style="zoom:50%;" /><p>​</p><p>​信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。</p><p><strong>异步I&#x2F;O（Posix.1的aio_系列函数）：</strong></p><p>​<img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ipcc12jj30lg0coabe.jpg" alt="image-20210504172148095" style="zoom:50%;" /></p><p>​当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。</p><h4 id="2、Reactor多线程模型"><a href="#2、Reactor多线程模型" class="headerlink" title="2、Reactor多线程模型"></a>2、Reactor多线程模型</h4><p>​Netty 的 I&#x2F;O 模型是基于<strong>非阻塞 I&#x2F;O</strong> 实现的，底层依赖的是 NIO 框架的<strong>多路复用器 Selector</strong>。采用 <strong>epoll 模式</strong>后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个<strong>事件分发器</strong>（Event Dispather），它负责将读写事件分发给对应的读写<strong>事件处理器</strong>（Event Handler）。事件分发器有两种设计模式：<strong>Reactor 和 Proactor</strong>，Reactor 采用同步 I&#x2F;O， Proactor 采用异步 I&#x2F;O。</p><p>​</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ipob6wjj30we0i4jz2.jpg" alt="image-20210504172207142" style="zoom:50%;" /><p>​Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I&#x2F;O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 <strong>select 或 epoll</strong> 来实现。</p><h4 id="3、拆包粘包问题"><a href="#3、拆包粘包问题" class="headerlink" title="3、拆包粘包问题"></a>3、拆包粘包问题</h4><p><strong>拆包</strong>TCP 传输协议是面向流的，没有数据包界限。<br><strong>MTU（Maxitum Transmission Unit）</strong> 是链路层一次最大传输数据的大小。MTU 一般来说大小为 1500 byte。<strong>MSS（Maximum Segement Size）</strong> 是指 TCP 最大报文段长度，它是传输层一次发送最大数据的大小。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iq4xdjtj30q407egnk.jpg" alt="image-20210504172233844" style="zoom:50%;" /><p>如上图所示，如果 MSS + TCP 首部 + IP 首部 &gt; MTU，那么数据包将会被拆分为多个发送。这就是<strong>拆包现象</strong>。</p><p><strong>Nagle 算法</strong><br>Nagle 算法可以理解为批量发送，也是我们平时编程中经常用到的优化思路，它是在数据未得到确认之前先写入缓冲区，等待数据确认或者缓冲区积攒到一定大小再把数据包发送出去。Netty 中为了使数据<strong>传输延迟最小化</strong>，就默认<strong>禁用了 Nagle 算法</strong>。</p><p><strong>拆包&#x2F;粘包的解决方案</strong></p><p>在客户端和服务端通信的过程中，服务端一次读到的数据大小是不确定的。需要确定边界：</p><p><strong>消息长度固定</strong><br><strong>特定分隔符</strong><br><strong>消息长度 + 消息内容</strong>(Netty)</p><h4 id="4、自定义协议"><a href="#4、自定义协议" class="headerlink" title="4、自定义协议"></a>4、自定义协议</h4><p>Netty 常用编码器类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MessageToByteEncoder <span class="comment">//对象编码成字节流；</span></span><br><span class="line"></span><br><span class="line">MessageToMessageEncoder <span class="comment">//一种消息类型编码成另外一种消息类型。</span></span><br></pre></td></tr></table></figure><p>Netty 常用解码器类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteToMessageDecoder/ReplayingDecoder <span class="comment">//将字节流解码为消息对象；</span></span><br><span class="line"></span><br><span class="line">MessageToMessageDecoder <span class="comment">//将一种消息类型解码为另外一种消息类型。</span></span><br></pre></td></tr></table></figure><p>编解码器可以分为<strong>一次解码器</strong>和<strong>二次解码器</strong>，一次解码器用于解决 <strong>TCP 拆包&#x2F;粘包问题</strong>，按协议解析后得到的字节数据。如果你需要对解析后的<strong>字节数据做对象模型</strong>的转换，这时候便需要用到二次解码器，同理编码器的过程是反过来的。</p><p><strong>Netty自定义协议内容：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">| 状态 1byte |        保留字段 4byte     |      数据长度 4byte     | </span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">|                   数据内容 （长度不定）                          |</span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>如何判断 ByteBuf 是否存在完整的报文？最常用的做法就是通过读取消息长度 dataLength 进行判断。如果 ByteBuf 的可读数据长度小于 dataLength，说明 ByteBuf 还不够获取一个完整的报文。</p><h4 id="5、WriteAndFlush"><a href="#5、WriteAndFlush" class="headerlink" title="5、WriteAndFlush"></a>5、WriteAndFlush</h4><p>​<img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iqnas8fj31400lkaj2.jpg" alt="image-20210504172303465" style="zoom:50%;" /></p><p>​①writeAndFlush 属于出站操作，它是从 Pipeline 的 Tail 节点开始进行事件传播，一直向前传播到 Head 节点。不管在 write 还是 flush 过程，Head 节点都中扮演着重要的角色。</p><p>​②write 方法并没有将数据写入 Socket 缓冲区，只是将数据写入到 ChannelOutboundBuffer 缓存中，ChannelOutboundBuffer 缓存内部是由单向链表实现的。</p><p>​③flush 方法才最终将数据写入到 Socket 缓冲区。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="1、堆外内存"><a href="#1、堆外内存" class="headerlink" title="1、堆外内存"></a>1、堆外内存</h4><p>​在 Java 中对象都是在堆内分配的，通常我们说的<strong>JVM 内存</strong>也就指的<strong>堆内内存</strong>，<strong>堆内内存</strong>完全被<strong>JVM 虚拟机</strong>所管理，JVM 有自己的垃圾回收算法，对于使用者来说不必关心对象的内存如何回收。<strong>堆外内存</strong>与堆内内存相对应，对于整个机器内存而言，除<strong>堆内内存以外部分即为堆外内存</strong>。堆外内存不受 JVM 虚拟机管理，直接由操作系统管理。使用堆外内存有如下几个优点：</p><ol><li>堆内内存由 JVM GC 自动回收内存，降低了 Java 用户的使用心智，堆外内存由于不受 JVM 管理，所以在一定程度上可以降低 GC 对应用运行时带来的影响。</li><li>堆外内存需要手动释放，这一点跟 C&#x2F;C++ 很像，稍有不慎就会造成应用程序内存泄漏，当出现内存泄漏问题时排查起来会相对困难。</li><li>当进行网络 I&#x2F;O 操作、文件读写时，堆内内存都需要转换为堆外内存，然后再与底层设备进行交互，所以直接使用堆外内存可以减少一次内存拷贝。</li><li>堆外内存可以方便实现进程之间、JVM 多实例之间的数据共享。</li></ol><p>​    在堆内存放的 DirectByteBuffer 对象并不大，仅仅包含堆外内存的地址、大小等属性，同时还会创建对应的 Cleaner 对象，通过 ByteBuffer 分配的堆外内存不需要手动回收，它可以被 JVM 自动回收。当堆内的 DirectByteBuffer 对象被 GC 回收时，Cleaner 就会用于回收对应的堆外内存。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ir0d0cmj30qw0hw41z.jpg" alt="image-20210504172324820" style="zoom:50%;" /><p>​从 DirectByteBuffer 的构造函数中可以看出，真正分配堆外内存的逻辑还是通过 unsafe.allocateMemory(size)，Unsafe 是一个非常不安全的类，它用于执行内存访问、分配、修改等<strong>敏感操作</strong>，可以越过 JVM 限制的枷锁。Unsafe 最初并不是为开发者设计的，使用它时虽然可以获取对底层资源的控制权，但也失去了安全性的保证，使用 Unsafe 一定要慎重（Java 中是不能直接使用 Unsafe 的，但是可以通过反射获取 Unsafe 实例）。Netty 中依赖了 Unsafe 工具类，是因为 Netty 需要与底层 Socket 进行交互，Unsafe 提升 Netty 的性能</p><p>​ 因为DirectByteBuffer 对象的回收需要依赖 Old GC 或者 Full GC 才能触发清理，如果长时间没有 GC执行，那么堆外内存即使不再使用，也会一直在占用内存不释放，很容易将机器的物理内存耗尽。-XX:MaxDirectMemorySize 指定堆外内存的上限大小，超出时触发GC，仍无法释放抛出OOM异常。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ir0d0cmj30qw0hw41z.jpg" alt="image-20210504172324820" style="zoom:50%;" /><p>​当初始化堆外内存时，内存中的对象引用情况如下图所示，first 是 Cleaner 类中的静态变量，Cleaner 对象在初始化时会加入 Cleaner 链表中。DirectByteBuffer 对象包含堆外内存的地址、大小以及 Cleaner 对象的引用，ReferenceQueue 用于保存需要回收的 Cleaner 对象。</p><p>​</p><h4 id="2、数据载体ByteBuf"><a href="#2、数据载体ByteBuf" class="headerlink" title="2、数据载体ByteBuf"></a>2、<strong>数据载体ByteBuf</strong></h4><p>JDK NIO 的 <strong>ByteBuffer</strong></p><ul><li>mark：为某个读取过的关键位置做标记，方便回退到该位置；</li><li>position：当前读取的位置；</li><li>limit：buffer 中有效的数据长度大小；</li><li>capacity：初始化时的空间容量。</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6irlptv0j30z408wabn.jpg" alt="image-20210504172358702" style="zoom:50%;" /><p>​第一，ByteBuffer 分配的长度是固定的，无法动态扩缩容，每次在存放数据的时候对容量大小做校验，扩容需要将已有的数据迁移。</p><p>​第二，ByteBuffer 只能通过 position 获取当前可操作的位置，因为读写共用的 position 指针，所以需要频繁调用 flip、rewind 方法切换读写状态。</p><p>Netty中的ByteBuf</p><ul><li><strong>废弃字节</strong>，表示已经丢弃的无效字节数据。</li><li><strong>可读字节</strong>，表示 ByteBuf 中可以被读取的字节内容，可以通过 writeIndex - readerIndex 计算得出。当读写位置重叠时时，表示 ByteBuf 已经不可读。</li><li><strong>可写字节</strong>，向 ByteBuf 中写入数据都会存储到可写字节区域。当 writeIndex 超过 capacity，表示 ByteBuf 容量不足，需要扩容。</li><li><strong>可扩容字节</strong>，表示 ByteBuf 最多还可以扩容多少字节，最多扩容到 maxCapacity 为止，超过 maxCapacity 再写入就会出错。</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j1t85zuj31020ds42m.jpg" alt="image-20210504173347000" style="zoom:50%;" /><p><strong>引用计数</strong></p><p>​当byteBuf当引用计数为 0，该 ByteBuf 可以被放入到对象池中，避免每次使用 ByteBuf 都重复创建。</p><p>​JVM 并不知道 Netty 的引用计数是如何实现的，当 ByteBuf 对象不可达时，一样会被 GC 回收掉，但是如果此时 ByteBuf 的引用计数不为 0，那么该对象就不会释放或者被放入对象池，从而发生了内存泄漏。Netty 会对分配的 ByteBuf 进行抽样分析，检测 ByteBuf 是否已经不可达且引用计数大于 0，判定内存泄漏的位置并输出到日志中，<strong>通过关注日志中 LEAK 关键字可以找到内存泄漏的具体对象</strong>。</p><h4 id="3、内存分配jemalloc"><a href="#3、内存分配jemalloc" class="headerlink" title="3、内存分配jemalloc"></a>3、<strong>内存分配jemalloc</strong></h4><p>​为了减少分配时产生的内部碎片和外部碎片，常见的内存分配算法<strong>动态内存分配</strong>、<strong>伙伴算法</strong>和<strong>Slab 算法</strong></p><p><strong>动态内存分配（DMA）</strong></p><p>​<strong>⾸次适应算法（first fit）</strong>，空闲分区链以地址递增的顺序将空闲分区以双向链表的形式连接在一起，从空闲分区链中找到第一个满足分配条件的空闲分区，然后从空闲分区中划分出一块可用内存给请求进程，剩余的空闲分区仍然保留在空闲分区链中。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j26fh88j30ni0ea41c.jpg" alt="image-20210504173407923" style="zoom:50%;" /><p>​<strong>循环首次适应算法（next fit）</strong>不再是每次从链表的开始进行查找，而是从上次找到的空闲分区的以后开始查找。查找效率提升，会产生更多的碎片。</p><p>​<strong>最佳适应算法（best fit）</strong>，空闲分区链以空闲分区大小递增的顺序将空闲分区以双向链表的形式连接在一起，每次从空闲分区链的开头进行查找。</p><p><strong>伙伴算法</strong>（外部碎片少，内部碎片多）</p><p>​是一种非常经典的内存分配算法，它采用了<strong>分离适配的设计思想</strong>，将物理内存按照 2 的次幂进行划分，内存分配时也是按照 2 的次幂大小进行按需分配</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j2m0rr1j30ly0iugnk.jpg" alt="image-20210504173433749" style="zoom:50%;" /><ol><li>首先需要找到存储 2^4 连续 Page 所对应的链表，即数组下标为 4；</li><li>查找 2^4 链表中是否有空闲的内存块，如果有则分配成功；</li><li>如果 2^4 链表不存在空闲的内存块，则继续沿数组向上查找，即定位到数组下标为 5 的链表，链表中每个节点存储 2^5 的连续 Page；</li><li>如果 2^5 链表中存在空闲的内存块，则取出该内存块并将它分割为 2 个 2^4 大小的内存块，其中一块分配给进程使用，剩余的一块链接到 2^4 链表中。</li></ol><p><strong>Slab 算法（解决伙伴算法内部碎片问题）</strong></p><p>​Slab 算法在伙伴算法的基础上，对小内存的场景专门做了优化，采用了内存池的方案，解决内部碎片问题。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j3160yuj30rw0eo77o.jpg" alt="image-20210504173454562" style="zoom:50%;" /><p>在 Slab 算法中维护着大小不同的 Slab 集合，将这块内存划分为大小相同的 slot，不会对内存块再进行合并，同时使用位图 bitmap 记录每个 slot 的使用情况。</p><p>​kmem_cache 中包含三个 Slab 链表：<strong>完全分配使用 slab_full</strong>、<strong>部分分配使用 slab_partial</strong>和<strong>完全空闲 slabs_empty</strong>，这三个链表负责内存的分配和释放。Slab 算法是基于对象进行内存管理的，它把相同类型的对象分为一类。当分配内存时，从 Slab 链表中划分相应的内存单元；单个 Slab 可以在不同的链表之间移动，例如当一个 Slab 被分配完，就会从 slab_partial 移动到 slabs_full，当一个 Slab 中有对象被释放后，就会从 slab_full 再次回到 slab_partial，所有对象都被释放完的话，就会从 slab_partial 移动到 slab_empty。当<strong>释放内存时，Slab 算法并不会丢弃已经分配的对象，而是将它保存在缓存中，当下次再为对象分配内存时，直接会使用最近释放的内存块</strong>。</p><h4 id="4、jemalloc-架构"><a href="#4、jemalloc-架构" class="headerlink" title="4、jemalloc 架构"></a>4、jemalloc 架构</h4><ul><li>内存是由一定数量的 arenas 负责管理，线程均匀分布在 arenas 当中；</li><li>每个 arena 都包含一个 bin 数组，每个 bin 管理不同档位的内存块；</li><li>每个 arena 被划分为若干个 chunks，每个 chunk 又包含若干个 runs，每个 run 由连续的 Page 组成，run 才是实际分配内存的操作对象；</li><li>每个 run 会被划分为一定数量的 regions，在小内存的分配场景，region 相当于用户内存；</li><li>每个 tcache 对应一个 arena，tcache 中包含多种类型的 bin。</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j3160yuj30rw0eo77o.jpg" alt="image-20210504173454562" style="zoom:50%;" /><p><strong>内存管理Arena</strong> ，内存由一定数量的 arenas 负责管理。每个用户线程采用 round-robin 轮询的方式选择可用的 arena 进行内存分配。</p><p><strong>分级管理Bin</strong>，每个 bin 管理的内存大小是按分类依次递增。<strong>jemalloc 中小内存的分配是基于 Slab 算法</strong>完成的，会产生不同类别的内存块。</p><p><strong>Page集合chunk</strong>，chunk 以 Page 为单位管理内存。每个 chunk 可被用于多次小内存的申请，但是在大内存分配的场景下只能分配一次。</p><p><strong>实际分配单位run</strong>，run 结构具体的大小由不同的 bin 决定，例如 8 字节的 bin 对应的 run 只有一个 Page，可以从中选取 8 字节的块进行分配。</p><p><strong>run 细分region</strong>，每个 run 会将划分为若干个等长的 region，每次内存分配也是按照 region 进行分发。</p><p><strong>tcache 是每个线程私有的缓存</strong>，tcache 每次从 arena 申请一批内存，在分配内存时首先在 tcache 查找，避免锁竞争，分配失败才会通过 run 执行内存分配。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u1jn9b3j31e80hqjt5.jpg" alt="image-20211205121406792"></p><p>Small 场景，如果请求分配内存的大小小于 arena 中的最小的 bin，那么优先从线程中对应的 tcache 中进行分配。首先确定查找对应的 tbin 中是否存在缓存的内存块，如果存在则分配成功，否则找到 tbin 对应的 arena，从 arena 中对应的 bin 中分配 region 保存在 tbin 的 avail 数组中，最终从 availl 数组中选取一个地址进行内存分配，当内存释放时也会将被回收的内存块进行缓存。</p><p>Large 场景的内存分配与 Smalll 类似，如果请求分配内存的大小大于 arena 中的最小的 bin，但是不大于 tcache 中能够缓存的最大块，依然会通过 tcache 进行分配，但是不同的是此时会分配 chunk 以及所对应的 run，从 chunk 中找到相应的内存空间进行分配。内存释放时也跟 samll 场景类似，会把释放的内存块缓存在 tacache 的 tbin 中。此外还有一种情况，当请求分配内存的大小大于tcache 中能够缓存的最大块，但是不大于 chunk 的大小，那么将不会采用 tcache 机制，直接在 chunk 中进行内存分配。</p><p>Huge 场景，如果请求分配内存的大小大于 chunk 的大小，那么直接通过 mmap 进行分配，调用 munmap 进行回收。</p><h4 id="5、内存池设计（待补充）"><a href="#5、内存池设计（待补充）" class="headerlink" title="5、内存池设计（待补充）"></a>5、内存池设计（待补充）</h4><h4 id="6、Recycle对象池（待补充）"><a href="#6、Recycle对象池（待补充）" class="headerlink" title="6、Recycle对象池（待补充）"></a>6、Recycle对象池（待补充）</h4><h4 id="7、零拷贝技术"><a href="#7、零拷贝技术" class="headerlink" title="7、零拷贝技术"></a>7、零拷贝技术</h4><ol><li>当用户进程发起 read() 调用后，上下文从用户态切换至内核态。DMA 引擎从文件中读取数据，并存储到内核态缓冲区，这里是<strong>第一次数据拷贝</strong>。</li><li>请求的数据从内核态缓冲区拷贝到用户态缓冲区，然后返回给用户进程。<strong>第二次数据拷贝</strong>的过程同时，会导致上下文从内核态再次切换到用户态。</li><li>用户进程调用 send() 方法期望将数据发送到网络中，用户态会再次切换到内核态，<strong>第三次数据拷贝</strong>请求的数据从用户态缓冲区被拷贝到 Socket 缓冲区。</li><li>最终 send() 系统调用结束返回给用户进程，发生了第四次上下文切换。<strong>第四次拷贝会异步执行</strong>，从 Socket 缓冲区拷贝到协议引擎中。</li></ol><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jlghxe0j30t00fsjtw.jpg" alt="image-20210504175240348" style="zoom:50%;" /><p>​<strong>在 Linux 中</strong>系统调用 sendfile() 可以实现将数据从一个文件描述符传输到另一个文件描述符，从而实现了零拷贝技术。</p><p>​<strong>在 Java 中</strong>也使用了零拷贝技术，它就是 NIO FileChannel 类中的 transferTo() 方法，它可以将数据从 FileChannel 直接传输到另外一个 Channel。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jm8q3yej311c0h6q7v.jpg" alt="image-20210504175323875" style="zoom:50%;" /><p><strong>Netty 中的零拷贝</strong>技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化，主要体现在以下 5 个方面：</p><ul><li>堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝。</li><li>CompositeByteBuf 类，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。</li><li>通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。</li><li>ByteBuf.slice ，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。</li><li>Netty 使用 封装了transferTo() 方法 FileRegion，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝。</li></ul><h3 id="高性能数据结构"><a href="#高性能数据结构" class="headerlink" title="高性能数据结构"></a>高性能数据结构</h3><h4 id="1、FastThreadLocal"><a href="#1、FastThreadLocal" class="headerlink" title="1、FastThreadLocal"></a>1、FastThreadLocal</h4><p>​ThreadLocal 可以理解为线程本地变量。ThreadLocal 为变量在每个线程中都创建了一个副本，该副本只能被当前线程访问，多线程之间是隔离的，变量不能在多线程之间共享。这样每个线程修改变量副本时，不会对其他线程产生影响。</p><p>​既然多线程访问 ThreadLocal 变量时都会有自己独立的实例副本，那么很容易想到的方案就是在 ThreadLocal 中维护一个 Map，记录线程与实例之间的映射关系。当新增线程和销毁线程时都需要更新 Map 中的映射关系，因为会存在多线程并发修改，所以需要保证 Map 是线程安全的。但是在高并发的场景并发修改 Map 需要加锁，势必会降低性能。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jmqtl1hj30q60dmtck.jpg" alt="image-20210504175349901" style="zoom:50%;" /><p>​JDK 为了避免加锁，采用了相反的设计思路。以 Thread 入手，在 Thread 中维护一个 Map，记录 ThreadLocal 与实例之间的映射关系，这样在同一个线程内，Map 就不需要加锁了。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jmyxnylj30ns06adgu.jpg" alt="image-20210504175406824" style="zoom:50%;" /><p>​ThreadLocalMap 是一种使用线性探测法实现的哈希表，底层采用数组存储数据，通过魔数0x61c88647来使散列更加平衡。ThreadLocalMap 初始化一个长度为 16 的 Entry 数组。与 HashMap 不同的是，Entry 的 key 就是 ThreadLocal对象本身，value 就是用户具体需要存储的值。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jncecy1j30yy0eejtq.jpg" alt="image-20210504175428964" style="zoom:50%;" /><p>​Entry 继承自弱引用类 WeakReference，Entry 的 key 是弱引用，value 是强引用。在 JVM 垃圾回收时，只要发现了弱引用的对象，不管内存是否充足，都会被回收。那么为什么 Entry 的 key 要设计成弱引用呢？如果 key 都是强引用，当线 ThreadLocal 不再使用时，然而 ThreadLocalMap 中还是存在对 ThreadLocal 的强引用，那么 GC 是无法回收的，从而造成内存泄漏。</p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4umi0759j30hi0a03zd.jpg" alt="img" style="zoom: 67%;" /><p>​虽然 Entry 的 key 设计成了弱引用，但是当 ThreadLocal不再使用(<strong>业务逻辑走完，但是由于线程复用导致线程并没有结束</strong>)被 GC 回收后，ThreadLocalMap 中可能出现 Entry 的 key 为 NULL，那么 Entry 的 value 一直会强引用数据而得不到释放，只能等待线程销毁。那么应该如何避免 ThreadLocalMap 内存泄漏呢？ThreadLocal 已经帮助我们做了一定的保护措施，在执行 ThreadLocal.set()&#x2F;get() 方法时，ThreadLocal 会清除 ThreadLocalMap 中 key 为 NULL 的 Entry 对象，让它还能够被 GC 回收。除此之外，当线程中某个 ThreadLocal 对象不再使用时，立即调用 remove() 方法删除 Entry 对象。如果是在异常的场景中，应在 finally 代码块中进行清理，保持良好的编码意识。在Netty中，可以方便的使用FashThreadLocal来防止内存泄漏</p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4ux5gohpj30hs0ajjs1.jpg" alt="img" style="zoom:67%;" /><p><strong>FastThreadLocal</strong></p><p>​FastThreadLocal 使用 Object 数组替代了 Entry 数组，Object[0] 存储的是一个Set&lt;FastThreadLocal&lt;?&gt;&gt; 集合，从数组下标 1 开始都是直接存储的 value 数据，不再采用 ThreadLocal 的键值对形式进行存储。主要是针对set方法，增加了两个额外的行为。</p><ol><li>找到数组下标 index 位置，设置新的 value。</li><li>将 <strong>FastThreadLocal 对象保存到待清理的 Set 中</strong>。</li></ol><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jnu8l6aj315k060wfi.jpg" alt="image-20210504175457264" style="zoom:50%;" /><ul><li><strong>高效查找</strong>。FastThreadLocal 在定位数据的时候可以直接根据数组下标 index 获取，时间复杂度 O(1)。而 JDK 原生的 ThreadLocal 在数据较多时哈希表很容易发生 Hash 冲突，线性探测法在解决 Hash 冲突时需要不停地向下寻找，效率较低。此外，FastThreadLocal 相比 ThreadLocal 数据扩容更加简单高效，FastThreadLocal 以 index 为基准向上取整到 2 的次幂作为扩容后容量，然后把原数据拷贝到新数组。而 ThreadLocal 由于采用的哈希表，所以在扩容后需要再做一轮 rehash。</li><li><strong>安全性更高</strong>。JDK 原生的 ThreadLocal 使用不当可能造成内存泄漏，只能等待线程销毁。在使用线程池的场景下，ThreadLocal 只能通过主动检测的方式防止内存泄漏，从而造成了一定的开销。然而 FastThreadLocal 不仅提供了 remove() 主动清除对象的方法，而且在线程池场景中 Netty 还封装了 FastThreadLocalRunnable，<strong>任务执行完毕后一定会执行 FastThreadLocal.removeAll() 将 Set 集合中所有 FastThreadLocal 对象都清理掉</strong></li></ul><h4 id="2、HashedTimerWheel"><a href="#2、HashedTimerWheel" class="headerlink" title="2、HashedTimerWheel"></a>2、<strong>HashedTimerWheel</strong></h4><p>​生成月统计报表、每日得分结算、邮件定时推送</p><p>​定时任务三种形式：</p><p>​1、按固定周期定时执行</p><p>​2、延迟一定时间后执行</p><p>​3、指定某个时刻执行</p><p>​定时任务的三个关键方法：</p><p>​Schedule 新增任务至任务集合；</p><p>​Cancel 取消某个任务；</p><p>​Run 执行到期的任务</p><p>JDK自带的三种定时器：<strong>Timer</strong>、<strong>DelayedQueue</strong> 和 <strong>ScheduledThreadPoolExecutor</strong></p><pre><code>Timer小根堆队列，deadline 任务位于堆顶端，弹出的始终是最优先被执行的任务。Run 操作时间复杂度 O(1)，Schedule 和Cancel 操作的时间复杂度都是 O(logn)。</code></pre><p>不论有多少任务被加入数组，始终由 异步线程TimerThread 负责处理。TimerThread 会定时轮询 TaskQueue 中的任务，如果堆顶的任务的 deadline 已到，那么执行任务；如果是周期性任务，执行完成后重新计算下一次任务的 deadline，并再次放入小根堆；如果是单次执行的任务，执行结束后会从 TaskQueue 中删除。</p><p>​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DelayedQueue 采用优先级队列 PriorityQueue延迟获取对象的阻塞队列。DelayQueue中的每个对象都必须实现Delayed 接口，并重写 compareTo 和 getDelay 方法。</span><br></pre></td></tr></table></figure><p>DelayQueue 提供了 put() 和 take() 的阻塞方法，可以向队列中添加对象和取出对象。对象被添加到 DelayQueue 后，会根据 compareTo() 方法进行优先级排序。getDelay() 方法用于计算消息延迟的剩余时间，只有 getDelay &lt;&#x3D;0 时，该对象才能从 DelayQueue 中取出。</p><p>DelayQueue 在日常开发中最常用的场景就是实现重试机制。例如，接口调用失败或者请求超时后，可以将当前请求对象放入 DelayQueue，通过一个异步线程 take() 取出对象然后继续进行重试。如果还是请求失败，继续放回 DelayQueue。可以设置重试的最大次数以及采用指数退避算法设置对象的 deadline，如 2s、4s、8s、16s ……以此类推。DelayQueue的时间复杂度和Timer基本一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了解决 Timer 的设计缺陷，JDK 提供了功能更加丰富的 ScheduledThreadPoolExecutor，多线程、相对时间、对异常</span><br></pre></td></tr></table></figure><p>​Timer 是单线程模式。如果某个 TimerTask 执行时间很久，会影响其他任务的调度。</p><p>​Timer 的任务调度是基于系统绝对时间的，如果系统时间不正确，可能会出现问题。</p><p>​TimerTask 如果执行出现异常，Timer 并不会捕获，会导致线程终止，其他任务永远不会执行。</p><p><strong>时间轮原理分析</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jo7abpbj30wi0ciacs.jpg" alt="image-20210504175518335" style="zoom:50%;" /><p>根据任务的到期时间进行取余和取模，然后根据取余结果将任务分布到不同的 slot 中，每个slot中根据round值决定是否操作，每次轮询到指定slot时，总时遍历最少round的对象进行执行，这样新增、执行两个操作的时间复杂度都近似O(1)。如果冲突较大可以增加数组长度，或者采用多级时间轮的方式处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashedWheelTimer</span><span class="params">(</span></span><br><span class="line"><span class="params">        ThreadFactory threadFactory, //线程池，但是只创建了一个线程</span></span><br><span class="line"><span class="params">        <span class="type">long</span> tickDuration, //时针每次 tick 的时间，相当于时针间隔多久走到下一个 slot</span></span><br><span class="line"><span class="params">        TimeUnit unit, //表示 tickDuration 的时间单位，tickDuration * unit</span></span><br><span class="line"><span class="params">        <span class="type">int</span> ticksPerWheel,  //时间轮上一共有多少个 slot，默认 <span class="number">512</span> 个。</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> leakDetection,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> maxPendingTimeouts)</span> &#123;<span class="comment">//最大允许等待任务数</span></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    wheel = createWheel(ticksPerWheel); <span class="comment">// 创建时间轮的环形数组结构</span></span><br><span class="line">    mask = wheel.length - <span class="number">1</span>; <span class="comment">// 用于快速取模的掩码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> unit.toNanos(tickDuration); <span class="comment">// 转换成纳秒处理</span></span><br><span class="line">    workerThread = threadFactory.newThread(worker); <span class="comment">// 创建工作线程</span></span><br><span class="line">    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="built_in">this</span>) : <span class="literal">null</span>; <span class="comment">// 是否开启内存泄漏检测</span></span><br><span class="line">    <span class="built_in">this</span>.maxPendingTimeouts = maxPendingTimeouts; <span class="comment">// 最大允许等待任务数，HashedWheelTimer 中任务超出该阈值时会抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jofq9r4j315i0fmq96.jpg" alt="image-20210504175531294" style="zoom:50%;" /><p>​<strong>时间轮空推进问题</strong></p><p>​Netty 中的时间轮是通过固定的时间间隔 tickDuration 进行推动的，如果长时间没有到期任务，那么会存在时间轮空推进的现象，从而造成一定的性能损耗。此外，如果任务的到期时间跨度很大，例如 A 任务 1s 后执行，B 任务 6 小时之后执行，也会造成空推进的问题。</p><p><strong>Kafka解决方案</strong></p><p>​<strong>为了解决空推进的问题</strong>，Kafka 借助 JDK 的 DelayQueue 来负责推进时间轮。DelayQueue 保存了时间轮中的每个 Bucket，并且根据 Bucket 的到期时间进行排序，最近的到期时间被放在 DelayQueue 的队头。Kafka 中会有一个线程来读取 DelayQueue 中的任务列表，<strong>如果时间没有到，那么 DelayQueue 会一直处于阻塞状态</strong>，从而解决空推进的问题。虽然DelayQueue 插入和删除的性能不是很好，但这其实就是一种权衡的策略，但是DelayQueue 只存放了 Bucket，Bucket 的数量并不多，相比空推进带来的影响是利大于弊的。</p><p>​<strong>为了解决任务时间跨度很大的问题</strong>，Kafka 引入了层级时间轮，如下图所示。当任务的 deadline 超出当前所在层的时间轮表示范围时，就会尝试将任务添加到上一层时间轮中，跟钟表的时针、分针、秒针的转动规则是同一个道理。</p><h4 id="3、MpscQueue"><a href="#3、MpscQueue" class="headerlink" title="3、MpscQueue"></a>3、MpscQueue</h4><h4 id="4、select、poll、epoll的区别"><a href="#4、select、poll、epoll的区别" class="headerlink" title="4、select、poll、epoll的区别"></a>4、select、poll、epoll的区别</h4><p><strong>select</strong> （windows）**poll **(linux)本质上和select没有区别，查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。</p><p>**epoll **支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p><strong>Epoll空轮询漏洞</strong></p><p>在 JDK 中， Epoll 的实现是存在漏洞的，即使 Selector 轮询的事件列表为空，NIO 线程一样可以被唤醒，导致 CPU 100% 占用。实际上 Netty 并没有从根源上解决该问题，而是巧妙地规避了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/*事件轮询的持续时间大于等于 timeoutMillis*/</span>) &#123;</span><br><span class="line">    selectCnt = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/*不正常的次数 selectCnt 达到阈值 512*/</span>) &#123;</span><br><span class="line">    <span class="comment">//重建Select并且SelectionKey重新注册到新Selector上</span></span><br><span class="line">  selector = selectRebuildSelector(selectCnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioEventLoop 线程的可靠性至关重要，一旦 NioEventLoop 发生阻塞或者陷入空轮询，就会导致整个系统不可用。</p><h1 id="四、LEETCODE"><a href="#四、LEETCODE" class="headerlink" title="四、LEETCODE"></a>四、LEETCODE</h1><h3 id="【Python语法】"><a href="#【Python语法】" class="headerlink" title="【Python语法】"></a>【Python语法】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br><span class="line">    reduce(<span class="keyword">lambda</span> x,y:x * y,ns) <span class="comment"># 数组之乘积 (ns[0] * ns[1]) * ns[2]</span></span><br><span class="line">    reduce(<span class="keyword">lambda</span> x,y:x + y,ns) <span class="comment"># 数组之和</span></span><br><span class="line"><span class="comment"># 记忆化搜索</span></span><br><span class="line"><span class="meta">@functools.lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">res = helper(<span class="number">0</span>,N,<span class="number">0</span>)</span><br><span class="line">helper.cache_clear()</span><br><span class="line"><span class="built_in">tuple</span>(ns) 可以<span class="built_in">hash</span>做参数</span><br><span class="line"><span class="comment"># 大根堆</span></span><br><span class="line">q = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:-x,ns))</span><br><span class="line">heapq.heapify(q)</span><br><span class="line">key = -heapq.heappop(q)</span><br><span class="line"><span class="comment"># 过滤函数</span></span><br><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br><span class="line">    <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="number">2</span> &lt; x &lt; <span class="number">10</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>, <span class="built_in">range</span>(<span class="number">18</span>))</span><br><span class="line">    <span class="built_in">filter</span>(dfs, <span class="built_in">range</span>(<span class="built_in">len</span>(graph)))</span><br><span class="line"><span class="comment"># 除数</span></span><br><span class="line">div, mod = <span class="built_in">divmod</span>(<span class="built_in">sum</span>(ns), <span class="number">4</span>)</span><br><span class="line">random.randint(i,<span class="built_in">len</span>(<span class="variable language_">self</span>.ns)-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#第一个降序，第二个升序</span></span><br><span class="line"><span class="built_in">sorted</span>(pss,key = <span class="keyword">lambda</span> x:[x[<span class="number">0</span>],-x[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不可变str 常见函数</span></span><br><span class="line">split(sep=<span class="literal">None</span>, maxsplit=-<span class="number">1</span>)  <span class="comment"># 以sep来分割字符串</span></span><br><span class="line">strip([chars])  <span class="comment"># 去除首末两端的字符, 默认是 \r,\n,&quot; &quot;</span></span><br><span class="line">join(iterable)  <span class="comment"># 将iterable内的元素拼接成字符串,如&#x27;,&#x27;.join([&#x27;leet&#x27;, &#x27;code&#x27;])=&quot;leet,code&quot;</span></span><br><span class="line">replace(old, new[, count])  <span class="comment"># 字符串替换, old to new</span></span><br><span class="line">count(sub[, start[, end]])  <span class="comment"># 统计子字符串sub的个数</span></span><br><span class="line">startswith(prefix[, start[, end]])  <span class="comment"># 以prefix开始的字符串</span></span><br><span class="line">endswith(suffix[, start[, end]])  <span class="comment"># 以suffix结束的字符串</span></span><br><span class="line">cs <span class="keyword">in</span> chrs: <span class="comment"># chrs 中包含 cs </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deque 常见函数</span></span><br><span class="line">queue = deque([iterable[, maxlen]])</span><br><span class="line">queue.append(val)  <span class="comment"># 往右边添加一个元素</span></span><br><span class="line">queue.appendleft(val)  <span class="comment"># 往左边添加一个元素</span></span><br><span class="line">queue.clear()  <span class="comment"># 清空队列</span></span><br><span class="line">queue.count(val)  <span class="comment"># 返回指定元素的出现次数</span></span><br><span class="line">queue.insert(val[, start[, stop]])  <span class="comment"># 在指定位置插入元素</span></span><br><span class="line">queue.pop()  <span class="comment"># 获取最右边一个元素，并在队列中删除</span></span><br><span class="line">queue.popleft()  <span class="comment"># 获取最左边一个元素，并在队列中删除</span></span><br><span class="line">queue.reverse()  <span class="comment"># 队列反转</span></span><br><span class="line">queue.remove(val)  <span class="comment"># 删除指定元素</span></span><br><span class="line">queue.rotate(n=<span class="number">1</span>)  <span class="comment"># 把右边元素放到左边</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list 常见函数</span></span><br><span class="line">lst.sort(*, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line">lst.append(val)  <span class="comment"># 也可以 lst = lst + [val]</span></span><br><span class="line">lst.clear()  <span class="comment"># 清空列表</span></span><br><span class="line">lst.count(val)  <span class="comment"># val个数</span></span><br><span class="line">lst.pop(val=lst[-<span class="number">1</span>])  <span class="comment"># (默认)从末端移除一个值</span></span><br><span class="line">lst.remove(val)  <span class="comment"># 移除 val</span></span><br><span class="line">lst.reverse()  <span class="comment"># 反转</span></span><br><span class="line">lst.insert(i, val)  <span class="comment"># 在 i 处插入 val</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典dict 常见函数</span></span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span> : value) <span class="comment"># 取到不存在的值时不会报错，用&#123;&#125;时、需要设置get的default值</span></span><br><span class="line">pop(key[, default])  <span class="comment"># 通过键去删除键值对(若没有该键则返回default(没有设置default则报错))</span></span><br><span class="line">setdefault(key[, default])  <span class="comment"># 设置默认值</span></span><br><span class="line">update([other])  <span class="comment"># 批量添加</span></span><br><span class="line">get(key[, default])  <span class="comment"># 通过键获取值(若没有该键可设置默认值, 预防报错)</span></span><br><span class="line">clear()  <span class="comment"># 清空字典</span></span><br><span class="line">keys()  <span class="comment"># 将字典的键组成新的可迭代对象</span></span><br><span class="line">values()  <span class="comment"># 将字典中的值组成新的可迭代对象</span></span><br><span class="line">items()  <span class="comment"># 将字典的键值对凑成一个个元组, 组成新的可迭代对象</span></span><br><span class="line">dict1 = dict2 <span class="comment">#两个字典完全相等，滑窗时可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合set 常见函数</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="keyword">lambda</span> : value)</span><br><span class="line">add(elem)  <span class="comment"># 向集合中添加数据</span></span><br><span class="line">update(*others)  <span class="comment"># 迭代着增加</span></span><br><span class="line">clear()  <span class="comment"># 清空集合</span></span><br><span class="line">discard(elem)  <span class="comment"># 删除集合中指定的值(不存在则不删除)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆heapq 常见函数</span></span><br><span class="line">heap = []  <span class="comment"># 建堆</span></span><br><span class="line">heapq.heappush(heap,item)  <span class="comment"># 往堆中插入新值</span></span><br><span class="line">heapq.heappop(heap)  <span class="comment"># 弹出最小的值</span></span><br><span class="line">heap[<span class="number">0</span>]  <span class="comment"># 查看堆中最小的值, 不弹出</span></span><br><span class="line">heapq.heapify(x)  <span class="comment"># 以线性时间将一个列表转为堆</span></span><br><span class="line">heapq.heappoppush(heap, item)  <span class="comment"># 弹出最小的值.并且将新的值插入其中.</span></span><br><span class="line">heapq.merge(*iterables, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)  <span class="comment"># 将多个堆进行合并</span></span><br><span class="line">heapq.nlargest(n, iterable, key=<span class="literal">None</span>)  <span class="comment"># 从堆中找出最大的 n 个数，key的作用和sorted( )方法里面的key类似, 用列表元素的某个属性和函数作为关键字</span></span><br><span class="line">heapq.nsmallest(n, iterable, key=<span class="literal">None</span>)  <span class="comment"># 从堆中找出最小的 n 个数, 与 nlargest 相反</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分查找函数</span></span><br><span class="line">bisect.bisect_left(ps, T, L=<span class="number">0</span>, R=<span class="built_in">len</span>(ns))  <span class="comment">#二分左边界</span></span><br><span class="line">bisect.bisect_right(ps, T, L=<span class="number">0</span>, R=<span class="built_in">len</span>(ns)) <span class="comment">#二分右边界 </span></span><br><span class="line">bisect.insort_left(a, x, lo=<span class="number">0</span>, hi=<span class="built_in">len</span>(a))  <span class="comment"># 二分插入到左侧</span></span><br><span class="line">bisect.insort_right(a, x, lo=<span class="number">0</span>, hi=<span class="built_in">len</span>(a)) <span class="comment"># 二分插入到右侧</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bit操作</span></span><br><span class="line">&amp; 符号，x &amp; y ，会将两个十进制数在二进制下进行与运算</span><br><span class="line">| 符号，x | y ，会将两个十进制数在二进制下进行或运算</span><br><span class="line">^ 符号，x ^ y ，会将两个十进制数在二进制下进行异或运算</span><br><span class="line">&lt;&lt; 符号，x &lt;&lt; y 左移操作，最右边用 <span class="number">0</span> 填充</span><br><span class="line">&gt;&gt; 符号，x &gt;&gt; y 右移操作，最左边用 <span class="number">0</span> 填充</span><br><span class="line">~ 符号，~x ，按位取反操作，将 x 在二进制下的每一位取反</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数集合set位运算</span></span><br><span class="line"><span class="comment"># 整数集合做标志时，可以做参数加速运算</span></span><br><span class="line">vstd 访问 i ：vstd | (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 离开 i ：vstd &amp; ~(<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 不包含 i : <span class="keyword">not</span> vstd &amp; (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line"></span><br><span class="line">并集 ：A | B</span><br><span class="line">交集 ：A &amp; B</span><br><span class="line">全集 ：(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">补集 ：((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) ^ A</span><br><span class="line">子集 ：(A &amp; B) == B</span><br><span class="line">判断是否是 <span class="number">2</span> 的幂 ：A &amp; (A - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">最低位的 <span class="number">1</span> 变为 <span class="number">0</span> ：n &amp;= (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">最低位的 <span class="number">1</span>：A &amp; (-A)，最低位的 <span class="number">1</span> 一般记为 lowbit(A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ^     ：匹配字符串开头</span></span><br><span class="line"><span class="comment"># [\+\-]：代表一个+字符或-字符</span></span><br><span class="line"><span class="comment"># ?     ：前面一个字符可有可无</span></span><br><span class="line"><span class="comment"># \d    ：一个数字</span></span><br><span class="line"><span class="comment"># +     ：前面一个字符的一个或多个</span></span><br><span class="line"><span class="comment"># \D    ：一个非数字字符</span></span><br><span class="line"><span class="comment"># *     ：前面一个字符的0个或多个</span></span><br><span class="line">matches = re.<span class="keyword">match</span>(<span class="string">&#x27;[ ]*([+-]?\d+)&#x27;</span>, s)</span><br></pre></td></tr></table></figure><h3 id="【背包模板】"><a href="#【背包模板】" class="headerlink" title="【背包模板】"></a>【背包模板】</h3><p><strong>「力扣」上的 0-1 背包问题：</strong></p><ul><li><p>组合问题模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0-1背包，不可重复</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> ns: </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(T, n-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[i - n] + ws[i])</span><br><span class="line"><span class="comment">#完全背包，可重复，无序，算重量</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> ns: </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, T+<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[i - n] + ws[i]) </span><br><span class="line"><span class="comment">#完全背包，可重复，有序，算次数     </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, T+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> ns:</span><br><span class="line">dp[i] += dp[i-n]</span><br></pre></td></tr></table></figure><p><strong>✅377</strong> 组合总和 Ⅳ<br>✅<strong>494</strong> 目标和<br>✅<strong>518</strong> 零钱兑换 II</p></li><li><p>True、False问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] |= dp[i-num]</span><br></pre></td></tr></table></figure><p><strong>✅139</strong> 单词拆分<br><strong>✅416</strong> 分割等和子集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#特殊的可以使用bit数组</span></span><br></pre></td></tr></table></figure></li><li><p>最大最小问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">min</span>(dp[i], dp[i-num]+<span class="number">1</span>)</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i], dp[i-num]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>✅<strong>474</strong> 一和零<br>✅<strong>322</strong> 零钱兑换</p></li></ul><p>「力扣」第 <strong>879</strong> 题：盈利计划（困难）；<br>「力扣」第 <strong>1449</strong> 题：数位成本和为目标值的最大数字（困难）。</p><h3 id="【回溯模板】"><a href="#【回溯模板】" class="headerlink" title="【回溯模板】"></a>【回溯模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回溯算法，复杂度较高2^n或者N！，因为回溯算法就是暴力穷举，可用lru剪枝</span></span><br><span class="line"><span class="meta">@functools.lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        结果.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:    <span class="comment"># 核心代码段</span></span><br><span class="line">      <span class="keyword">if</span> vst[i]:   <span class="comment"># 辅助数组，减枝</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        做出选择</span><br><span class="line">        递归执行backtrack</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>「<strong>剪枝</strong>」第 <strong>46</strong> 题 全排列 第 <strong>47</strong> 题 全排列②</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 剪枝</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">temp_list, length</span>):</span><br><span class="line">    <span class="keyword">if</span> length == n:</span><br><span class="line">      res.append(temp_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">          visited[i] = <span class="number">1</span></span><br><span class="line">          backtrack(temp_list + [nums[i]], length + <span class="number">1</span>)</span><br><span class="line">          visited[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>「<strong>索引遍历</strong>」第 <strong>78</strong> 题 子集 | 第 <strong>47</strong> 题 子集② | 第 <strong>131</strong> 题 分割字符串</p><pre><code>  第 **39 **题 组合 | 第 **40** 题 组合②  | 第 **216** 题 组合③</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引遍历</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">helper1</span>(<span class="params">idx, n, temp_list</span>):</span><br><span class="line">  <span class="keyword">if</span> temp_list <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">    res.append(temp_list)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, n):</span><br><span class="line">    helper1(i + <span class="number">1</span>, n, temp_list + [nums[i]])</span><br></pre></td></tr></table></figure><p>「 <strong>资源消耗</strong>」第 <strong>22</strong> 题 夸号生成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源消耗</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">S, L, R</span>):</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">and</span> <span class="keyword">not</span> R:</span><br><span class="line">    ans.append(<span class="string">&#x27;&#x27;</span>.join(S))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> L :     backtrack(S + [<span class="string">&#x27;(&#x27;</span>], L-<span class="number">1</span>, R)</span><br><span class="line">  <span class="keyword">if</span> R &gt; L : backtrack(S + [<span class="string">&#x27;)&#x27;</span>], L, R-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>「<strong>资源消耗</strong>」第 <strong>93</strong> 题 复原IP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">资源消耗</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">i, tmp, flag</span>):</span><br><span class="line">  <span class="keyword">if</span> i == n <span class="keyword">and</span> flag == <span class="number">0</span>:</span><br><span class="line">    res.append(tmp[:-<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">elif</span> i&lt;n <span class="keyword">and</span> s[i] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">    backtrack(i + <span class="number">1</span>, tmp + s[i] + <span class="string">&quot;.&quot;</span>, flag - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">elif</span> flag :</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">min</span>(n,i + <span class="number">3</span>)):</span><br><span class="line">      <span class="keyword">if</span> <span class="number">0</span> &lt; <span class="built_in">int</span>(s[i:j + <span class="number">1</span>]) &lt;= <span class="number">255</span>:</span><br><span class="line">        backtrack(j + <span class="number">1</span>, tmp + s[i:j + <span class="number">1</span>] + <span class="string">&quot;.&quot;</span>, flag - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>「<strong>资源消耗</strong>」第 <strong>17</strong> 题 电话号码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源消耗</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">path, remains</span>):</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> remains:</span><br><span class="line">    res.append(path[:])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(remains)):</span><br><span class="line">    dfs(path + [remains[i]], remains[:i] + remains[i+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 套模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">pth,idx</span>):</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(ds):</span><br><span class="line">        res.append(pth)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> dic[ds[idx]]:</span><br><span class="line">        dfs(pth + c, idx + <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>「<strong>多重限制</strong>」第 <strong>37</strong> 题 解数独  | 第 <strong>51</strong> 题 N皇后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多重限制</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">pos</span>):</span><br><span class="line">  <span class="keyword">if</span> pos == n:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  i, j = empty[pos]</span><br><span class="line">  <span class="keyword">for</span> num <span class="keyword">in</span> row[i] &amp; col[j] &amp; block[bidx(i, j)]:</span><br><span class="line">    row[i].remove(num)</span><br><span class="line">    col[j].remove(num)</span><br><span class="line">    block[bidx(i, j)].remove(num)</span><br><span class="line">    board[i][j] = <span class="built_in">str</span>(num)</span><br><span class="line">    <span class="keyword">if</span> backtrack(pos + <span class="number">1</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    row[i].add(num)</span><br><span class="line">    col[j].add(num)</span><br><span class="line">    block[bidx(i, j)].add(num)</span><br></pre></td></tr></table></figure><p>「<strong>递归</strong>」第 <strong>10</strong> 题 正则匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> p: </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">  f = <span class="built_in">bool</span>(s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">&#x27;.&#x27;</span>&#125;)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> f <span class="keyword">and</span> <span class="variable language_">self</span>.isMatch(s[<span class="number">1</span>:], p)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> f <span class="keyword">and</span> <span class="variable language_">self</span>.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h3 id="【并查集模板】"><a href="#【并查集模板】" class="headerlink" title="【并查集模板】"></a>【并查集模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#虚拟节点用以连接某一特征的全部节点，类似于链表的preHead</span></span><br><span class="line">dummy </span><br><span class="line">parent = &#123;&#125;</span><br><span class="line">size = collections.defaultdict(<span class="keyword">lambda</span>:<span class="number">1</span>)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    parent.setdefault(x,x)</span><br><span class="line">    <span class="keyword">while</span> x != parent[x]:</span><br><span class="line">        x = parent[x]</span><br><span class="line">        <span class="comment">#路径压缩 parent[x] = parent[parent[x]];</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">nonlocal</span> cnt</span><br><span class="line">    <span class="keyword">if</span> connected(x,y): <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 小的树挂到大的树上， 使树尽量平衡</span></span><br><span class="line">    xP = find(x)</span><br><span class="line">    yP = find(y)</span><br><span class="line">    <span class="keyword">if</span> size[hP] &lt; size[yP]:</span><br><span class="line">        parent[xP] = yP</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent[yP] = xP</span><br><span class="line">    size[xP] += size[yP]</span><br><span class="line">    <span class="comment"># 优化结束</span></span><br><span class="line">    parent[find(x)] = find(y)</span><br><span class="line">    <span class="comment"># 不优化</span></span><br><span class="line">    cnt -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> size[xP]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connected</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,x</span>):</span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">        parent[x] = <span class="literal">None</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line"><span class="comment"># 检查是否有环</span></span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> edges:</span><br><span class="line">    <span class="keyword">if</span> connected(a, b): </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    union(a, b)</span><br><span class="line"><span class="comment"># 将每个集合组成以头为key的字典</span></span><br><span class="line">res = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> e2n:</span><br><span class="line">    res[uf.find(e)].append(e)</span><br></pre></td></tr></table></figure><h3 id="【拓扑排序模板】"><a href="#【拓扑排序模板】" class="headerlink" title="【拓扑排序模板】"></a>【拓扑排序模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【拓扑排序模板】</span></span><br><span class="line">ins = [<span class="number">0</span>] * n</span><br><span class="line">ous = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> cur, pre <span class="keyword">in</span> ps:</span><br><span class="line">    ins[cur] += <span class="number">1</span>  <span class="comment">#入度</span></span><br><span class="line">    ous[pre].append(cur)<span class="comment">#出度</span></span><br><span class="line">res = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:ins[x]==<span class="number">0</span>, <span class="built_in">range</span>(n)))</span><br><span class="line">q = collections.deque(res)</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    pre = q.popleft()</span><br><span class="line">    <span class="keyword">for</span> cur <span class="keyword">in</span> ous[pre]:   <span class="comment">#释放出度队列</span></span><br><span class="line">        ins[cur] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ins[cur]: </span><br><span class="line">            q.append(cur)  <span class="comment">#入度为0解锁</span></span><br><span class="line">            res.append(cur)</span><br></pre></td></tr></table></figure><h3 id="【单调栈模板】"><a href="#【单调栈模板】" class="headerlink" title="【单调栈模板】"></a><strong>【单调栈模板】</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s中一般存索引</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ns):</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> ns[stack[-<span class="number">1</span>]] &lt;= ns[i]: <span class="comment"># 单调递减栈</span></span><br><span class="line">        stack.pop()</span><br><span class="line">    <span class="comment"># 业务逻辑</span></span><br><span class="line">    stack.append(i)</span><br></pre></td></tr></table></figure><p>「<strong>单调递增</strong>」第 <strong>84</strong> 题 求最大矩形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **84** 题 求最大矩形</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(hs)):</span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> hs[i] &lt; hs[s[-<span class="number">1</span>]]:</span><br><span class="line">        base = s.pop()</span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            H = hs[base]</span><br><span class="line">            W = i - s[-<span class="number">1</span>] - <span class="number">1</span> <span class="comment"># 当前弹出的做高，当前与次小做宽</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, H * W)</span><br><span class="line">    s.append(i)</span><br></pre></td></tr></table></figure><p>「<strong>单调递增,考虑剩余</strong>」第 <strong>316</strong> 题 去除重复字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **316** 题 去除重复字符</span></span><br><span class="line"><span class="keyword">for</span> i,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(ss):</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">while</span> s <span class="keyword">and</span> c &lt; s[-<span class="number">1</span>] <span class="keyword">and</span> s[-<span class="number">1</span>] <span class="keyword">in</span> ss[i:]:</span><br><span class="line">            s.pop()</span><br><span class="line">        s.append(c)</span><br></pre></td></tr></table></figure><p>「<strong>单调递减</strong>」第 <strong>42</strong> 题 接雨水</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **42** 题 接雨水</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(hgt)):</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> hgt[i] &gt; hgt[stack[-<span class="number">1</span>]]: <span class="comment">#递减栈</span></span><br><span class="line">        base = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> stack:</span><br><span class="line">            LH = hgt[stack[-<span class="number">1</span>]]</span><br><span class="line">            W = i - stack[-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            H = <span class="built_in">min</span>(LH,hgt[i]) - hgt[base]</span><br><span class="line">            res += W * H </span><br><span class="line">    stack.append(i)</span><br></pre></td></tr></table></figure><p>「<strong>单调递减</strong>」第 <strong>739</strong> 题 每日温度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **739** 题 每日温度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> T[s[-<span class="number">1</span>]] &lt;= T[i] :   <span class="comment">#递减栈</span></span><br><span class="line">        s.pop()</span><br><span class="line">    res[i] = s[-<span class="number">1</span>] - i <span class="keyword">if</span> s <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    s.append(i)</span><br></pre></td></tr></table></figure><h3 id="【二分模板】"><a href="#【二分模板】" class="headerlink" title="【二分模板】"></a>【二分模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1355579 T=5 =&gt; 13(5)55579 返回2</span></span><br><span class="line"><span class="comment"># ps[i-1] &lt; ps[i] &lt;= ps[i+1]</span></span><br><span class="line">bisect.bisect_left(ps, T, L=<span class="number">0</span>, R=<span class="built_in">len</span>(ns))  </span><br><span class="line"><span class="comment"># 1355579 T=5 =&gt; 13555(5)79 返回5</span></span><br><span class="line"><span class="comment"># ps[i-1] &lt;= ps[i] &lt; ps[i+1]</span></span><br><span class="line">bisect.bisect_right(ps, T, L=<span class="number">0</span>, R=<span class="built_in">len</span>(ns))  </span><br><span class="line">bisect.bisect(ps, T, L=<span class="number">0</span>, R=<span class="built_in">len</span>(ns))   </span><br></pre></td></tr></table></figure><p>「<strong>中位返回</strong>」第 <strong>33</strong> 题 搜索旋转排序数组 | 第<strong>374</strong>题 猜数字大小 | 第<strong>69</strong>题  x平方根</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中位返回</span></span><br><span class="line"><span class="keyword">while</span> L &lt;= R:</span><br><span class="line">    M = (L + R) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[M] == T:</span><br><span class="line">        <span class="keyword">return</span> M</span><br><span class="line">    <span class="keyword">elif</span> nums[M] &lt; T:</span><br><span class="line">        L = M + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        R = M - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>「<strong>区域压缩</strong>」第<strong>278</strong>题 第一个错误版本| 第<strong>162</strong>题 寻找峰值 | 第<strong>153</strong>题 寻找数组最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区域压缩</span></span><br><span class="line"><span class="keyword">while</span> L &lt; R:</span><br><span class="line">    M = (L + R) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> need <span class="keyword">in</span> s[L:M]:</span><br><span class="line">        R = M</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        L = M + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="【动态规划模板】"><a href="#【动态规划模板】" class="headerlink" title="【动态规划模板】"></a>【动态规划模板】</h3><h4 id="「单串问题」"><a href="#「单串问题」" class="headerlink" title="「单串问题」"></a>「<strong>单串问题</strong>」</h4><ul><li>70 爬楼梯问题</li><li>801 使序列递增的最小交换次数</li><li>746 使用最小花费爬楼梯</li><li>300 最长上升子序列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖前单个元素</span></span><br><span class="line">dp[i] = dp[i-<span class="number">1</span>] + ns[i]</span><br><span class="line"><span class="comment"># 依赖前部区域元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i)</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i], f(dp[j])</span><br></pre></td></tr></table></figure><h4 id="「单串加状态问题」"><a href="#「单串加状态问题」" class="headerlink" title="「单串加状态问题」"></a>「<strong>单串加状态问题</strong>」</h4><ul><li><p>887 鸡蛋掉落</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 鸡蛋掉落</span></span><br><span class="line"><span class="keyword">while</span> cur[K] &lt; N:             <span class="comment"># 还剩 j 个蛋 测 ans 次 覆盖多少层</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K + <span class="number">1</span>): <span class="comment"># 覆盖总层数 碎了 -1 次层数 + 1 + 没碎 -1 次层数</span></span><br><span class="line">        cur[j] = prev[j - <span class="number">1</span>] + <span class="number">1</span> + prev[j]</span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line">    prev = copy.deepcopy(cur)</span><br></pre></td></tr></table></figure></li><li><p>813 最大平均值分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 813 最大平均值分组</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(K-<span class="number">1</span>):            <span class="comment">#循环k次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):          <span class="comment">#每次均依赖上次的结果</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], avrg(i, j) + dp[j])</span><br></pre></td></tr></table></figure></li><li><p>410 分割数组最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 410 分割数组最大值</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,K):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N): </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="comment"># 0~i中分 k 段最大 即为</span></span><br><span class="line">            <span class="comment"># 0~j中分k-1段最大 和 j到i的前缀和的最大</span></span><br><span class="line">            dp[i][k] = <span class="built_in">min</span>(dp[i][k], <span class="built_in">max</span>(dp[j][k-<span class="number">1</span>], ps[i+<span class="number">1</span>] - ps[j+<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li></ul><h4 id="「经典双串LCS问题」"><a href="#「经典双串LCS问题」" class="headerlink" title="「经典双串LCS问题」"></a>「<strong>经典双串LCS问题</strong>」</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经典双串LCS问题</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (M+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        <span class="keyword">if</span> t1[i] == t2[j] : dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span> : dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j])</span><br></pre></td></tr></table></figure><h4 id="「区间动态规划」"><a href="#「区间动态规划」" class="headerlink" title="「区间动态规划」"></a>「区间动态规划」</h4><ul><li>5 最长回文子串</li><li>647 最多回文子串</li><li>516 最长回文子序列</li><li>1312 最长回文插入次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] 代表从 i 到 j 的最长子串满足条件的数量</span></span><br><span class="line"><span class="comment"># i-- &lt; j++  ==&gt; i 在 0~j 范围内 --</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (N) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    dp[j][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> ss[i] == ss[j]:</span><br><span class="line">            dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] +<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h4 id="「区间分治动态规划」"><a href="#「区间分治动态规划」" class="headerlink" title="「区间分治动态规划」"></a><strong>「区间分治动态规划」</strong></h4><p><a href="https://leetcode-cn.com/problems/predict-the-winner/">486 预测赢家</a></p><p><a href="***https://leetcode-cn.com/problems/burst-balloons/***">312 戳气球</a></p><p><a href="***https://leetcode-cn.com/problems/strange-printer/***">664 奇怪的打印机</a></p><p><a href="***https://leetcode-cn.com/problems/remove-boxes/***">546 移除盒子</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区间分治动态规划</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, ns: <span class="type">List</span>[<span class="built_in">int</span>]</span>) :</span><br><span class="line">    N = <span class="built_in">len</span>(ns)</span><br><span class="line">    dp = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(N): <span class="comment"># 长度从小到大</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-l): <span class="comment"># 以 i 为 开头</span></span><br><span class="line">            j = i + l           <span class="comment"># 以 j 为 终点</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i,j): <span class="comment"># 以 k 为分割点，进行分治         </span></span><br><span class="line">                // Todo 业务逻辑 </span><br></pre></td></tr></table></figure><p>「<strong>卡特兰数</strong>」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卡特兰数</span></span><br><span class="line">g(n) = g(<span class="number">0</span>)*g(n-<span class="number">1</span>) + g(<span class="number">1</span>)*g(n-<span class="number">2</span>) ...g(n-<span class="number">1</span>)*g(<span class="number">0</span>)</span><br><span class="line">dp=[<span class="number">1</span>] + [<span class="number">0</span>] * n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">        dp[i] += dp[j-<span class="number">1</span>] * dp[i-j]</span><br></pre></td></tr></table></figure><h3 id="【滑动窗口】"><a href="#【滑动窗口】" class="headerlink" title="【滑动窗口】"></a>【滑动窗口】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;给定待查串s和目标串t&quot;&quot;&quot;</span></span><br><span class="line">nd, wd = &#123;&#125;, &#123;&#125;</span><br><span class="line">nd = collections.Counter(s1)</span><br><span class="line">L, R = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">cnt = <span class="number">0</span> <span class="comment"># 满足条件个数</span></span><br><span class="line"><span class="keyword">while</span> R &lt; <span class="built_in">len</span>(s):        <span class="comment"># 窗口右边界不断扩大，本质是搜索问题的可能解</span></span><br><span class="line">    c = s[R]      <span class="comment"># 即将加入到窗口中的字符</span></span><br><span class="line">    R += <span class="number">1</span></span><br><span class="line">    更新窗口中的数据</span><br><span class="line">    <span class="keyword">while</span> 满足窗口收缩条件：  <span class="comment"># 窗口的左边界收缩，本质是优化可行解</span></span><br><span class="line">        记录或返回结果</span><br><span class="line">        d = s[L]   <span class="comment"># 即将从窗口中删除的字符</span></span><br><span class="line">        L += <span class="number">1</span></span><br><span class="line">        更新窗口中的数据</span><br><span class="line"><span class="keyword">return</span> 结果</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定窗口 ,比滑动窗口更快一些</span></span><br><span class="line">i = j = cnt = <span class="number">0</span>      </span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">    <span class="keyword">if</span> A[j] == <span class="number">0</span>: </span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cnt &gt; K: <span class="comment">#不满足时 平移</span></span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">0</span>:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> j - i + <span class="number">1</span>        </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">    <span class="keyword">if</span> A[j] == <span class="number">0</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> cnt &gt; K:</span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">0</span>:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【前缀和】"><a href="#【前缀和】" class="headerlink" title="【前缀和】"></a>【前缀和】</h3><p>「<strong>累加和存位置</strong>」</p><p>1371 最长偶数元音子数组</p><p>525 最长相等01子数组</p><p>325 最长和为k 子数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前缀和初始化</span></span><br><span class="line">psd = &#123;<span class="number">0</span>: -<span class="number">1</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    t ^= cd.get(s[i], <span class="number">0</span>) <span class="comment"># 业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> psd:</span><br><span class="line">        psd[t] = i       <span class="comment"># 第一次存入数组</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, i - psd[t]) <span class="comment">#已存入则开始计算</span></span><br></pre></td></tr></table></figure><p>「<strong>累加和存数量</strong>」</p><p>560 和为K的子数组数量</p><p> 统计优美子数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 累加和存数量</span></span><br><span class="line">psd = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ns)):</span><br><span class="line">    s += ns[i]</span><br><span class="line">    <span class="keyword">if</span> s - T <span class="keyword">in</span> psd:</span><br><span class="line">        ans += psd[s - T] <span class="comment"># 存数量</span></span><br><span class="line">    psd[s] = psd.get(s,<span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>「<strong>模K状态前缀和</strong>」</p><p>523 连续和为 k 倍 的子数组（存索引）</p><p>974 和被k 整除 子数组数量（存数量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模K状态前缀和</span></span><br><span class="line">psd = &#123;<span class="number">0</span>:-<span class="number">1</span>&#125;</span><br><span class="line">ans = s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ns)):</span><br><span class="line">    s += ns[i]<span class="comment"># 业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> T != <span class="number">0</span>: s %= <span class="built_in">abs</span>(T)<span class="comment"># 模k状态做key，索引做值</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> psd:</span><br><span class="line">        psd[s] = i</span><br><span class="line">    <span class="keyword">elif</span> i - psd[s] &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>「矩阵前缀和」</strong></p><ul><li>363 不超过K的最大数值和</li><li>1074 和为目标值的子矩阵数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵前缀和</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):        <span class="comment">#固定左边界</span></span><br><span class="line">    ps = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, m): <span class="comment">#固定右边界</span></span><br><span class="line">    psS = <span class="number">0</span></span><br><span class="line">        dct = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;       <span class="comment">#初始只有一种可能</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 以高做前缀和</span></span><br><span class="line">            ps[k] += mtx[j][k]          <span class="comment"># 每行前缀和</span></span><br><span class="line">            psS += ps[k]                <span class="comment"># n行前缀和</span></span><br><span class="line">            cnt += dct.get(psS - T, <span class="number">0</span>)  <span class="comment"># 满足条件cnt</span></span><br><span class="line">            dct[psS] = dct.get(psS,<span class="number">0</span>) + <span class="number">1</span> <span class="comment"># 保存当前状态</span></span><br><span class="line"><span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h3 id="【双指针】"><a href="#【双指针】" class="headerlink" title="【双指针】"></a>【双指针】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双指针</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, ns: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    slow = <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(ns)</span><br><span class="line">    <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> ns[fast] != val:</span><br><span class="line">            ns[slow] = ns[fast]</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h3 id="【深度优先】"><a href="#【深度优先】" class="headerlink" title="【深度优先】"></a>【深度优先】</h3><p>「<strong>二叉树遍历模板</strong>」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归1：二叉树遍历最易理解和实现版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preOrd</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 前序递归</span></span><br><span class="line">        <span class="keyword">return</span> [root.val] + <span class="variable language_">self</span>.preOrd(root.left) + <span class="variable language_">self</span>.preOrd(root.right)</span><br><span class="line">        <span class="comment"># # 中序递归 </span></span><br><span class="line">        <span class="comment"># return self.inOrd(root.left) + [root.val] + self.inOrd(root.right)</span></span><br><span class="line">        <span class="comment"># # 后序递归</span></span><br><span class="line">        <span class="comment"># return self.postOrd(root.left) + self.postOrd(root.right) + [root.val]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preOrd</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span>      </span><br><span class="line">            <span class="comment"># 前序递归</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            dfs(cur.left)</span><br><span class="line">            dfs(cur.right) </span><br><span class="line">            <span class="comment"># # 中序递归</span></span><br><span class="line">            <span class="comment"># dfs(cur.left)</span></span><br><span class="line">            <span class="comment"># res.append(cur.val)</span></span><br><span class="line">            <span class="comment"># dfs(cur.right)</span></span><br><span class="line">            <span class="comment"># # 后序递归</span></span><br><span class="line">            <span class="comment"># dfs(cur.left)</span></span><br><span class="line">            <span class="comment"># dfs(cur.right)</span></span><br><span class="line">            <span class="comment"># res.append(cur.val)      </span></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(h)，h为树的高度。取决于树的结构，最坏情况存储整棵树，即O(n)</span></span><br><span class="line"><span class="comment"># 迭代1：前序遍历最常用模板（后序同样可以用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preOrd</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []        </span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="comment"># # 前序迭代模板：最常用的二叉树DFS迭代遍历模板</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 后序迭代，相同模板：将前序迭代进栈顺序稍作修改，最后得到的结果反转</span></span><br><span class="line">        <span class="comment"># while stack:</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     if cur.left:</span></span><br><span class="line">        <span class="comment">#         stack.append(cur.left)</span></span><br><span class="line">        <span class="comment">#     if cur.right:</span></span><br><span class="line">        <span class="comment">#         stack.append(cur.right)</span></span><br><span class="line">        <span class="comment">#     res.append(cur.val)</span></span><br><span class="line">        <span class="comment"># return res[::-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代1：层序遍历最常用模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q :</span><br><span class="line">            l = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)) :</span><br><span class="line">                t = q.popleft()</span><br><span class="line">                l.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left : q.append(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right : q.append(t.right)</span><br><span class="line">            res.append(l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 迭代2：前、中、后序遍历通用模板（只需一个栈的空间）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inOrd</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]: </span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># 中序，模板：先用指针找到每颗子树的最左下角，然后进行进出栈操作</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 前序，相同模板</span></span><br><span class="line">        <span class="comment"># while stack or cur:</span></span><br><span class="line">        <span class="comment">#     while cur:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment">#         stack.append(cur)</span></span><br><span class="line">        <span class="comment">#         cur = cur.left</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     cur = cur.right</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 后序，相同模板</span></span><br><span class="line">        <span class="comment"># while stack or cur:</span></span><br><span class="line">        <span class="comment">#     while cur:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment">#         stack.append(cur)</span></span><br><span class="line">        <span class="comment">#         cur = cur.right</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     cur = cur.left</span></span><br><span class="line">        <span class="comment"># return res[::-1]</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代3：标记法迭代（需要双倍的空间来存储访问状态）：</span></span><br><span class="line"><span class="comment"># 前、中、后、层序通用模板，只需改变进栈顺序或即可实现前后中序遍历，</span></span><br><span class="line"><span class="comment"># 而层序遍历则使用队列先进先出。0表示当前未访问，1表示已访问。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preOrd</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        stack = [(<span class="number">0</span>, root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            flag, cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 前序，标记法</span></span><br><span class="line">                stack.append((<span class="number">0</span>, cur.right))</span><br><span class="line">                stack.append((<span class="number">0</span>, cur.left))</span><br><span class="line">                stack.append((<span class="number">1</span>, cur))</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># # 后序，标记法</span></span><br><span class="line">                <span class="comment"># stack.append((1, cur))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.right))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.left))</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># # 中序，标记法</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.right))</span></span><br><span class="line">                <span class="comment"># stack.append((1, cur))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.left))  </span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)  </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 层序，标记法</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># queue = [(0, root)]</span></span><br><span class="line">        <span class="comment"># while queue:</span></span><br><span class="line">        <span class="comment">#     flag, cur = queue.pop(0)  # 注意是队列，先进先出</span></span><br><span class="line">        <span class="comment">#     if not cur: continue</span></span><br><span class="line">        <span class="comment">#     if flag == 0:</span></span><br><span class="line">                  <span class="comment"># 层序遍历这三个的顺序无所谓，因为是队列，只弹出队首元素</span></span><br><span class="line">        <span class="comment">#         queue.append((1, cur))</span></span><br><span class="line">        <span class="comment">#         queue.append((0, cur.left))</span></span><br><span class="line">        <span class="comment">#         queue.append((0, cur.right))</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 莫里斯遍历</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，看似超过O(n)，有的节点可能要访问两次，实际分析还是O(n)</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)，如果在遍历过程中就输出节点值，则只需常数空间就能得到中序遍历结果，空间只需两个指针。</span></span><br><span class="line"><span class="comment"># 如果将结果储存最后输出，则空间复杂度还是O(n)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PS：莫里斯遍历实际上是在原有二叉树的结构基础上，构造了线索二叉树，</span></span><br><span class="line"><span class="comment"># 线索二叉树定义为：原本为空的右子节点指向了中序遍历顺序之后的那个节点，把所有原本为空的左子节点都指向了中序遍历之前的那个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处只给出中序遍历，前序遍历只需修改输出顺序即可</span></span><br><span class="line"><span class="comment"># 而后序遍历，由于遍历是从根开始的，而线索二叉树是将为空的左右子节点连接到相应的顺序上，使其能够按照相应准则输出</span></span><br><span class="line"><span class="comment"># 但是后序遍历的根节点却已经没有额外的空间来标记自己下一个应该访问的节点，</span></span><br><span class="line"><span class="comment"># 所以这里需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 莫里斯遍历，借助线索二叉树中序遍历（附前序遍历）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inOrd</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># cur = pre = TreeNode(None)</span></span><br><span class="line">        cur = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># print(cur.val)</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right != cur:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:</span><br><span class="line">                    <span class="comment"># print(cur.val) 这里是前序遍历的代码，前序与中序的唯一差别</span></span><br><span class="line">                    pre.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.right = <span class="literal">None</span></span><br><span class="line">                    res.append(cur.val)</span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树遍历</span></span><br><span class="line"><span class="comment"># 时间复杂度：时间复杂度：O(M)，其中 M 是 N 叉树中的节点个数。每个节点只会入栈和出栈各一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(M)。在最坏的情况下，这棵 N 叉树只有 2 层，所有第 2 层的节点都是根节点的孩子。</span></span><br><span class="line"><span class="comment"># 将根节点推出栈后，需要将这些节点都放入栈，共有 M−1个节点，因此栈的大小为 O(M)。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树简洁递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = [root.val]</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">            res.extend(<span class="variable language_">self</span>.preorder(node))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树通用递归模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                helper(child)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树迭代方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s = [root]</span><br><span class="line">        <span class="comment"># s.append(root)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            node = s.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="comment"># for child in node.children[::-1]:</span></span><br><span class="line">            <span class="comment">#     s.append(child)</span></span><br><span class="line">            s.extend(node.children[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="【广度优先】"><a href="#【广度优先】" class="headerlink" title="【广度优先】"></a>【广度优先】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 「**无向图的遍历**」</span></span><br><span class="line">q = collections.deque([i])</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    cur = q.popleft()</span><br><span class="line">    <span class="keyword">for</span> nxt <span class="keyword">in</span> dt[cur]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vst[nxt]:</span><br><span class="line">            vstd[nxt] = <span class="literal">True</span></span><br><span class="line">            q.append(nxt)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 「**二叉树层序遍历**」</span></span><br><span class="line">q = deque([root])</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> q :</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)) :</span><br><span class="line">        t = q.popleft()</span><br><span class="line">        l.append(t.val)</span><br><span class="line">        <span class="keyword">if</span> t.left : q.append(t.left)</span><br><span class="line">        <span class="keyword">if</span> t.right : q.append(t.right)</span><br><span class="line">    res.append(l)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="【图论】"><a href="#【图论】" class="headerlink" title="【图论】"></a>【图论】</h3><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#「Dijkstra最短路径」</span></span><br><span class="line">dic = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">    dic[u].append([v, w])</span><br><span class="line">    dic[v].append([u, w])</span><br><span class="line">q = [(<span class="number">0</span>, n)]</span><br><span class="line">dist = [-<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    dis, cur = heapq.heappop(q)</span><br><span class="line">    <span class="keyword">if</span> dist[cur] &lt; <span class="number">0</span>:</span><br><span class="line">        dist[cur] = dis</span><br><span class="line">        <span class="keyword">for</span> nxt, wi <span class="keyword">in</span> dic[cur]:</span><br><span class="line">            heapq.heappush(q, [dis + wi, nxt])</span><br></pre></td></tr></table></figure><p><strong>「Floyd 求图中路径」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Floyd算法 求图中任意2点距离</span></span><br><span class="line">ds = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">st = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(ess):</span><br><span class="line">    ds[(x, y)] = vs[i]</span><br><span class="line">    ds[(y, x)] = <span class="number">1</span> / vs[i]</span><br><span class="line">    st.update(&#123;x,y&#125;)</span><br><span class="line">arr = <span class="built_in">list</span>(st)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> ds[(i, k)] <span class="keyword">and</span> ds[(k, j)]:</span><br><span class="line">                ds[(i, j)] = ds[(i, k)] * ds[(k, j)]</span><br></pre></td></tr></table></figure><h1 id="五、实战算法篇"><a href="#五、实战算法篇" class="headerlink" title="五、实战算法篇"></a>五、实战算法篇</h1><h3 id="1、URL黑名单（布隆过滤器）"><a href="#1、URL黑名单（布隆过滤器）" class="headerlink" title="1、URL黑名单（布隆过滤器）"></a><strong>1、</strong>URL黑名单（布隆过滤器）</h3><p><strong>100亿黑名单URL，每个64B，问这个黑名单要怎么存？判断一个URL是否在黑名单中</strong></p><p>​<strong>散列表：</strong></p><p>​如果把黑名单看成一个集合，将其存在 hashmap 中，貌似太大了，需要 640G，明显不科学。</p><p>​<strong>布隆过滤器：</strong></p><p>​它实际上是一个很长的二进制矢量和一系列随机映射函数。</p><p>​它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p><p>​在数组中的每一位都是二进制位。布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：</p><ul><li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ul><h3 id="2、词频统计（分文件）"><a href="#2、词频统计（分文件）" class="headerlink" title="2、词频统计（分文件）"></a>2、词频统计（分文件）</h3><p><strong>2GB内存在20亿整数中找到出现次数最多的数</strong> </p><p>​通常做法是使用哈希表对出现的每一个数做词频统计，哈希表的key是某个整数，value记录整数出现的次数。本题的数据量是20亿，有可能一个数出现20亿次，则为了避免溢出，哈希表的key是32位（4B）,value也是 32位（4B），那么一条哈希表的记录就需要占用8B。</p><p>​当哈希表记录数为2亿个时，需要16亿个字节数（8*2亿），需要至少1.6GB内存(16亿&#x2F;2^30,1GB&#x3D;&#x3D; 2 ^30个字节 &#x3D;&#x3D; 10亿)。则20亿个记录，至少需要16GB的内存，不符合题目要求。</p><p>​解决办法是将20亿个数的大文件利用哈希函数分成16个小文件，根据哈希函数可以把20亿条数据均匀分布到16个文件上，同一种数不可能被哈希函数分到不同的小文件上，假设哈希函数够好。然后对每一个小文件用哈希函数来统计其中每种数出现的次数，这样我们就得到16个文件中出现次数最多的数，接着从16个数中选出次数最大的那个key即可。</p><h3 id="3、未出现的数（bit数组）"><a href="#3、未出现的数（bit数组）" class="headerlink" title="3、未出现的数（bit数组）"></a><strong>3、未出现的数</strong>（bit数组）</h3><p><strong>40亿个非负整数中找到没有出现的数</strong> </p><p>​对于原问题，如果使用哈希表来保存出现过的数，那么最坏情况下是40亿个数都不相同，那么哈希表则需要保存40亿条数据，一个32位整数需要4B，那么40亿*4B &#x3D; 160亿个字节，一般大概10亿个字节的数据需要1G的空间，那么大概需要16G的空间，这不符合要求。</p><p>　　我们换一种方式，申请一个bit数组，数组大小为4294967295，大概为40亿bit，40亿&#x2F;8 &#x3D; 5亿字节，那么需要0.5G空间， bit数组的每个位置有两种状态0和1，那么怎么使用这个bit数组呢？呵呵，数组的长度刚好满足我们整数的个数范围，那么数组的每个下标值对应4294967295中的一个数，逐个遍历40亿个无符号数，例如，遇到20，则bitArray[20] &#x3D; 1；遇到666，则bitArray[666] &#x3D; 1,遍历完所有的数，将数组相应位置变为1。</p><p><strong>40亿个非负整数中找到一个没有出现的数，内存限制10MB</strong> </p><p>​10亿个字节的数据大概需要1GB空间处理，那么10MB内存换算过来就是可以处理1千万字节的数据，也就是8千万bit，对于40亿非负整数如果申请bit数组的话，40亿bit &#x2F; 0.8亿bit &#x3D; 50，那么这样最少也得分50块来处理，下面就以64块来进行分析解答吧。</p><p><strong>总结一下进阶的解法：</strong></p><p>1．根据10MB的内存限制，确定统计区间的大小，就是第二次遍历时的bitArr大小。</p><p>2．利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。</p><p>3．对这个区间上的数做bit map映射，再遍历bit map，找到一个没出现的数即可。</p><p><strong>自己的想法</strong></p><p>如果只是找一个数，可以高位模运算，写到64个不同的文件，然后在最小的文件中通过bitArray一次处理掉。</p><p><strong>40亿个无符号整数，1GB内存，找到所有出现两次的数</strong> </p><p>​对于原问题，可以用bit map的方式来表示数出现的情况。具体地说，是申请一个长度为4294967295×2的bit类型的数组bitArr，用2个位置表示一个数出现的词频，1B占用8个bit，所以长度为4294967295×2的bit类型的数组占用1GB空间。怎么使用这个bitArr数组呢？遍历这40亿个无符号数，如果初次遇到num，就把bitArr[num<em>2 + 1]和bitArr[num</em>2]设置为01，如果第二次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为10，如果第三次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为11。以后再遇到num，发现此时bitArr[num<em>2+1]和bitArr[num</em>2]已经被设置为11，就不再做任何设置。遍历完成后，再依次遍历bitArr，如果发现bitArr[i<em>2+1]和bitArr[i</em>2]设置为10，那么i 就是出现了两次的数。</p><h3 id="4、重复URL（分机器）"><a href="#4、重复URL（分机器）" class="headerlink" title="4、重复URL（分机器）"></a><strong>4、重复URL</strong>（分机器）</h3><p><strong>找到100亿个URL中重复的URL</strong></p><p>​原问题的解法使用解决大数据问题的一种常规方法：把大文件通过哈希函数分配到机器，或者通过哈希函数把大文件拆成小文件。一直进行这种划分，直到划分的结果满足资源限制的要求。首先，你要向面试官询问在资源上的限制有哪些，包括内存、计算时间等要求。在明确了限制要求之后，可以将每条URL通过哈希函数分配到若干机器或者拆分成若干小文件，这里的“若干”由具体的资源限制来计算出精确的数量。 </p><p>​例如，将100亿字节的大文件通过哈希函数分配到100台机器上，然后每一台机器分别统计分给自己的URL中是否有重复的URL，<strong>同时哈希函数的性质决定了同一条URL不可能分给不同的机器；</strong>或者在单机上将大文件通过哈希函数拆成1000个小文件，对每一个小文件再利用哈希表遍历，找出重复的URL；或者在分给机器或拆完文件之后，进行排序，排序过后再看是否有重复的URL出现。总之，牢记一点，很多大数据问题都离不开分流，要么是哈希函数把大文件的内容分配给不同的机器，要么是哈希函数把大文件拆成小文件，然后处理每一个小数量的集合。</p><h3 id="5、TOPK搜索（小根堆）"><a href="#5、TOPK搜索（小根堆）" class="headerlink" title="5、TOPK搜索（小根堆）"></a><strong>5、TOPK搜索（小根堆）</strong></h3><p><strong>海量搜索词汇，找到最热TOP100词汇的方法</strong> </p><p>​最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上，具体多少台机器由面试官规定或者由更多的限制来决定。对每一台机器来说，如果分到的数据量依然很大，比如，内存不够或其他问题，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理。</p><p>​处理每一个小文件的时候，哈希表统计每种词及其词频，哈希表记录建立完成后，再遍历哈希表，遍历哈希表的过程中使用大小为100的小根堆来选出每一个小文件的top 100（整体未排序的top 100）。每一个小文件都有自己词频的小根堆（整体未排序的top 100），将小根堆里的词按照词频排序，就得到了每个小文件的排序后top 100。然后把各个小文件排序后的top 100进行外排序或者继续利用小根堆，就可以选出每台机器上的top 100。不同机器之间的top100再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的top 100。对于top K 的问题，除哈希函数分流和用哈希表做词频统计之外，还经常用堆结构和外排序的手段进行处理。</p><h3 id="6、中位数（单向二分查找）"><a href="#6、中位数（单向二分查找）" class="headerlink" title="6、中位数（单向二分查找）"></a><strong>6、中位数（单向二分查找）</strong></h3><p><strong>10MB内存，找到100亿整数的中位数</strong> </p><p>①内存够：内存够还慌什么啊，直接把100亿个全部排序了，你用冒泡都可以…然后找到中间那个就可以了。但是你以为面试官会给你内存？？ </p><p>②内存不够：题目说是整数，我们认为是带符号的int,所以4字节，占32位。 </p><p>  假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。 </p><p>  从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中） </p><p>  现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。 </p><p>  现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。 </p><p>  抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。 </p><p>  按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p><h3 id="7、短域名系统（缓存）"><a href="#7、短域名系统（缓存）" class="headerlink" title="7、短域名系统（缓存）"></a><strong>7、短域名系统（缓存）</strong></h3><p><strong>设计短域名系统，将长URL转化成短的URL.</strong></p><p>（1）利用放号器，初始值为0，对于每一个短链接生成请求，都递增放号器的值，再将此值转换为62进制（a-zA-Z0-9），比如第一次请求时放号器的值为0，对应62进制为a，第二次请求时放号器的值为1，对应62进制为b，第10001次请求时放号器的值为10000，对应62进制为sBc。</p><p>（2）将短链接服务器域名与放号器的62进制值进行字符串连接，即为短链接的URL，比如：<a href="http://t.cn/sBc%E3%80%82">t.cn&#x2F;sBc。</a></p><p>（3）重定向过程：生成短链接之后，需要存储短链接到长链接的映射关系，即sBc -&gt; URL，浏览器访问短链接服务器时，根据URL Path取到原始的链接，然后进行302重定向。映射关系可使用K-V存储，比如Redis或Memcache。</p><h3 id="8、海量评论入库（消息队列）"><a href="#8、海量评论入库（消息队列）" class="headerlink" title="8、海量评论入库（消息队列）"></a><strong>8、海量评论入库（消息队列）</strong></h3><p><strong>假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写</strong></p><p>前端页面直接给用户展示、通过消息队列异步方式入库</p><p>读可以进行读写分离、同时热点评论定时加载到缓存</p><h3 id="9、在线-并发用户数（Redis）"><a href="#9、在线-并发用户数（Redis）" class="headerlink" title="9、在线&#x2F;并发用户数（Redis）"></a><strong>9、在线&#x2F;并发用户数（Redis）</strong></h3><p>​<strong>显示网站的用户在线数的解决思路</strong></p><p>​维护在线用户表</p><p>​使用Redis统计</p><p><strong>显示网站并发用户数</strong></p><ol><li>每当用户访问服务时，把该用户的 ID 写入ZSORT队列，权重为当前时间</li><li>根据权重(即时间)计算一分钟内该机构的用户数Zrange</li><li>删掉一分钟以上过期的用户Zrem</li></ol><h3 id="10、热门字符串（前缀树）"><a href="#10、热门字符串（前缀树）" class="headerlink" title="10、热门字符串（前缀树）"></a>10、热门字符串（前缀树）</h3><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><p><strong>HashMap 法</strong></p><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4 个字节）。由此可见，1G 的内存空间完全够用。</p><p><strong>思路如下</strong>：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code> 。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code> 。</p><p><strong>前缀树法</strong></p><p>当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p><strong>思路如下</strong>：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用<strong>小顶堆</strong>来对字符串的出现次数进行排序。</p><h3 id="11、红包算法"><a href="#11、红包算法" class="headerlink" title="11、红包算法"></a>11、红包算法</h3><p>线性切割法，一个区间切N-1刀。越早越多</p><p>二倍均值法，【0 ~ 剩余金额 &#x2F; 剩余人数 * 2】中随机，相对均匀</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqpbvl5pvj30qu0gcgm0.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqpc3hz9dj31450ggq8k.jpg" alt="img"></p><h3 id="11、手写快排"><a href="#11、手写快排" class="headerlink" title="11、手写快排"></a>11、手写快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 常规快排 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L , <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R)  <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> partition(arr, L, R);</span><br><span class="line">quickSort1(arr, L, M - <span class="number">1</span>);</span><br><span class="line">quickSort1(arr, M + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line"><span class="type">int</span> <span class="variable">lessEqual</span> <span class="operator">=</span> L - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> L;</span><br><span class="line"><span class="keyword">while</span> (index &lt; R) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] &lt;= arr[R])</span><br><span class="line">swap(arr, index, ++lessEqual);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, ++lessEqual, R);</span><br><span class="line"><span class="keyword">return</span> lessEqual;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 荷兰国旗 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R)  <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">quickSort2(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">quickSort2(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] netherlandsFlag(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R) &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; L, R &#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> L - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> R;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> L;</span><br><span class="line"><span class="keyword">while</span> (index &lt; more) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] == arr[R]) &#123;</span><br><span class="line">index++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; arr[R]) &#123;</span><br><span class="line">swap(arr, index++, ++less);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(arr, index, --more);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, more, R);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">succeed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">long</span> T1=<span class="number">0</span>,T2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line"><span class="type">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line"><span class="type">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line"><span class="type">int</span>[] arr3 = copyArray(arr1);</span><br><span class="line"><span class="comment">//int[] arr1 = &#123;9,8,7,6,5,4,3,2,1&#125;;</span></span><br><span class="line"><span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">quickSort1(arr1,<span class="number">0</span>,arr1.length-<span class="number">1</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">quickSort2(arr2,<span class="number">0</span>,arr2.length-<span class="number">1</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">t3</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">T1 += (t2-t1);</span><br><span class="line">T2 += (t3-t2);</span><br><span class="line"><span class="keyword">if</span> (!isEqual(arr1, arr2) || !isEqual(arr2, arr3)) &#123;</span><br><span class="line">succeed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(T1+<span class="string">&quot; &quot;</span>+T2);</span><br><span class="line"><span class="comment">//System.out.println(succeed ? &quot;Nice!&quot; : &quot;Oops!&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] generateRandomArray(<span class="type">int</span> maxSize, <span class="type">int</span> maxValue) &#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = (<span class="type">int</span>) ((maxValue + <span class="number">1</span>) * Math.random()) </span><br><span class="line">                - (<span class="type">int</span>) (maxValue * Math.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] copyArray(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span>)  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">res[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((arr1 == <span class="literal">null</span> &amp;&amp; arr2 != <span class="literal">null</span>) || (arr1 != <span class="literal">null</span> &amp;&amp; arr2 == <span class="literal">null</span>)) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (arr1 == <span class="literal">null</span> &amp;&amp; arr2 == <span class="literal">null</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (arr1.length != arr2.length) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line"><span class="keyword">if</span> (arr1[i] != arr2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span>) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) </span><br><span class="line">System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12、手写归并"><a href="#12、手写归并" class="headerlink" title="12、手写归并"></a>12、手写归并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> M, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> L;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M)</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R)</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++)</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    process(arr, L, mid);</span><br><span class="line">    process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    printArray(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13、手写堆排"><a href="#13、手写堆排" class="headerlink" title="13、手写堆排"></a>13、手写堆排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序额外空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        heapify(arr, i, arr.length);</span><br><span class="line">    <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">    <span class="comment">// O(N*logN)</span></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123; <span class="comment">// O(N)</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, heapSize); <span class="comment">// O(logN)</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[index]刚来的数，往上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[index]位置的数，能否往下移动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子的下标</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; heapSize) &#123; <span class="comment">// 下方还有孩子的时候</span></span><br><span class="line">        <span class="comment">// 两个孩子中，谁的值大，把下标给largest</span></span><br><span class="line">        <span class="comment">// 1）只有左孩子，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left+<span class="number">1</span> &lt; heapSize &amp;&amp; arr[left+<span class="number">1</span>]&gt; arr[left] ? left+<span class="number">1</span> : left;</span><br><span class="line">        <span class="comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span></span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, largest, index);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    heapSort(arr1);</span><br><span class="line">    printArray(arr1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、手写单例"><a href="#14、手写单例" class="headerlink" title="14、手写单例"></a>14、手写单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">              singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15、手写LRUcache"><a href="#15、手写LRUcache" class="headerlink" title="15、手写LRUcache"></a>15、手写LRUcache</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于linkedHashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer,Integer&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;   <span class="comment">//容量大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(capacity);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//缓存中不存在此key，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        cache.remove(key);   <span class="comment">//先从链表中删除</span></span><br><span class="line">        cache.put(key,res);  <span class="comment">//再把该节点放到链表末尾处</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(key); <span class="comment">//已经存在，在当前链表移除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(capacity == cache.size()) &#123;</span><br><span class="line">            <span class="comment">//cache已满，删除链表头位置</span></span><br><span class="line">            Set&lt;Integer&gt; keySet = cache.keySet();</span><br><span class="line">            Iterator&lt;Integer&gt; iterator = keySet.iterator();</span><br><span class="line">            cache.remove(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key,value);  <span class="comment">//插入到链表末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DNode</span> &#123;</span><br><span class="line">        DNode prev;</span><br><span class="line">        DNode next;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, DNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    DNode head, tail;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">DNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">DNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.val = value;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DNode</span>();</span><br><span class="line">            newNode.val = value;</span><br><span class="line">            newNode.key = key;</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; cap) &#123;</span><br><span class="line">                map.remove(tail.prev.key);</span><br><span class="line">                removeNode(tail.prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DNode node)</span> &#123;</span><br><span class="line">        <span class="type">DNode</span> <span class="variable">prevNode</span> <span class="operator">=</span> node.prev;</span><br><span class="line">        <span class="type">DNode</span> <span class="variable">nextNode</span> <span class="operator">=</span> node.next;</span><br><span class="line">        prevNode.next = nextNode;</span><br><span class="line">        nextNode.prev = prevNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DNode node)</span> &#123;</span><br><span class="line">        <span class="type">DNode</span> <span class="variable">firstNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = firstNode;</span><br><span class="line">        firstNode.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="16、手写线程池"><a href="#16、手写线程池" class="headerlink" title="16、手写线程池"></a><strong>16、手写线程池</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.concurrent.pool;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySelfThreadPool</span> &#123;</span><br><span class="line"><span class="comment">//默认线程池中的线程的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WORK_NUM</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//默认处理任务的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TASK_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> workNum;<span class="comment">//线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> taskNum;<span class="comment">//任务数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;WorkThread&gt; workThreads;<span class="comment">//保存线程的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; taskQueue;<span class="comment">//阻塞有序队列存放任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MySelfThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(WORK_NUM, TASK_NUM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MySelfThreadPool</span><span class="params">(<span class="type">int</span> workNum, <span class="type">int</span> taskNum)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (workNum &lt;= <span class="number">0</span>) workNum = WORK_NUM;</span><br><span class="line"><span class="keyword">if</span> (taskNum &lt;= <span class="number">0</span>) taskNum = TASK_NUM;</span><br><span class="line">taskQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(taskNum);</span><br><span class="line"><span class="built_in">this</span>.workNum = workNum;</span><br><span class="line"><span class="built_in">this</span>.taskNum = taskNum;</span><br><span class="line">workThreads = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//启动一定数量的线程数，从队列中获取任务处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;workNum;i++) &#123;</span><br><span class="line"><span class="type">WorkThread</span> <span class="variable">workThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>(<span class="string">&quot;thead_&quot;</span>+i);</span><br><span class="line">workThread.start();</span><br><span class="line">workThreads.add(workThread);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">taskQueue.put(task);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ready close thread pool...&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (workThreads == <span class="literal">null</span> || workThreads.isEmpty()) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (WorkThread workThread : workThreads) &#123;</span><br><span class="line">workThread.stopWork();</span><br><span class="line">workThread = <span class="literal">null</span>;<span class="comment">//help gc</span></span><br><span class="line">&#125;</span><br><span class="line">workThreads.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WorkThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">setName(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> taskQueue.take();<span class="comment">//获取任务</span></span><br><span class="line"><span class="keyword">if</span> (runnable !=<span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(getName()+<span class="string">&quot; readyexecute:&quot;</span>+runnable.toString());</span><br><span class="line">runnable.run();<span class="comment">//执行任务</span></span><br><span class="line">&#125;</span><br><span class="line">runnable = <span class="literal">null</span>;<span class="comment">//help gc</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">interrupt();</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopWork</span><span class="params">()</span> &#123;</span><br><span class="line">interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.concurrent.pool;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMySelfThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TASK_NUM</span> <span class="operator">=</span> <span class="number">50</span>;<span class="comment">//任务的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MySelfThreadPool</span> <span class="variable">myPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySelfThreadPool</span>(<span class="number">3</span>,<span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;TASK_NUM;i++) &#123;</span><br><span class="line">myPool.execute(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;task_&quot;</span>+i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;task :&quot;</span>+name+<span class="string">&quot; end...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;name = &quot;</span>+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17、手写消费者生产者模式"><a href="#17、手写消费者生产者模式" class="headerlink" title="17、手写消费者生产者模式"></a><strong>17、手写消费者生产者模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() + num &gt; MAX_VALUE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;暂时不能执行生产任务&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;已生产产品数&quot;</span>+num+<span class="string">&quot; 仓库容量&quot;</span>+list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() &lt; num) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;暂时不能执行消费任务&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;已消费产品数&quot;</span>+num+<span class="string">&quot; 仓库容量&quot;</span> + list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Storage storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        storage.produce(<span class="built_in">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Storage storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        storage.consume(<span class="built_in">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Storage</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(storage);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(storage);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(storage);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(storage);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(storage);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(storage);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(storage);</span><br><span class="line">        p1.setNum(<span class="number">10</span>);</span><br><span class="line">        p2.setNum(<span class="number">20</span>);</span><br><span class="line">        p3.setNum(<span class="number">80</span>);</span><br><span class="line">        c1.setNum(<span class="number">50</span>);</span><br><span class="line">        c2.setNum(<span class="number">20</span>);</span><br><span class="line">        c3.setNum(<span class="number">20</span>);</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        c3.start();</span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        p3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18、手写阻塞队列"><a href="#18、手写阻塞队列" class="headerlink" title="18、手写阻塞队列"></a><strong>18、手写阻塞队列</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">blockQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; container = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">isNull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">isFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    blockQueue(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (size &gt;= capacity) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;阻塞队列满了&quot;</span>);</span><br><span class="line">                    isFull.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                isFull.signal();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ++size;</span><br><span class="line">            container.add(data);</span><br><span class="line">            isNull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;阻塞队列空了&quot;</span>);</span><br><span class="line">                    isNull.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                isNull.signal();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> container.get(<span class="number">0</span>);</span><br><span class="line">            container.remove(<span class="number">0</span>);</span><br><span class="line">            isFull.signal();</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AxinBlockQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AxinBlockQueue</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;塞入&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费&quot;</span>+queue.take());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">800</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19、手写多线程交替打印ABC"><a href="#19、手写多线程交替打印ABC" class="headerlink" title="19、手写多线程交替打印ABC"></a><strong>19、手写多线程交替打印ABC</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">syncPrinter</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">// 打印次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRINT_COUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition thisCondtion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition nextCondtion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> printChar;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">syncPrinter</span><span class="params">(ReentrantLock reentrantLock, Condition thisCondtion, Condition nextCondition, <span class="type">char</span> printChar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reentrantLock = reentrantLock;</span><br><span class="line">        <span class="built_in">this</span>.nextCondtion = nextCondition;</span><br><span class="line">        <span class="built_in">this</span>.thisCondtion = thisCondtion;</span><br><span class="line">        <span class="built_in">this</span>.printChar = printChar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取打印锁 进入临界区</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连续打印PRINT_COUNT次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; PRINT_COUNT; i++) &#123;</span><br><span class="line">                <span class="comment">//打印字符</span></span><br><span class="line">                System.out.print(printChar);</span><br><span class="line">                <span class="comment">// 使用nextCondition唤醒下一个线程</span></span><br><span class="line">                <span class="comment">// 因为只有一个线程在等待，所以signal或者signalAll都可以</span></span><br><span class="line">                nextCondtion.signal();</span><br><span class="line">                <span class="comment">// 不是最后一次则通过thisCondtion等待被唤醒</span></span><br><span class="line">                <span class="comment">// 必须要加判断，不然虽然能够打印10次，但10次后就会直接死锁</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; PRINT_COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 本线程让出锁并等待唤醒</span></span><br><span class="line">                        thisCondtion.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">syncPrinter</span>(lock, conditionA, conditionB,<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">syncPrinter</span>(lock, conditionB, conditionC,<span class="string">&#x27;B&#x27;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">syncPrinter</span>(lock, conditionC, conditionA,<span class="string">&#x27;C&#x27;</span>));</span><br><span class="line">        printA.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        printB.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        printC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20、交替打印FooBar"><a href="#20、交替打印FooBar" class="headerlink" title="20、交替打印FooBar"></a>20、交替打印FooBar</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手太阴肺经 BLOCKING Queue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; bar = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; foo = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            foo.put(i);</span><br><span class="line">            printFoo.run();</span><br><span class="line">            bar.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bar.take();</span><br><span class="line">            printBar.run();</span><br><span class="line">            foo.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手阳明大肠经CyclicBarrier 控制先后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar6</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!fin);</span><br><span class="line">            printFoo.run();</span><br><span class="line">            fin = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;</span><br><span class="line">            printBar.run();</span><br><span class="line">            fin = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手少阴心经 自旋 + 让出CPU</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar5</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">permitFoo</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(permitFoo) &#123;</span><br><span class="line">            printFoo.run();</span><br><span class="line">            i++;</span><br><span class="line">            permitFoo = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!permitFoo) &#123;</span><br><span class="line">        printBar.run();</span><br><span class="line">        i++;</span><br><span class="line">        permitFoo = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//手少阳三焦经 可重入锁 + Condition</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar4</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">foo</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">                    foo.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                foo.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">                    foo.await();</span><br><span class="line">            &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                foo.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手厥阴心包经 synchronized + 标志位 + 唤醒</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 标志位，控制执行顺序，true执行printFoo，false执行printBar</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">type</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object foo=  <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 锁标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (foo) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!type)&#123;</span><br><span class="line">                    foo.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                type = <span class="literal">false</span>;</span><br><span class="line">                foo.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (foo) &#123;</span><br><span class="line">                <span class="keyword">while</span>(type)&#123;</span><br><span class="line">                    foo.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                type = <span class="literal">true</span>;</span><br><span class="line">                foo.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//手太阳小肠经 信号量 适合控制顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            foo.acquire();</span><br><span class="line">        printFoo.run();</span><br><span class="line">            bar.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bar.acquire();</span><br><span class="line">        printBar.run();</span><br><span class="line">            foo.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="六、个人项目"><a href="#六、个人项目" class="headerlink" title="六、个人项目"></a><strong>六、个人项目</strong></h1><h2 id="一、一站到底"><a href="#一、一站到底" class="headerlink" title="一、一站到底"></a><strong>一、一站到底</strong></h2><p>​采用SpringBoot构建项目，主要通过分布式缓存、队列、限流保证系统高可用，Netty、缓存、反向代理保证高并发。</p><blockquote><p>双人对战答题、公司对战抢答</p></blockquote><h3 id="1、如何设计排行榜"><a href="#1、如何设计排行榜" class="headerlink" title="1、如何设计排行榜"></a>1、如何设计排行榜</h3><ul><li>个人总得分和总排名实时更新</li><li>个人排行榜按分数、时间、次数、正确率展示</li><li>日榜、过去N日榜滚动更新</li></ul><h4 id="性能优化过程"><a href="#性能优化过程" class="headerlink" title="性能优化过程"></a>性能优化过程</h4><p>​第一条需求很简单，使用了Redis的<strong>Zset</strong>实现不过这里总得分采用了基于<strong>分数、时间、次数和正确率</strong>的混合加权。考虑到数据的<strong>持久化</strong>，以及<strong>关系数据库和缓存的一致性</strong>导致的设计的复杂性，使用了<strong>谷歌</strong>开源的<strong>JamsRanking</strong></p><p>​优点<strong>是可以直接使用现成的setScores和getRanking接口封装了Redis和Mysql和消息队列的完成</strong>事务和一致性<strong>的使用细节。缺点是</strong>并发比较低<strong>使用Jmeter进行压测，单机只有</strong>20<strong>左右的</strong>TPS**</p><p>​后来看了下源码，主要是它针对每一次设置都进行了分布式事务处理，并且会返回事务提交或回滚的结果。了解了底层实现以后就去谷歌的<strong>开源社区</strong>去查阅了相关的解决方案，当时官方对这个问题并没有通过<strong>配置能直接解决问题</strong>的快捷方式，不过推荐了使用者自身如果对响应时间不高的场景下可以采用<strong>批量合并事务</strong>的方式进行优化。基于这个思路，我们把写操作进行了封装并放入了<strong>队列</strong>，然后在消费者端批量取得数据后进行事务的批量处理，压测环境下整体性能达到了<strong>500TPS</strong>。已经基本满足了线上更新的需求，但是当时压测的过程中，队列偶尔的吞吐量会<strong>大范围波动</strong>，经常会持续数十秒，然后业务一次性处理完再响应，导致<strong>局部响应时间大幅度增长</strong></p><p>​后来也是在官网上查询，了解到谷歌开源组件使用的<strong>队列服务</strong>底层是使用<strong>BigTable</strong>作为持久层，但是当BigTable分片过大时，会触发<strong>再分片</strong>的过程，再分片的过程中，是<strong>不会进行任务分发</strong>的，所以就会导致先前的问题。针对这个问题，谷歌官方的建议是提前<strong>配置队列的数量、负载策略和最大容量</strong>等信息，保证所有队列<strong>不同时触发</strong>再分片</p><p>​进行两次优化后，压测环境已经基本可以满足预期了，在实际生产环境的部署中，发现对于事务更新失败时，JamsRanking会对失败的事务进行<strong>切分和重试</strong>，整个过程对于研发人员是<strong>透明</strong>的，不利于线上问题排查，所以我们当时特地写了一个watchdog的工具，监控事务回滚达到十次以上的事务，查明原因后通过后台管理系统进行相应补偿，保证<strong>最终一致性</strong></p><p><strong>最终结果：</strong></p><ul><li><p>高效快速：能在数百毫秒内找到玩家排名以及进行更新</p></li><li><p>强一致性以及持久化、排名准确</p></li><li><p>可以扩展到任意数量的玩家</p></li><li><p>吞吐量有限制，只能支持约每秒 500次更新。</p></li></ul><p>针对这个缺点谷歌官方也是给出了使用分片树和近似排名的解决方案，当然复杂的方案有更高的运维成本，所以我们优化工作也就到此为止</p><h4 id="方案优化过程"><a href="#方案优化过程" class="headerlink" title="方案优化过程"></a>方案优化过程</h4><h4 id="方案1：每日一个滚动榜，当日汇聚（费时间）"><a href="#方案1：每日一个滚动榜，当日汇聚（费时间）" class="headerlink" title="方案1：每日一个滚动榜，当日汇聚（费时间）"></a>方案1：每日一个滚动榜，当日汇聚（费时间）</h4><p>​首先记录每天的排行榜和一个滚动榜，加分时同时写入这两个榜单，每日零点后跑工具将前几天数据累加写入当日滚动榜，该方案缺点是时间复杂度高，7天榜还好，只需要读过去6天数据，如果是100天榜，该方案需要读过去99天榜，显然不可接受</p><h4 id="方案2：全局N个滚动榜同时写（费空间）"><a href="#方案2：全局N个滚动榜同时写（费空间）" class="headerlink" title="方案2：全局N个滚动榜同时写（费空间）"></a>方案2：全局N个滚动榜同时写（费空间）</h4><p>​要做到每日零点后榜单实时生效，而不需要等待离线作业的完成，一种方案是预写未来的榜单。可以写当天的滚动榜的同时，写往后N-1天的滚动榜一起写入该方案不仅能脱离离线作业做到实时更新，且可以省略每天的日榜。但缺点也不难看出，对于7天滚动榜，每次写操作需要更新7个榜单，但是对于百日榜，空间消耗无法接受，1000万榜单大约消耗1G内存</p><h4 id="方案3：实时更新，常数次写操作"><a href="#方案3：实时更新，常数次写操作" class="headerlink" title="方案3：实时更新，常数次写操作"></a>方案3：实时更新，常数次写操作</h4><p>有不有办法做到既能实时更新，写榜数量也不随N的增加而增加呢？</p><p>​仍然是记录每天的排行榜和一个滚动榜，加分操作也还是同时操作当日榜和全局榜，但每日零点的离线作业改为从全局榜中减去之前过期的数据，从而实现先滚动更新。  此方案每次只需读取一个日榜做减法，时间复杂度为O(1)；但是无法做到实时更新。 这个方案的优点是在十二点前提前准备好差分榜，到了十二点直接加上当天数据就是滚动榜内容 ，这样就在常数次写操作的前提下，实现了滚动榜的实时更新</p><h3 id="2、如何解决重复答题"><a href="#2、如何解决重复答题" class="headerlink" title="2、如何解决重复答题"></a>2、<strong>如何解决重复答题</strong></h3><p>​<strong>利用setnx防止重复答题</strong><br>​分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁推荐使用set的方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐使用redis+lua脚本</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lua</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(lua, Collections.singletonList(lockKey)</span><br></pre></td></tr></table></figure><h3 id="3、一个题目被多个人抢答"><a href="#3、一个题目被多个人抢答" class="headerlink" title="3、一个题目被多个人抢答"></a><strong>3、一个题目被多个人抢答</strong></h3><p>​<strong>利用redis来实现乐观锁（抢答）</strong>，好处是答错的人不影响状态，第一个秒杀答对的人才能得分。</p><p>1、利用redis的watch功能，监控这个 Corp:Activ:Qust: 的状态值<br>2、获取Corp:Activ:Qust: 的值，创建redis事务，给这个key的值-1<br>3、执行这个事务，如果key的值被修改过则回滚，key不变</p><h3 id="4、如何管理昵称重复"><a href="#4、如何管理昵称重复" class="headerlink" title="4、如何管理昵称重复"></a><strong>4、如何管理昵称重复</strong></h3><p>​<strong>使用布隆过滤器：</strong></p><p>​它实际上是一个很长的二进制矢量数组和 K 个哈希函数。当一个昵称加入布隆过滤器中的时候，会进行如下操作：</p><ul><li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。 Na</li></ul><p>​用户新增昵称时需要首先计算K个哈希值，如果K个哈希值有一个不为0则通过，否则不通过，不通过时通过加随机字符串再次检验，检测通过后返回给前端，帮助用户自动填写。</p><p>​布隆过滤器的好处是它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p><p>BloomFilter 的优势是，全内存操作，性能很高。另外空间效率非常高，<strong>要达到 1% 的误判率，平均单条记录占用 1.2 字节即可。而且，平均单条记录每增加 0.6 字节，还可让误判率继续变为之前的 1&#x2F;10，即平均单条记录占用 1.8 字节，误判率可以达到 1&#x2F;1000；平均单条记录占用 2.4 字节，误判率可以到 1&#x2F;10000，以此类推</strong>。这里的误判率是指，BloomFilter 判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，而非 key 的值，所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。对于 BloomFilter 判断不存在的 key ，则是 100% 不存在的，反证法，如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，而不会是 0</p><p>​</p><h3 id="5、如何管理出题定时任务"><a href="#5、如何管理出题定时任务" class="headerlink" title="5、如何管理出题定时任务"></a><strong>5、如何管理出题定时任务</strong></h3><p>​压测环境中服务器通过Netty的主从Reactor多路复用NIO事件模型，单机可以<strong>轻松应对十万长连接</strong>，但是每个业务中，由于每个用户登录系统后需要按照指定顺序答题，例如一共要答十道，那么服务器针对这一个用户就会产生十个定时任务，所以对于系统来说，定时器的<strong>数量就是百万级别的</strong>。</p><p>​通过压测结果发现：JDK自带的Timer，在大概三万并发时性能就急剧下降了。也是此时根据业务场景的需要，将定时任务改成了Netty自带的HashedWheelTimer时间轮方案，通过压测单机在50万级别下依然能够平滑的执行。</p><p>​也是这个强烈的反差，使我在强烈的好奇心促使下，阅读源码了解到常规的JDK 的Timer 和 DelayedQueue 等工具类，可实现简单的定时任务，单底层用的是<strong>堆数据结构</strong>，存取复杂度都是 <strong>O(NlogN)<strong>，无法支撑海量定时任务。</strong>Netty经典的时间轮方案</strong>，正是通过将任务存取及取消操作时间复杂度降为 O(1)，而广泛应用在定时<strong>任务量大、性能要求高</strong>的场景中。</p><p>​<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvl9c3hp2j30py0d7q4i.jpg" alt="img" style="zoom:50%;" /></p><p>​基于Netty的Websocket底层，服务器端维护一个高效批量管理定时任务的调度模型。时间轮一般会实现成一个<strong>环形数组结构</strong>，类似一个时钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用<strong>双向链表</strong>存储定时任务。指针<strong>周期性地跳动</strong>，跳动到一个槽位，就执行该槽位的定时任务。</p><p>​单层时间轮的容量和精度都是有限的，对于精度要求特别高、时间跨度特别大或是海量定时任务需要调度的场景，可以考虑使用多级时间轮以及持久化存储与时间轮结合的方案。时间轮的<strong>定时任务处理逻辑</strong>如下：</p><ol><li>将缓存在 timeouts 队列中的定时任务转移到时间轮中对应的槽中</li><li>根据当前指针定位对应槽，处理该槽位的双向链表中的定时任务，从链表头部开始迭代：<ul><li>属于当前时钟周期则取出运行</li><li>不属于则将其剩余的时钟周期数减一</li></ul></li><li>检测时间轮的状态。如果时间轮处于运行状态，则循环执行上述步骤，不断执行定时任务。</li></ol><h3 id="6：如何解决客户端断连"><a href="#6：如何解决客户端断连" class="headerlink" title="6：如何解决客户端断连"></a><strong>6：如何解决客户端断连</strong></h3><p>​使用Netty的<strong>重连检测狗</strong>ConnectionWatchdog</p><p>​服务端定义refreshTime，当我们从channel中read到了服务端发来的心跳响应消息的话，就刷新refreshTime为当前时间</p><p>​客户端在state是WRITER_IDLE的时候每隔一秒就发送一个心跳包到sever端，告诉server端我还活着。</p><p>当重连成功时，会触发channelActive方法，在这里我们开启了一个定时任务去判断refreshTime和当前时间的时间差，超过5秒说明断线了，要进行重连，最后计算重连次数，尝试连接2次以上连不上就会修改header信息强制重连去连另一个服务器。</p><h2 id="二、秒杀项目"><a href="#二、秒杀项目" class="headerlink" title="二、秒杀项目"></a>二、秒杀项目</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a><strong>技术选型</strong></h3><p>秒杀用到的基础组件，主要有<strong>框架、KV 存储、关系型数据库、MQ</strong>。</p><p>框架主要有 Web 框架和 RPC 框架。</p><p>其中，Web 框架主要用于提供 HTTP 接口给浏览器访问，所以 Web 框架的选型在秒杀服务中非常重要。在这里，我<strong>推荐Gin</strong>，它的性能和易用性都不错，在 <strong>GitHub 上的 Star 达到了 44k</strong>。对比性能最好的 fasthttp，虽然 fasthttp 在请求延迟低于 10ms 时性能优势明显，但其底层使用的对象池容易让人踩坑，导致其易用性较差，所以没必要过于追求性能而忽略了稳定性</p><p>至于 RPC 框架，我推荐选用 <strong>gRPC</strong>，因为它的扩展性和性能都非常不错。在秒杀系统中，Redis 中的数据主要是给秒杀接口服务使用，以便将配置从管理后台同步到 Redis 缓存中。</p><p>KV 存储方面，秒杀系统中主要是用 <strong>Redis 缓存活动配置</strong>，用 <strong>etcd 存储集群信息</strong>。</p><p>关系型数据库中，<strong>MySQL</strong> 技术成熟且稳定可靠，秒杀系统用它存储活动配置数据很合适。主要 原因还是秒杀活动信息和库存数据都缓存在 Redis 中，活动过程中秒杀服务不操作数据库， 使用 MySQL 完全能够满足需求。</p><p>MQ 有很多种，其中 <strong>Kafka</strong> 在业界认可度最高，技术也非常成熟，性能很不错，非常适合用在秒杀系统中。Kafka 支持自动创建队列，秒杀服务各个节点可以用它自动创建属于自己的队列</p><h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><p><strong>背景</strong></p><ul><li><p>秒杀业务简单，每个秒杀活动的商品是事先定义好的，商品有明确的类型和数量，卖完即止</p></li><li><p>秒杀活动定时上架，消费者可以在活动开始后，通过秒杀入口进行抢购秒杀活动</p></li><li><p>秒杀活动由于商品物美价廉，开始售卖后，会被快速抢购一空。</p></li></ul><p><strong>现象</strong></p><p>-<br>  秒杀活动持续时间短，访问冲击量大，秒杀系统需要应对这种爆发性的访问模型</p><p>-<br>  业务的请求量远远大于售卖量，大部分是陪跑的请求，秒杀系统需要提前规划好处理策略</p><p>-<br>  前端访问量巨大，系统对后端数据的访问量也会短时间爆增，对数据存储资源进行良好设计</p><p>-<br>  活动期间会给整个业务系统带来超大负荷，需要制定各种策略，避免系统过载而宕机</p><p>-<br>  售卖活动商品价格低廉，存在套利空间，各种非法作弊手段层出，需要提前规划预防策略</p><p><strong>秒杀系统设计</strong></p><p>​首先，要<strong>尽力将请求拦截在系统上游</strong>，层层设阻拦截，过滤掉无效或超量的请求。因为访问量远远大于商品数量，所有的请求打到后端服务的最后一步，其实并没有必要，反而会严重拖慢真正能成交的请求，降低用户体验。</p><p>​秒杀系统专为秒杀活动服务，售卖商品确定，因此可以在设计秒杀商品页面时，将商品信息提前设计为静态信息，将静态的商品信息以及常规的 CSS、JS、宣传图片等静态资源，一起<strong>独立存放到 CDN 节点</strong>，加速访问，且降低系统访问压力，在访问前端也可以<strong>制定种种限制策略，</strong>比如活动没开始时，抢购按钮置灰，避免抢先访问，用户抢购一次后，也将按钮置灰，让用户排队等待，避免反复刷新。</p><p>​其次，要<strong>充分利用缓存</strong>，提升系统的性能和可用性。</p><p>​用户所有的请求进入秒杀系统前，通过<strong>负载均衡策略</strong>均匀分发到不同 Web 服务器，避免节点过载。在 Web 服务器中，首先检查用户的访问权限，识别并发刷订单的行为。如果发现售出数量已经达到秒杀数量，则直接返回结束，要将秒杀业务系统和其他业务系统进行功能分拆，尽量将秒杀系统及依赖服务<strong>独立分拆部署</strong>，避免影响其他核心业务系统。</p><p>​秒杀系统需要构建访问记录缓存，记录访问 IP、用户的访问行为，发现异常访问，提前进行阻断及返回。同时还需要<strong>构建用户缓存</strong>，并针对历史数据分析，提前缓存僵尸强刷专业户，方便在秒杀期间对其进行策略限制。这些访问记录、用户数据，通过缓存进行存储，可以加速访问，另外，对用户数据还进行缓存预热，避免活动期间大量穿透。</p><h3 id="1、如何解决超卖？"><a href="#1、如何解决超卖？" class="headerlink" title="1、如何解决超卖？"></a><strong>1、如何解决超卖？</strong></h3><p>mysql乐观锁+redis预减库存+redis缓存卖完标记 </p><p>第一是基于<strong>数据库乐观锁</strong>的方式保证数据并发扣减的强一致性；</p><p>第二是基于<strong>数据库的事务</strong>实现批量扣减部分失败时的数据回滚。</p><p>​在扣减指定数量前应先做一次前置数量校验的读请求（参考<strong>读写分离</strong> + <strong>全缓存方案</strong>）</p><blockquote><p>纯数据库乐观锁+事务的方式性能比较差，但是如果不计成本和考虑场景的话也完全够用，因为任何没有机器配置的指标，都是耍流氓。如果我采用 Oracle 的数据库、100 多核的刀锋服务器、SSD 的硬盘，即使是纯数据库的扣减方案，也是可以达到单机上万的 TPS 的。</p></blockquote><p><strong>单线程Redis 的 lua 脚本实现批量扣减</strong></p><p>当用户调用扣减接口时，将扣减的 对应数量 + 脚本标示传递至 Redis 即可，所有的扣减判断逻辑均在 Redis 中的 lua 脚本中执行，lua 脚本执行完成之后返还是否成功给客户端。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j9dkq6vj30w20kowku.jpg" alt="image-20210504174103769" style="zoom:50%;" /><p>Redis 中的 lua 脚本执行时，首先会使用 get 命令查询 uuid 进行查重。当防重通过后，会<strong>批量获取对应的剩余库存状态并进行判断</strong>，如果一个扣减的数量大于剩余数量，则返回错误并提示数量不足。</p><p>Redis 的单线程模型，确保<strong>不会出现当所有扣减数量在判断均满足后，在实际扣减时却数量不够</strong>。同时，单线程保证判断数量的步骤和后续扣减步骤之间，没有其他任何线程出现并发的执行。</p><p>当 Redis 扣减成功后，扣减接口会<strong>异步的将此次扣减内容保存至数据库</strong>。异步保存数据库的目的是防止出现极端情况—— Redis 宕机后数据未持久化到磁盘，此时我们可以使用数据库恢复或者校准数据</p><p>最后，运营后台直连数据库，是运营和商家修改库存的入口。商家在运营后台进货物进行补充。同时，运营后台的实现需要将此数量<strong>同步的增加至 Redis</strong>，因为当前方案的所有实际扣减都在 Redis 中</p><blockquote><p>纯缓存方案虽<strong>不会导致超卖</strong>，但因<strong>缓存不具备事务特性</strong>，极端情况下会存在缓存里的数据<strong>无法回滚</strong>，导致出现<strong>少卖</strong>的情况。且架构中的异步写库，也可能发生失败，导致多扣的数据丢失</p></blockquote><p>可以借助<strong>顺序写</strong>的特性，将扣减任务同步<strong>插入</strong>任务表，发现异常时，将任务表作为<strong>undolog</strong>进行回滚</p><p>可以解决由于<strong>网络不通</strong>、调用缓存<strong>扣减超时</strong>、在扣减到一半时缓存<strong>突然宕机</strong>（故障 failover）了。针对上述请求，都有相应的异常抛出，根据异常进行<strong>数据库回滚</strong>即可，最终任务库里的数据都是准的</p><p>更进一步：由于任务库是无状态的，可以进行水平分库，提升整体性能</p><h3 id="2、如何解决重复下单？"><a href="#2、如何解决重复下单？" class="headerlink" title="2、如何解决重复下单？"></a><strong>2、如何解决重复下单？</strong></h3><p>mysql唯一索引+分布式锁 </p><h3 id="3、如何防刷？"><a href="#3、如何防刷？" class="headerlink" title="3、如何防刷？"></a><strong>3、如何防刷？</strong></h3><p>IP限流 | 验证码 | 单用户 | 单设备 | IMEI | 源IP |均设置规则</p><h3 id="4、热key问题如何解决？"><a href="#4、热key问题如何解决？" class="headerlink" title="4、热key问题如何解决？"></a><strong>4、热key问题如何解决？</strong></h3><p>redis集群+本地缓存+限流+key加随机值分布在多个实例中 </p><p>1、<strong>缓存集群</strong>可以单节点进行<strong>主从复制和垂直扩容</strong></p><p>2、利用应用内的<strong>前置缓存</strong>，但是需注意需要设置上限</p><p>3、延迟不敏感，<strong>定时刷新</strong>，实时感知用主动刷新</p><p>4、和缓存穿透一样，限制逃逸流量，单请求进行数据<strong>回源并刷新前置</strong></p><p>5、无论如何设计，最后都要写一个<strong>兜底逻辑</strong>，千万级流量说来就来</p><h3 id="5、应对高并发的读请求"><a href="#5、应对高并发的读请求" class="headerlink" title="5、应对高并发的读请求"></a><strong>5、应对高并发的读请求</strong></h3><p>使用缓存策略将请求挡在上层中的缓存中</p><p>使用CDN，能静态化的数据尽量做到静态化，</p><p>加入限流（比如对短时间之内来自某一个用户，某一个IP、某个设备的重复请求做丢弃处理）</p><p><strong>资源隔离限流</strong>会将对应的资源按照指定的类型进行隔离，比如<strong>线程池</strong>和<strong>信号量</strong>。</p><ul><li><p>计数器限流，例如5秒内技术1000请求，超数后限流，未超数重新计数</p></li><li><p>滑动窗口限流，解决计数器不够精确的问题，把一个窗口拆分多滚动窗口</p></li><li><p>令牌桶限流，类似景区售票，售票的速度是固定的，拿到令牌才能去处理请求</p></li><li><p>漏桶限流，生产者消费者模型，实现了恒定速度处理请求，能够绝对防止突发流量</p><p>流量控制效果从好到差依次是：<strong>漏桶限流 &gt; 令牌桶限流 &gt; 滑动窗口限流 &gt; 计数器限流</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ja736ekj316o06640u.jpg" alt="image-20210504174148831" style="zoom:50%;" /><p>其中，只有漏桶算法<strong>真正实现了恒定速度处理请求</strong>，能够绝对<strong>防止突发流量超过下游系统承载能力</strong>。<br>不过，漏桶限流也有个不足，就是需要分<strong>配内存资源缓存请求</strong>，这会增加内存的使用率。而<strong>令牌桶限流</strong>算法中的“桶”可以用一个整数表示，<strong>资源占用相对较小</strong>，这也让它成为最常用的限流算法。正是因为这些特点，<strong>漏桶限流和令牌桶限流</strong>经常在一些大流量系统中结合使用。</p></li></ul><h3 id="6、应对高并发的写请求"><a href="#6、应对高并发的写请求" class="headerlink" title="6、应对高并发的写请求"></a><strong>6、应对高并发的写请求</strong></h3><ul><li><p><strong>削峰</strong>：恶意用户拦截</p><p>对于单用户多次点击、单设备、IMEI、源IP均设置规则</p></li><li><p>采用比较成熟的<strong>漏桶算法、令牌桶</strong>算法，也可以使用<strong>guava</strong>开箱即用的限流算法</p><p>可以集群限流，但单机限流更加简洁和稳定</p></li><li><p>当前层<strong>直接过滤</strong>一定比例的请求，最大承载值前需要加上<strong>兜底逻辑</strong></p></li><li><p>对于已经无货的产品，<strong>本地缓存</strong>直接返回</p></li><li><p><strong>单独部署，减少对系统正常服务的影响，方便扩缩容</strong></p></li></ul><p>对于<strong>一段时间内的秒杀活动，需要保证写成功</strong>，我们可以使用 <strong>消息队列</strong>。</p><ul><li>削去秒杀场景下的峰值写流量——<strong>流量削峰</strong></li><li>通过异步处理简化秒杀请求中的业务流程——<strong>异步处理</strong></li><li>解耦，实现秒杀系统模块之间松耦合——<strong>解耦</strong></li></ul><p><strong>削去秒杀场景下的峰值写流量</strong></p><ul><li><strong>将秒杀请求暂存于消息队列</strong>，业务服务器响应用户“秒杀结果正在处理中。。。”，释放系统资源去处理其它用户的请求。</li><li><strong>削峰填谷</strong>，削平短暂的流量高峰，消息堆积会造成请求延迟处理，但秒杀用户对于短暂延迟有一定容忍度。秒杀商品有 1000 件，处理一次购买请求的时间是 500ms，那么总共就需要 500s 的时间。这时你部署 10 个队列处理程序，那么秒杀请求的处理时间就是 50s，也就是说用户需要等待 50s 才可以看到秒杀的结果，这是可以接受的。这时会<strong>并发 10 个</strong>请求到达数据库，并不会对数据库造成很大的压力。</li></ul><p><strong>通过异步处理简化秒杀请求中的业务流程</strong></p><p>​先处理主要的业务，异步处理次要的业务。</p><ul><li>如主要流程是<strong>生成订单</strong>、<strong>扣减库存</strong>；</li><li>次要流程比如购买成功之后会给用户<strong>发优惠券</strong>，<strong>增加用户的积****分</strong>。</li><li>此时秒杀只要处理生成订单，扣减库存的耗时，发放优惠券、增加用户积分异步去处理了。</li></ul><p><strong>解耦</strong></p><p>​实现秒杀系统模块之间松耦合将秒杀数据同步给数据团队，有两种思路：</p><ul><li>使用 HTTP 或者 RPC 同步调用，即提供一个接口，实时将数据推送给数据服务。<strong>系统的耦合度高</strong>，如果其中一个服务有问题，可能会导致另一个服务不可用。</li><li>使用消息队列<strong>将数据全部发送给消息队列</strong>，然后<strong>数据服务订阅这个消息队列</strong>，接收数据进行处理。</li></ul><h3 id="7、如何保证数据一致性"><a href="#7、如何保证数据一致性" class="headerlink" title="7、如何保证数据一致性"></a><strong>7、如何保证数据一致性</strong></h3><p><strong>CacheAside旁路缓存</strong>读请求不命中查询数据库，查询完成写入缓存，写请求更新数据库后删除缓存数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key,Object data)</span>&#123;</span><br><span class="line">redis.delKey(key);</span><br><span class="line">db.updateData(data);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为防缓存失效这一信息丢失，可用消息队列确保。</p><ul><li>更新数据库数据；</li><li>数据库会将操作信息写入binlog日志当中；</li><li>另起一段非业务代码，程序订阅提取出所需要的数据以及key；</li><li>尝试删除缓存操作，若删除失败，将这些信息发送至消息队列；</li><li>重新从消息队列中获得该数据，重试操作；</li></ul><p>订阅<strong>binlog程序在mysql中有现成的中间</strong>件叫canal，重试机制，主要采用的是消息队列的方式。</p><p><strong>终极方案：请求串行化</strong></p><p>真正靠谱非秒杀的方案：将访问操作串行化</p><ol><li>先删缓存，将更新数据库的<strong>写操作放进有序队列中</strong></li><li>从缓存查不到的<strong>读操作也进入有序队列</strong></li></ol><p>需要解决的问题：</p><ol><li>读请求积压，大量超时，导致数据库的压力：限流、熔断</li><li>如何避免大量请求积压：将队列水平拆分，提高并行度。</li></ol><h3 id="8、可靠性如何保障"><a href="#8、可靠性如何保障" class="headerlink" title="8、可靠性如何保障**"></a>8、可靠性如何保障**</h3><p>​由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<strong>哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统</strong>中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。</p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluq6vlvglj30nw0e076f.jpg" alt="image-20201220231241725" style="zoom:50%;" /><p>​当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。 </p><h3 id="9、秒杀系统瓶颈-日志"><a href="#9、秒杀系统瓶颈-日志" class="headerlink" title="9、秒杀系统瓶颈-日志"></a>9、秒杀系统瓶颈-日志</h3><blockquote><p>秒杀服务单节点需要处理的请求 QPS 可能达到 10 万以上。一个请求从进入秒杀服务到处理失败或者成功，至少会产生两条日志。也就是说，高峰期间，一个秒杀节点每秒产生的日志可能达到 <strong>30 万条</strong>以上</p></blockquote><p>​一块性能比较好的固态硬盘，每秒写的IOPS 大概在 3 万左右。也就是说，一个秒杀节点的每秒日志条数是固态硬盘 IOPS 的 10 倍，磁盘都扛不住，更别说通过网络写入到监控系统中。</p><ul><li><strong>每秒日志量远高于磁盘 IOPS</strong>，直接写磁盘会影响服务性能和稳定性</li><li>大量日志导致服务频繁分配，<strong>频繁释放内存，影响服务性能</strong>。</li><li>服务异常退出<strong>丢失大量日志</strong>的问题</li></ul><p><strong>解决方案</strong></p><ul><li><strong>Tmpfs</strong>，即临时文件系统，它是一种基于内存的文件系统。我们可以将秒杀服务写日志的文件放在临时文件系统中。相比直接写磁盘，在临时文件系统中写日志的性能至少<strong>能提升 100 倍</strong>，每当日志文件达到 20MB 的时候，就将<strong>日志文件转移到磁盘上</strong>，并将临时文件系统中的日志文件清空。</li><li>可以参考内存池设计，将给logger分配缓冲区，每一次的新写可以复用Logger对象</li><li>参考kafka的缓冲池设计，当缓冲区达到大小和间隔时长临界值时，调用Flush函数，减少丢失的风险</li></ul><p><strong>10、池化技术</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6japwof2j31520na4mh.jpg" alt="image-20210504174220668"></p><p>​通常可以采用<strong>循环队列</strong>来保存空闲连接。使用的时候，可以从队列头部取出连接，用完后将空闲连接放到队列尾部。Netty中利用带缓冲区的 channel 来充当队列。</p><h2 id="三、即时通信"><a href="#三、即时通信" class="headerlink" title="三、即时通信"></a>三、即时通信</h2><h3 id="1、单聊消息可靠传输"><a href="#1、单聊消息可靠传输" class="headerlink" title="1、单聊消息可靠传输"></a>1、<strong>单聊消息可靠传输</strong></h3><p>TCP保证消息可靠传输三板斧：超时、重传、确认。服务端和客户端通信MSG和ACK的共计6个报文</p><ul><li>请求报文（request，后简称为为R），客户端主动发送给服务端。</li><li>应答报文（acknowledge，后简称为A），服务器被动应答客户端的报文。</li><li>通知报文（notify，后简称为N），服务器主动发送给客户端的报文</li></ul><p><strong>在线消息流程：</strong></p><p>​A 消息请求  <strong>MSG:R</strong>  &#x3D;&gt; S 消息应答  <strong>MSG:A</strong>  &#x3D;&gt; S 消息通知B  <strong>MSG:N</strong> </p><p>​S 确认通知  <strong>ACK:N</strong>  &lt;&#x3D;  S 确认应答  <strong>ACK:A</strong>  &lt;&#x3D;  B确认请求S  <strong>ACK:R</strong> </p><p><strong>超时与重传、确认和去重：</strong></p><p>​A发出了 <strong>MSG:R</strong> ，收到了<strong>MSG:A</strong>之后，在一个期待的时间内，如果没有收到<strong>ACK:N</strong>，A会尝试将 <strong>MSG:R</strong>  重发。可能A同时发出了很多消息，所以A需要在本地维护一个等待ack队列，并配合timer超时机制，来记录哪些消息没有收到<strong>ACK:N</strong>，定时重发。确认ACK<strong>保证必达</strong>，去重保证<strong>唯一</strong></p><p><strong>离线消息流程</strong></p><p>​原方案：根据离线好友的标识，交互拉取指定的消息</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8kxci29zj30b305974z.jpg" alt="IM消息送达保证机制实现(二)：保证离线消息的可靠投递_2.png"></p><p>优化的方案：</p><ul><li>如用户<strong>勾选全量</strong>则返回计数，在用户点击时拉取。</li><li>如用户未勾选全量则返回<strong>最近全部离线消息</strong>，客户端针对<strong>用户id进行计算</strong>。</li><li>全量离线信息可以通过客户端异步线程分页拉取，减少卡顿</li><li>将ACK和分页第二次拉取的报文重合，可以较少离线消息拉取交互的次数</li></ul><h3 id="2、群聊消息如何保证不丢不重"><a href="#2、群聊消息如何保证不丢不重" class="headerlink" title="2、群聊消息如何保证不丢不重"></a><strong>2、群聊消息如何保证不丢不重</strong></h3><blockquote><p>在线的群友能第一时间收到消息；<br>离线的群友能在登陆后收到消息。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8jswr3poj30hh078dg2.jpg" alt="IM群聊消息如此复杂，如何保证不丢不重？_1.jpg"></p><ul><li>群消息发送者x向server发出群消息；</li><li>server去db中查询群中有多少用户(x,A,B,C,D)；</li><li>server去cache中查询这些用户的在线状态；</li><li>对于群中在线的用户A与B，群消息server进行实时推送；</li><li>对于群中离线的用户C与D，群消息server进行离线存储。</li></ul><p>​    对于同一份群消息的内容，多个离线用户存储了很多份。假设群中有200个用户离线，离线消息则冗余了200份，这极大的增加了数据库的存储压力</p><ul><li><p>离线消息表只存储用户的群离线消息msg_id，降低数据库的冗余存储量</p></li><li><p>加入应用层的ACK，才能保证群消息一定到达，服务端幂等性校验及客户端去重，保证不重复</p></li><li><p>每条群消息都ACK，会给服务器造成巨大的冲击，通过批量ACK减少消息风暴扩散系数的影响</p></li><li><p>群离线消息过多：拉取过慢，可以通过分页懒拉取改善。</p></li></ul><h3 id="3、如何保证消息的时序性"><a href="#3、如何保证消息的时序性" class="headerlink" title="3、如何保证消息的时序性"></a>3、<strong>如何保证消息的时序性</strong></h3><p>方案：</p><ul><li>Id通过借鉴微信号段+跳跃的方式保证趋势递增</li><li>单聊借鉴数据库设计，单点序列化同步到其他节点保证多机时序</li><li>群聊消息使用单点序列化保证各个发送者的消息相对时序</li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8m1ge2ksj30j707gt96.jpg" alt="如何保证IM实时消息的“时序性”与“一致性”？_10.jpg"></p><p>优化：</p><ul><li>利用服务器单点序列化时序，可能出现服务端收到消息的时序，与发出序列不一致</li><li>在A往B发出的消息中，加上发送方A本地的一个绝对时序，来表示接收方B的展现时序。</li><li>群聊消息保证一个群聊落在一个service上然后通过本地递增解决全局递增的瓶颈问题</li></ul><h3 id="4：推拉结合"><a href="#4：推拉结合" class="headerlink" title="4：推拉结合"></a><strong>4：推拉结合</strong></h3><p>历史方案：</p><ul><li>服务器在缓存集群里存储所有用户的在线状态 -&gt; 保证状态可查</li><li>用户状态实时变更，任何用户登录&#x2F;登出时，需要推送所有好友更新状态</li><li>A登录时，先去数据库拉取自己的好友列表，再去缓存获取所有好友的在线状态</li></ul><p><strong>“消息风暴扩散系数”</strong>是指一个消息发出时，变成N个消息的扩散系数，这个系数与业务及数据相关，一定程度上它的大小决定了技术采用推送还是拉取。</p><p>优化方案：</p><ul><li><strong>好友状态推拉结合</strong>，首页置顶亲密、当前群聊，采用推送，否则可以采用轮询拉取的方式同步；</li><li><strong>群友的状态</strong>，由于消息风暴扩散系数过大，可以采用按需拉取，延时拉取的方式同步；</li><li><strong>系统消息&#x2F;开屏广告等</strong>这种实时产生的消息，可以采用推送的方式获取消息；</li></ul><h3 id="5、好友推荐"><a href="#5、好友推荐" class="headerlink" title="5、好友推荐"></a>5、好友推荐</h3><p>Neo4j 图谱数据库</p><h2 id="四、智慧社区"><a href="#四、智慧社区" class="headerlink" title="四、智慧社区"></a>四、智慧社区</h2><p>​18年初，针对我们Dubbo框架的智慧楼宇项目的单体服务显得十分笨重，需要采用微服务的形式进行架构的重新设计，当时，我阅读了<em>Eric Evans</em> 写的《领域驱动设计：软件核心复杂性应对之道》和<em>Martin</em> <em>fowler</em>的《微服务架构：<em>Microservice</em>》两本重量级书籍，书中了解到转型微服务的重要原因之一就是利用<strong>分治的思想</strong>减少系统的复杂性，是一种针对<strong>复杂问题的宏观设计</strong>，来应对系统后来规模越来越大，维护越来越困难的问题。然而，拆分成微服务以后，并<strong>不意味着每个微服务都是各自独立地运行</strong>，而是彼此协作地组织在一起。这就好像一个团队，<strong>规模越大越需要一些方法来组织</strong>，这正是我们需要DDD模型为我们的架构设计提供理论并实践的方法。</p><p>​当时每次版本更新迭代动辄十几个微服务同时修改，有时一个简单的数据库字段变更，也需要同时变更多个微服务，引起了团队的反思：微服务化看上去并没有减少我们的工作量。《企业架构设计》中对于微服务的定义是<strong>小而专</strong>，但在起初的设计时，我们只片面的<strong>理解了小却忽视了专</strong>，此时我们才意识到拆分的关键是要保证微服务内高内聚，微服务间低耦合。</p><h3 id="物联网架构"><a href="#物联网架构" class="headerlink" title="物联网架构"></a><strong>物联网架构</strong></h3><blockquote><p>物联网是互联网的<strong>外延</strong>。将用户端<strong>延伸</strong>和扩展到物与人的连接。物联网模式中，所有<strong>物品与网络连接</strong>，并进行通信和场景联动。互联网通过<strong>电脑、移动终端</strong>等设备将参与者联系起来，形成的一种全新的<strong>信息互换方式</strong></p></blockquote><h4 id="DCM系统架构"><a href="#DCM系统架构" class="headerlink" title="DCM系统架构"></a>DCM系统架构</h4><ul><li><strong>设备感知层</strong>（Device）：利用射频识别、二维码、传感器等技术进行数据采集</li><li><strong>网络传输层</strong>（Connect）：依托通信网络和协议，实现可信的信息交互和共享</li><li><strong>应用控制层</strong>（Manage）：分析和处理海量数据和信息，实现智能化的决策和控制</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jc1stt3j31380lswso.jpg" alt="image-20210504174337327" style="zoom:50%;" /><h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a><strong>三要素</strong></h4><ul><li><strong>设备联网</strong>：通过不同的网络协议和通信标准，实现设备与控制端的连接</li><li><strong>云端分析</strong>：提供监控、存储、分析等数据服务，以及保障客户的业务数据安全</li><li><strong>云边协同</strong>：云端接受设备上报数据，下发设备管控指令</li></ul><h4 id="云-边-端协同"><a href="#云-边-端协同" class="headerlink" title="云 &#x2F; 边 &#x2F; 端协同"></a>云 &#x2F; 边 &#x2F; 端协同</h4><p><strong>云端计算</strong>、<strong>终端计算</strong>和<strong>边缘计算</strong>是一个协同的系统，根据用户场景、资源约束程度、业务实时性等进行动态调 配，形成可靠、低成本的应用方案。从过去几年的发展积累来看，AI 已在物联网多个层面进行融合，比我们合作的海康威视、旷视宇视、商汤科技等纷纷发布了物联网AI相关平台和产品，和移动和小区进行了紧密的融合。</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn9kwux9vjj312w0li138.jpg" alt="image-20210202225351673" style="zoom:50%;" /><h4 id="物联网平台接入"><a href="#物联网平台接入" class="headerlink" title="物联网平台接入"></a>物联网平台接入</h4><img src="https://static-aliyun-doc.oss-accelerate.aliyuncs.com/assets/img/zh-CN/3199158061/p132750.png" alt="企业基于物联网平台的业务链路" style="zoom:50%;" /><p>向下连接海量设备，支撑设备<strong>数据采集上云</strong>；</p><p>向上通过调用<strong>云端API</strong>将指令下发至设备端，实现<strong>远程控制</strong>。</p><p><strong>上行数据链路</strong></p><ul><li>设备建立<strong>MQTT</strong>长连接，上报数据（发布Topic和Payload）到物联网平台</li><li>物联网平台通过<strong>配置</strong>规则，通过<strong>RocketMQ</strong>、<strong>AMQP</strong>等队列转发到业务平台</li></ul><p><strong>下行指令链路</strong></p><ul><li>业务服务器基于<strong>HTTPS</strong>协议调用的API接口，发布Topic指令到物联网平台。</li><li>物联网平台通过<strong>MQTT</strong>协议，使用发布（指定Topic和Payload）到<strong>设备端</strong>。</li></ul><h4 id="门锁接入"><a href="#门锁接入" class="headerlink" title="门锁接入"></a>门锁接入</h4><p><strong>WIFI门锁</strong>：<strong>非保活</strong> 平常处于断电休眠状态，需要<strong>MCU</strong> <strong>唤醒</strong>才能传输和发送数据</p><p><strong>蓝牙门锁</strong>：<strong>MCU串口对接</strong>和<strong>SDK对接</strong>，近距离<strong>单点登录</strong>和远距离<strong>网关登录</strong></p><p><strong>Zigbee门锁</strong>：<strong>非保活</strong> 但是保持心跳，<strong>MCU</strong>对接，<strong>Zigbee协议</strong>控制。</p><p><strong>NB-Iot门锁</strong>：可以通过<strong>公网</strong>连接，把门禁变成<strong>SAAS</strong>服务，<strong>MCU</strong></p><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Software-as-a-Service</strong> ，提供给客户的服务是运营商运行在云计算基础设施上的应用程序。<strong>用户可以在各种设备上通过客户端界面访问应用</strong>，例如计算机浏览器。用户不需要管理或控制任何云计算基础设施，包括网络、服务器、操作系统、存储等资源，一切由 SaaS 提供商管理和运维。</td></tr><tr><td><strong>PaaS</strong></td><td><strong>Platform-as-a-Service</strong>，表示平台即服务理念，客户不需要管理或控制底层的云基础设施，包括网络、服务器、操作系统、存储等，但<strong>客户能控制部署的应用程序</strong>，也可能控制运行应用程序的托管环境配置。</td></tr><tr><td><strong>IaaS</strong></td><td>I<strong>nfrastructure-as-a-Service</strong> ，表示基础设施即服务理念，提供的服务是对所有计算基础设施的利用，包括 CPU、内存、存储、网络等其它计算资源。<strong>用户能够部署和运行任意软件，包括操作系统和应用程序。</strong></td></tr></tbody></table><h4 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h4><p><strong>HTTP协议（CS用户上网）</strong></p><p>HTTP协议是典型的CS通讯模式，由<strong>客户端主动</strong>发起连接，向服务器请求<strong>XML或JSON数据</strong>。该协议最早是为了适用web浏览器的<strong>上网浏览场景</strong>和设计的，目前在<strong>PC、手机、pad</strong>等终端上都应用广泛，但并<strong>不适用于物联网场景</strong></p><ul><li>由于必须由设备主动向服务器发送数据，难以主动向设备推送数据。</li><li>物联网场景中的<strong>设备多样</strong>，运算<strong>受限的设备</strong>，难以实现JSON数据格式的解析</li></ul><p><strong>RESTAPI（松耦合调用）</strong></p><p>REST&#x2F;HTTP主要为了<strong>简化</strong>互联网中的系统架构，<strong>快速实现</strong>客户端和服务器之间交互的<strong>松耦合</strong>，降低了客户端和服务器之间的<strong>交互延迟</strong>。因此适合在物联网的应用层面，通过REST<strong>开放</strong>物联网中资源，实现服务被其他应用所调用。</p><p><strong>CoAP协议（无线传感）</strong></p><blockquote><p>简化了HTTP协议的<strong>RESTful API</strong>，它适用于在<strong>资源受限</strong>的通信的IP网络。</p></blockquote><p><strong>MQTT协议（低带宽）</strong></p><blockquote><p>MQTT协议采用<strong>发布&#x2F;订阅</strong>模式，物联网终端都通过TCP连接到云端，云端通过主题的方式管理各个设备关注的通讯内容，<strong>负责</strong>将设备与设备之间<strong>消息的转发</strong></p></blockquote><p>适用范围：在低带宽、不可靠的集中<strong>星型网络架构</strong>（hub-and-spoke），不适用设备与设备之间通信，设备<strong>控制能力弱</strong>，另外<strong>实时性较差</strong>，一般都在<strong>秒级</strong>。协议要<strong>足够轻量</strong>，方便嵌入式设备去快速地解析和响应。具备<strong>足够的灵活性</strong>，使其足以为 IoT 设备和服务的多样化提供支持。应该设计为<strong>异步消息协议</strong>，这么做是因为大多数 IoT 设备的网络延迟很可能非常不稳定，若使用同步消息协议，IoT 设备需要等待服务器的响应，必须是<strong>双向通信</strong>，服务器和客户端应该可以互相发送消息。</p><p><strong>AMQP协议（互操作性）</strong></p><blockquote><p>用于业务系统例如PLM，ERP，MES等进行数据交换。</p></blockquote><p>　　适用范围：最早应用于金融系统之间的交易消息传递，在物联网应用中，主要适用于移动手持设备与后台数据中心的通信和分析。</p><p><strong>XMPP协议（即时通信）</strong></p><blockquote><p>开源形式组织产生的网络即时通信协议。被IETF国际标准组织完成了标准化工作</p></blockquote><p>　　适用范围：<strong>即时通信</strong>的应用程序，还能用在<strong>协同工具</strong>、游戏等。</p><p>​XMPP在通讯的业务流程上是更适合物联网系统的，开发者不用花太多心思去解决设备通讯时的业务通讯流程，相对开发成本会更低。但是HTTP协议中的安全性以及计算资源消耗的硬伤并没有得到本质的解决。</p><p><strong>JMS （Java消息服务）</strong></p><p>​Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p><strong>Zigbee协议</strong></p><p>​低功耗，它保持IEEE 802.15.4（2003）标准</p><h3 id="IOT流量洪峰"><a href="#IOT流量洪峰" class="headerlink" title="IOT流量洪峰"></a>IOT流量洪峰</h3><p>智慧社区IOT领域，不管是嵌入式芯片还是应用服务器都需要传递消息，常见上行的消息有：<strong>人脸识别开门、烟感雾感告警</strong>、共享充电桩充电，下行的<strong>广告下发、NB门禁开门指令、</strong>超级门板显示等，由于物联网设备时不时会<strong>故障和断网导致大量的流量洪峰</strong>，传统消息队列需要针对性优化。</p><ul><li><p><strong>上下行拆分</strong></p><p>上行消息特征：并发量<strong>高</strong>、可靠性和<strong>时延性要求低</strong></p><p>下行消息特征：并发量<strong>低</strong>、控制指令的<strong>成功率要求高</strong></p></li><li><p><strong>海量Topic下性能</strong></p><p><strong>Kafka</strong>海量Topic性能会<strong>急剧下降</strong>，Zookeeper协调也有瓶颈</p><p><strong>多泳道消息队列</strong>可以实现IoT消息队列的故障<strong>隔离</strong></p></li><li><p><strong>实时消息优先处理</strong></p><p>NB门禁实时产生的开门指令必须<strong>第一优先级处理</strong>，堆积的消息降级</p><p>设计成<strong>无序、不持久化</strong>的，并与传统的FIFO队列隔离</p></li><li><p><strong>连接、计算、存储分离</strong></p><p>Broker只做<strong>流转分发</strong>，实现<strong>无状态</strong>和<strong>水平扩展</strong></p><p>计算交给<strong>Flink</strong>，存储交给nosqlDB，实现<strong>高吞吐写</strong></p></li><li><p><strong>消息策略-推拉结合</strong></p><p>MQTT针对电池类物联网设备，AMQP针对安全性较高的门禁设备</p><p>消费端离线时存到queue，在线时将<strong>实时消息和从queue中拉取的消息</strong>一起推送</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goboitd4h2j30u00ciq3i.jpg" alt="img"></p><p><strong>如果解决海量Topic</strong></p><p>​首先要做的就是分区、分组等水平拆分的方式，接下来考虑单实例如何处理更多Topic，传统消息队列在海量Topic下顺序写会退化成随机写，性能大幅下降</p><ul><li><p><strong>人工Sharding</strong>：部署多个Kafka集群，通过不同mq连接来隔离</p></li><li><p><strong>合并Topic</strong>，客户端封装subTopic。比如一个服务的N个统计项，会消费到无关消息</p><p>​基于这个思路，使用<strong>Kafka Streams</strong>或者<strong>Hbase列</strong>存储来聚合</p></li></ul><p>针对单个Topic海量订阅的问题，<strong>可以在上层封装广播组件来协调批量发送</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobohzda8fj30u00cgaax.jpg" alt="img"></p><h3 id="社区直播带货"><a href="#社区直播带货" class="headerlink" title="社区直播带货"></a>社区直播带货</h3><blockquote><p>使用<strong>端 &#x2F; 边 &#x2F; 云</strong>三级架构，客户端加密传输，边缘节点转发、云侧转码并持久化</p></blockquote><h4 id="产品的背景"><a href="#产品的背景" class="headerlink" title="产品的背景"></a><strong>产品的背景</strong></h4><blockquote><p>上线时间，从调研到正式上线用了 3个月时间，上线后一个月内就要经历双十二挑战。在这么紧的上线时间要求下，需要用到公司提供的所有优势，包括<strong>cdn网络，直播牌照</strong>等</p></blockquote><h4 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h4><ul><li><p>直播数据是<strong>实时</strong>生成的，所有不能够进行<strong>预缓存</strong></p></li><li><p>直播随时会发生，举办热点活动，相关服务器资源需要<strong>动态分配</strong></p></li><li><p>直播的延迟对于用户体验影响很大，需要控制在<strong>秒级</strong></p></li><li><p>直播sdk是内嵌在社区应用里的，整体要求不能超过5M</p></li></ul><h4 id="协议的比较"><a href="#协议的比较" class="headerlink" title="协议的比较"></a>协议的比较</h4><table><thead><tr><th>协议</th><th>上线时间</th><th>网络兼容</th><th>端对端延迟</th><th>应用大小</th><th>问题</th></tr></thead><tbody><tr><td>WebRTC</td><td></td><td>✗</td><td></td><td></td><td>Webrtc 基于 UDP，和社区应用的网络架构不兼容</td></tr><tr><td>HTTP Upload</td><td></td><td></td><td>✗</td><td></td><td>会导致网络高延迟</td></tr><tr><td>Custom Protocol</td><td>✗</td><td></td><td></td><td></td><td>工程师需要实现自己的客户端与服务端的库，无法按时上线</td></tr><tr><td>Proprietary</td><td></td><td></td><td></td><td>✗</td><td>协议就需要几兆的空间，超出额度</td></tr><tr><td>RTMPS</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>TCP实时传输消息协议，更安全更可靠</td></tr></tbody></table><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p><strong>RTMPS</strong>：基于TCP实时传输消息协议，更安全更可靠</p><p><strong>MPEG-DASH</strong>：是一种基于HTTP协议自适应比特率流媒体技术，应对复杂的环境</p><p><img src="https://i.loli.net/2021/01/25/zjwC7B8fdcpDytA.png" alt="image-20210125145103417"></p><ol><li><p>直播端使用 <strong>RTMPS</strong> 协议发送直播数据到<strong>边缘节点</strong>（POP）</p></li><li><p>POP 使用<strong>RTMP</strong>发送数据到数据中心（DC）</p></li><li><p>DC 将数据编码成<strong>不同的清晰度</strong>并进行持久化存储</p><p><strong>云端转码</strong>主要有<strong>两种分辨率</strong>400x400 和 720x720. </p></li><li><p>播放端通过 <strong>MPEG-DASH</strong> &#x2F; RTMPS 协议接收直播数据</p><p>如果用户网络不好**<a href="https://www.cloudflare.com/zh-cn/learning/video/what-is-mpeg-dash/">MPEG-DASH</a>**会自动转换成低分辨率</p></li></ol><h4 id="直播流程"><a href="#直播流程" class="headerlink" title="直播流程"></a><strong>直播流程</strong></h4><img src="https://i.loli.net/2021/01/25/GITnbhDqPdtZY2k.png" alt="image-20210125153606264" style="zoom:50%;" /><ol><li><p>直播端使用 <strong>RTMPS</strong> 协议发送直播流数据到 POP 内的就近的代理服务器</p></li><li><p>代理服务器<strong>转发</strong>直播流数据到数据中心的网关服务器（<strong>443转80</strong>）</p></li><li><p>网关服务器使用<strong>直播 id 的一致性哈希算法</strong>发送直播数据到指定的编码服务器</p></li><li><p>编码服务器有几项职责：</p><ul><li><p>4.1 <strong>验证直播数据</strong>的格式是否正确。</p></li><li><p>4.2 <strong>关联</strong>直播 id 以及编码服务器第一映射，保证客户端即使连接中断或者服务器扩容时，在<strong>重新连接</strong>的时候依然能够连接到相同的编码服务器</p></li><li><p>4.3 使用直播数据<strong>编码成不同解析度</strong>的输出数据</p></li><li><p>4.4 使用 <strong>DASH</strong> 协议输出数据并<strong>持久化</strong>存储</p></li></ul></li></ol><h4 id="播放流程"><a href="#播放流程" class="headerlink" title="播放流程"></a>播放流程</h4><img src="https://i.loli.net/2021/01/25/Lo5N8QYlI2DPjyO.png" alt="image-20210125154758184" style="zoom:50%;" /><ol><li>播放端使用 HTTP <strong>DASH</strong> 协议向 POP 拉取直播数据</li><li>POP 里面的代理服务器会检查数据是否已经在 POP 的<strong>缓存</strong>内。如果是的话，缓存会返回数据给播放端，否则，代理服务器会向 DC 拉取直播数据</li><li>DC 内的代理服务器会检查数据是否在 DC 的缓存内，如果是的话，缓存会返回数据给 POP，并更新 POP 的缓存，再返回给播放端。不是的话，代理服务器会使用一致性哈希算法向对应的编码服务器请求数据，并更新 DC 的缓存，返回到 POP，再返回到播放端。</li></ol><p><strong>收获</strong></p><ol><li>项目的成功不，代码只是内功，考虑适配不同的网络、利用可利用的资源</li><li>惊群效应在热点服务器以及许多组件中都可能发生</li><li>开发大型项目需要对<strong>吞吐量和时延</strong>、<strong>安全和性能</strong>做出妥协</li><li>保证架构的灵活度和可扩展性，为内存、服务器、带宽耗尽做好规划</li></ol><h3 id="直播高可用方案"><a href="#直播高可用方案" class="headerlink" title="直播高可用方案"></a><strong>直播高可用方案</strong></h3><p><strong>网络可靠性</strong>：</p><ul><li>根据<strong>网络连接速度</strong>来自动调整视频质量</li><li>使用<strong>短时间的数据缓存</strong>来解决直播端不稳定，瞬间断线的问题</li><li>根据<strong>网络质量自动降级</strong>为音频直播以及播放</li></ul><p><strong>惊群效应：</strong></p><ul><li>当多个播放端向同一个 POP 请求直播数据的时候，如果数据不在缓存中</li><li>这时候只有一个请求 A 会到 DC 中请求数据，其他请求会等待结果</li><li>但是如果请求 A 超时没有返回数据的话，所有请求会一起向 DC 访问数据</li><li>这时候就会加大 DC 的压力，触发惊群效应</li><li>解决这个问题的方法就是通过<strong>实际的情况</strong>来调整请求超时的时间。这个时间如果太长的话会带来直播的延迟，太短的话会经常触发惊群效应（<strong>每个时间窗口只允许触发一次</strong>，设置允许最大回源数量）</li></ul><h3 id="性能优化方案"><a href="#性能优化方案" class="headerlink" title="性能优化方案"></a><strong>性能优化方案</strong></h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobogaxxjkj304v0e7t93.jpg" alt="img"></p><p><strong>数据库优化：</strong> 数据库是最容易成为瓶颈的组件，考虑从 SQL 优化或者数据库本身去提高它的性能。如果瓶颈依然存在，则会考虑分库分表将数据打散，如果这样也没能解决问题，则可能会选择缓存组件进行优化</p><p><strong>集群最优：</strong>存储节点的问题解决后，计算节点也有可能发生问题。一个集群系统如果获得了水平扩容的能力，就会给下层的优化提供非常大的时间空间，由最初的 3 个节点，扩容到最后的 200 多个节点，但由于人力问题，服务又没有什么新的需求，下层的优化就一直被搁置着。</p><p><strong>硬件升级：</strong>水平扩容不总是有效的，原因在于单节点的计算量比较集中，或者 JVM 对内存的使用超出了宿主机的承载范围。在动手进行代码优化之前，我们会对节点的硬件配置进行升级。</p><p><strong>代码优化</strong>：代码优化是提高性能最有效的方式，但需要收集一些数据，这个过程可能是服务治理，也有可能是代码流程优化。比如JavaAgent 技术，会无侵入的收集一些 profile 信息，供我们进行决策。</p><p><strong>并行优化：</strong>并行优化是针对速度慢的接口进行并行调用。所以我们通常使用 ContDownLatch 对需要获取的数据进行并行处理，效果非常不错，比如在 200ms 内返回对 50 个耗时 100ms 的下层接口的调用。</p><p><strong>JVM 优化</strong>： JVM 发生问题时，优化会获得巨大的性能提升。但在 JVM 不发生问题时，它的优化效果有限。但在代码优化、并行优化、JVM 优化的过程中，JVM 的知识却起到了关键性的作用</p><p><strong>操作系统优化：</strong>操作系统优化是解决问题的杀手锏，比如像 HugePage、SWAP、“CPU 亲和性”这种比较底层的优化。但就计算节点来说，对操作系统进行优化并不是很常见。运维在背后会做一些诸如文件句柄的调整、网络参数的修改，这对于我们来说就已经够用了</p><h3 id="流量回放自动化测试"><a href="#流量回放自动化测试" class="headerlink" title="流量回放自动化测试"></a>流量回放自动化测试</h3><blockquote><p>系统级的重构，测试回归的工作量至少都是以月为单位，对于人力的消耗巨大。一种应对方案是，先不改造，到系统实在扛不住了再想办法。另一种应对方案是，先暂停需求，全力进行改造。但在实际工作场景中，上述应对策略往往很难实现。</p></blockquote><p>场景：</p><p>1、读服务均是查询，它是无状态的。</p><p>2、不管是架构升级还是日常需求，读服务对外接口的出入参格式是没有变化的</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jd95rpij315g0hqn5q.jpg" alt="image-20210504174447049" style="zoom:50%;" /><ul><li><p><strong>日志收集</strong>，主要作用是收集被测系统的真实用户请求，基于一定规则处理后作为系统用例；</p><p>Spring 里的 Interceptor 、Servlet 里的 Filter 过滤器，对所有请求的入参和出参进行记录，并通过 MQ 发送出去。（注意错峰、过滤写、去重等）</p></li><li><p>数据回放是基于收集的用例，对被测系统进行数据回放，发起自动化测试回归；</p><p><strong>离线回放：</strong>只调用新服务，将返回的数据和日志里的出参进行比较，<strong>日志比较大</strong></p><p><strong>实时回放：</strong>去实时调用线上系统和被测系统，并存储实时返回回放的结果信息，<strong>线上有负担</strong></p><p><strong>并行回放：</strong>新版本不即时上线，每次调用老版本接口时概率实时回放新版本接口，<strong>耗时间周期</strong></p></li><li><p><strong>差异对比</strong>，通过差异对比自动发现与预期不一致的用例，进而确定 Bug。</p><p>采用文本对比，可以直观地看到哪个字段数据有差异，从而更快定位到问题。正常情况下，只要存在差异的数据，均可认为是 Bug，是需要进行修复的。</p></li></ul><p><strong>方法论</strong></p><p><strong>Discovery</strong></p><p>​考虑企业战略，分析客户需求，制定产品目标</p><p>​由外到内：竞争对手的方案，为什么做，以后怎么发展，如何去优化。</p><p>​自上而下：基于公司的战略，考虑自身能力和所处环境。</p><p>​自下而上：从资源、历史问题、优先级出发，形成一套可行性实施方法。</p><p><strong>Define</strong></p><p>​基于收集的信息，综合跨业务线的抽象能力和服务，先做什么后做什么，怎么做</p><p>​设计新的架构，重点设计解决痛点问题。</p><p>​拆分业务领域，重点划分工作临界上下文。</p><p><strong>Design</strong></p><p>​详细的业务设计，功能设计，交付计划，考核计划</p><p>​产品愿景，产品形态，相关竞品方案对比，价值、优势、收益</p><p>​梳理业务范围，要知道电商领域四大流（信息流、商流、资金流、物流）</p><p>​MVP最小可用比，让客户和老大看到结果，最后通编写story把故事编圆</p><p><strong>Delivery</strong></p><p>​交付阶段，根据反馈及时调整中台战略，减少损失和增大收益</p><p>​合理制定每个阶段的绩效考核目标：</p><p>​40%稳定+25%业务创新+20%服务接入+15%用户满意度</p><h1 id="七、架构设计"><a href="#七、架构设计" class="headerlink" title="七、架构设计"></a><strong>七、架构设计</strong></h1><h2 id="1、社区系统的架构"><a href="#1、社区系统的架构" class="headerlink" title="1、社区系统的架构"></a>1、社区系统的架构</h2><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmqv8zyhkqj311s0u0q7s.jpg" alt="image-20210117182546782" style="zoom:40%;" /><p><strong>系统拆分</strong></p><p>​通过DDD领域模型，对服务进行拆分，将一个系统拆分为多个子系统，做成SpringCloud的微服务。微服务设计时要尽可能做到少扇出，多扇入，根据服务器的承载，进行客户端负载均衡，通过对核心服务的上游服务进行限流和降级改造。</p><p>​一个服务的代码不要太多，1 万行左右，两三万撑死了吧。</p><p>​大部分的系统，是要进行<strong>多轮拆分</strong>的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成<strong>订单系统、商品系统、采购系统、仓储系统、用户系统</strong>等等吧。</p><p>​但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了<strong>供应商管理系统、采购单管理系统</strong>，订单系统又拆分成了<strong>购物车系统、价格系统、订单管理</strong>系统。</p><p><strong>CDN、Nginx静态缓存、JVM缓存</strong></p><p>​利用Java的模板thymeleaf可以将页面和数据动态渲染好，然后通过Nginx直接返回。动态数据可以从redis中获取。其中redis里的数据由一个缓存服务来进行消费指定的变更服务。</p><p>​商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p><p><strong>缓存</strong></p><p>Redis cluster，10 台机器，5主5从，5 个节点对外提供读写服务，<strong>每个节点的读写高峰 QPS</strong> 可能可以达到每秒 5 万，<strong>5 台机器最多是 25 万读写</strong>请求每秒。</p><p>​<strong>32G 内存+ 8 核 CPU + 1T</strong> 磁盘，但是分配给 <strong>Redis 进程的是 10g 内存</strong>，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p><p>​因为每个主实例都挂了一个从实例，所以是<strong>高可用</strong>的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例<strong>会自动变成主实例</strong>继续提供读写服务。</p><p><strong>MQ</strong></p><p>​可以通过消息队列对微服务系统进行<a href="#1%E3%80%81%E6%8B%86%E5%88%86%E5%BE%AE%E6%9C%8D%E5%8A%A1">解耦</a>，异步调用的更适合微服务的扩展</p><p>​同时可以应对秒杀活动中[应对高并发写请求](# 6、应对高并发的写请求)，比如kafka在毫秒延迟基础上可以实现10w级吞吐量</p><p>​针对<a href="#IOT%E6%B5%81%E9%87%8F%E6%B4%AA%E5%B3%B0">IOT流量洪峰</a>做了一些特殊的优化，保证消息的及时性</p><p>​同时可以使用消息队列保证分布式系统<a href="#7%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7">最终一致性</a></p><p><strong>分库分表</strong></p><p>​分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就 将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个 表，每个表的数据量保持少一点，提高 sql 跑的性能。<strong>在通讯录、订单和商城商品模块超过千万级别都应及时考虑分表分库</strong></p><p><strong>读写分离</strong></p><p>​读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都 集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。 读流量太多的时候，还可以加更多的从库。比如<strong>统计监控类的微服务</strong>通过读写分离，只需访问从库就可以完成统计，例如ES</p><p><strong>ElasticSearch</strong></p><p>​Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的<strong>查询、统计类</strong>的操作，比如<strong>运营平台上</strong>的各地市的汇聚统计，还有一些<strong>全文搜索类</strong>的操作，比如<strong>通讯录和订单</strong>的查询。</p><h2 id="2、商城系统-亿级商品如何存储"><a href="#2、商城系统-亿级商品如何存储" class="headerlink" title="2、商城系统-亿级商品如何存储"></a>2、商城系统-亿级商品如何存储</h2><p>基于 Hash 取模、一致性 Hash 实现分库分表</p><p>高并发读可以通过<a href="5%E3%80%81%E5%BA%94%E5%AF%B9%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%AF%BB%E8%AF%B7%E6%B1%82">多级缓存</a>应对</p><p>大促销热key读的问题通过<a href="**4%E3%80%81%E7%83%ADkey%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F**">redis集群+本地缓存+限流+key加随机值</a>分布在多个实例中</p><p>高并发写的问题通过<strong>基于 Hash 取模、一致性 Hash 实现分库分表</strong>均匀落盘</p><p>业务分配不均导致的<strong>热key</strong>读写问题，可以根据业务场景进行range分片，将热点范围下的子key打散</p><p>具体实现：预先设定主键的生成规则，根据规则进行数据的分片路由，但这种方式会侵入商品各条线主数据的业务规则，更好的方式是基于<strong>分片元数据服务器</strong>（即每次访问分片前先询问分片元服务器在路由到实际分片）不过会带来复杂性，比如保证元数据服务器的<strong>一致性</strong>和可用性。</p><h2 id="3、对账系统-分布式事务一致性"><a href="#3、对账系统-分布式事务一致性" class="headerlink" title="3、对账系统-分布式事务一致性"></a>3、对账系统-分布式事务一致性</h2><blockquote><p>尽量避免分布式事务，单进程用数据库事务，跨进程用消息队列</p></blockquote><p>主流实现分布式系统事务一致性的方案：</p><ol><li><strong>最终一致性</strong>：也就是基于 MQ 的可靠消息投递的机制，</li><li>基于重试加确认的的<strong>最大努力通知方案</strong>。</li></ol><p>理论上也可以使用（2PC两阶段提交、3PC三阶段提交、TCC短事务、SAGA长事务方案），但是这些方案工业上落地代价很大，不适合互联网的业界场景。针对金融支付等需要强一致性的场景可以通过前两种方案实现。（<strong>展开说的话参考分布式事务</strong>）</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruh4oifej30xq0auq7p.jpg" alt="image-20210321212516364"></p><p>本地数据库事务原理：<strong>undo log</strong>（原子性） + <strong>redo log</strong>（持久性） + <strong>数据库锁</strong>（原子性&amp;隔离性） + <strong>MVCC</strong>（隔离性）</p><p>分布式事务原理：<strong>全局事务协调器（原子性）</strong> + 全局锁（隔离性） + <strong>DB本地事务（原子性、持久性）</strong></p><p>一、我们公司账单系统和第三方支付系统对账时，就采用“<strong>自研补偿&#x2F;MQ方案 + 人工介入</strong>”方式</p><p>落地的话：方案最“轻”，性能损失最少。可掌控性好，简单易懂，易维护。<br>考虑到分布式事务问题是小概率事件，留有补救余地就行，性能的损失可是实打实的反应在线上每一个请求上</p><p>二、也了解到业界比如阿里成熟<strong>Seata AT</strong>模式，平均性能会降低35%以上</p><p>我觉得不是特殊的场景不推荐</p><p>三、RocketMQ事务消息</p><p>听起来挺好挺简单的方案，但它比较挑业务场景，同步性强的处理链路不适合。<br>【重要】要求下游MQ消费方一定能成功消费消息。否则转人工介入处理。<br>【重要】千万记得实现幂等性。</p><h2 id="4、用户系统-多线程数据割接"><a href="#4、用户系统-多线程数据割接" class="headerlink" title="4、用户系统-多线程数据割接"></a>4、用户系统-多线程数据割接</h2><p>由于项目需要进行数据割接，保证用户多平台使用用户感知的一致，将广东项目的几百万用户及业务数据按照一定的逻辑灌到社区云平台上，由于依赖了第三方统一认证和省侧crm系统，按照之前系统内割接的方法，通过数据库将用户的唯一标识查出来然后使用多线程向省侧crm系统获取结果。</p><p>但是测试的过程中，发现每个线程请求的数据发生了错乱，导致每个请求处理的数据有重复，于是立即停止了脚本，当时怀疑是多线程对资源并发访问导致的，于是把ArrayList 改成了CopyOnWriteArrayList，但是折腾了一晚上，不管怎么修改，线程之间一直有重复数据，叫了一起加班的同事也没看出问题来，和同事估算了一下不使用多线程，大概30-40个小时能跑完，想了下也能接受，本来已经准备放弃了。</p><p>不过回到家，我还是用多线程仔细单步模拟了下，整个处理的过程，发现在起线程的时候，有些子线程并没有把分配给他的全部id的list处理完，导致最终状态没更新，新线程又去执行了一遍，然后我尝试通过修改在线程外深拷贝一个List再作为参数传入到子线程里，（后续clear的时候也是clear老的List）果然，整个测试过程中再也没出现过重复处理的情况。</p><p>事后，我也深究了下原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arrayBuffer.length == <span class="number">99</span>) &#123;</span><br><span class="line"> <span class="type">val</span> <span class="variable">asList</span> <span class="operator">=</span> arrayBuffer.toList</span><br><span class="line"> exec.execute ( openIdInsertMethod(asList) )</span><br><span class="line"> arrayBuffer.clear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。不过主线程先启动占用了cpu资源，因此主线程总是优于子线程。然而，即使设置了优先级，也无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p><p>所以主线程上的clear操作有可能先执行，那么子线程中未处理完的数据就变成一个空的数组，所以就出现了多个线程出现了重复数据的原因，所以我们要保证的是子线程每次执行完后再进行clear即可。而不是一开始定位的保证ArrayList的安全性。所以将赋值(buffer-&gt;list)操作放在外面去执行后，多线程数据就正常了。</p><h2 id="5、秒杀系统场景设计"><a href="#5、秒杀系统场景设计" class="headerlink" title="5、秒杀系统场景设计"></a>5、秒杀系统场景设计</h2><p>[见秒杀项目方案设计](# 二、秒杀项目)</p><h2 id="6、统计系统-海量计数"><a href="#6、统计系统-海量计数" class="headerlink" title="6、统计系统-海量计数"></a><strong>6、统计系统-海量计数</strong></h2><p><strong>中小规模的计数服务</strong>（万级）</p><p>最常见的计数方案是采用缓存 + DB 的存储方案。当计数变更时，先变更计数 DB，计数加 1，然后再变更计数缓存，修改计数存储的 Memcached 或 Redis。这种方案比较通用且成熟，但在高并发访问场景，支持不够友好。在互联网社交系统中，有些业务的计数变更特别频繁，比如微博 feed 的阅读数，计数的变更次数和访问次数相当，每秒十万到百万级以上的更新量，如果用 DB 存储，会给 DB 带来巨大的压力，DB 就会成为整个计数服务的瓶颈所在。即便采用聚合延迟更新 DB 的方案，由于总量特别大，同时请求均衡分散在大量不同的业务端，巨大的写压力仍然是 DB 的不可承受之重。</p><p><strong>大型互联网场景</strong>（百万级）</p><p>直接把计数全部存储在 Redis 中，通过 hash 分拆的方式，可以大幅提升计数服务在 Redis 集群的写性能，通过主从复制，在 master 后挂载多个从库，利用读写分离，可以大幅提升计数服务在 Redis 集群的读性能。而且 Redis 有持久化机制，不会丢数据</p><p>一方面 Redis 作为通用型存储来存储计数，内存存储效率低。以存储一个 key 为 long 型 id、value 为 4 字节的计数为例，Redis 至少需要 65 个字节左右，不同版本略有差异。但这个计数理论只需要占用 12 个字节即可。内存有效负荷只有 12&#x2F;65&#x3D;18.5%。如果再考虑一个 long 型 id 需要存 4 个不同类型的 4 字节计数，内存有效负荷只有 (8+16)&#x2F;(65*4)&#x3D; 9.2%。</p><p>另一方面，Redis 所有数据均存在内存，单存储历史千亿级记录，单份数据拷贝需要 10T 以上，要考虑核心业务上 1 主 3 从，需要 40T 以上的内存，再考虑多 IDC 部署，轻松占用上百 T 内存。就按单机 100G 内存来算，计数服务就要占用上千台大内存服务器。存储成本太高。</p><p><strong>微博、微信、抖音</strong>（亿级）</p><p>定制数据结构，共享key 紧凑存储，提升计数有效负荷率</p><p>超过阈值后数据保存到SSD硬盘，内存里存索引</p><p>冷key从SSD硬盘中读取后，放入到LRU队列中</p><p>自定义主从复制的方式，海量冷数据异步多线程并发复制</p><h2 id="7、系统设计-微软"><a href="#7、系统设计-微软" class="headerlink" title="7、系统设计 - 微软"></a>7、系统设计 - 微软</h2><h3 id="1、需求收集"><a href="#1、需求收集" class="headerlink" title="1、需求收集"></a><strong>1、需求收集</strong></h3><p>确认<strong>使用的对象</strong>（ToC：高并发，ToB：高可用）</p><p><strong>系统的服务场景</strong>（<strong>即时通信</strong>：低延迟，<strong>游戏</strong>：高性能，<strong>购物</strong>：秒杀-一致性）</p><p><strong>用户量级</strong>（<strong>万级</strong>：双机、<strong>百万</strong>：集群、<strong>亿级</strong>：弹性分布式、容器化编排架构）</p><p><strong>百万读</strong>：3主6从，<strong>每个节点的读写高峰 QPS</strong> 可能可以达到每秒 5 万，可以实现15万，30万读性能</p><p><strong>亿级读</strong>，通过CDN、静态缓存、JVM缓存等多级缓存来提高读并发</p><p><strong>百万写</strong>，通过消息队列削峰填谷，通过hash分拆，水平扩展分布式缓存</p><p><strong>亿级写</strong>，redis可以定制数据结构、SSD+内存LRU、冷数据异步多线程复制</p><p>持久化，（Mysql）承受量约为 1K的QPS，读写分离提升<strong>读并发</strong>，分库分表提升<strong>写并发</strong></p><h3 id="2、顶层设计"><a href="#2、顶层设计" class="headerlink" title="2、顶层设计"></a><strong>2、顶层设计</strong></h3><p>核心功能包括什么：</p><p>写功能：发送微博</p><p>读功能：热点资讯</p><p>交互：点赞、关注</p><h3 id="3、系统核心指标"><a href="#3、系统核心指标" class="headerlink" title="3、系统核心指标"></a><strong>3、系统核心指标</strong></h3><ul><li>系统<strong>性能</strong>和<strong>延迟</strong><ul><li>边缘计算 | 动静分离 | 缓存 |  多线程 |</li></ul></li><li><strong>可扩展性</strong>和<strong>吞吐量</strong><ul><li>负载均衡 | 水平扩展 | 垂直扩展 | 异步 | 批处理 | 读写分离</li></ul></li><li><strong>可用性</strong>和<strong>一致性</strong><ul><li>主从复制 | 哨兵模式 | 集群 | 分布式事务</li></ul></li></ul><h3 id="4、数据存储"><a href="#4、数据存储" class="headerlink" title="4、数据存储"></a>4、数据存储</h3><p>键值存储 : Redis ( 热点资讯 )</p><p>文档存储 : MongoDB ( 微博文档分类)</p><p>分词倒排：Elasticsearch（搜索）</p><p>列型存储：Hbase、BigTable（大数据）</p><p>图形存储：Neo4j （社交及推荐）</p><p>多媒体：FastDfs（图文视频微博）</p><h2 id="7、如何设计一个微博"><a href="#7、如何设计一个微博" class="headerlink" title="7、如何设计一个微博"></a>7、如何设计一个微博</h2><p><strong>实现哪些功能：</strong></p><p>筛选出核心功能（Post a Tweet，Timeline，News Feed，Follow&#x2F;Unfollow a user，Register&#x2F;Login）</p><p><strong>承担多大QPS：</strong></p><p>QPS &#x3D; 100，那么用我的笔记本作Web服务器就好了</p><p>QPS &#x3D; 1K，一台好点的Web 服务器也能应付，需要考虑单点故障；</p><p>QPS &#x3D; 1m，则需要建设一个1000台Web服务器的集群，考虑动态扩容、负载分担、故障转移</p><p>一台 SQL Database （Mysql）承受量约为 1K的QPS；</p><p>一台 NoSQL Database (Redis) 约承受量是 20k 的 QPS；</p><p>一台 NoSQL Database (Memcache) 约承受量是 200k 的 QPS；</p><p><strong>微服务战略拆分</strong></p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruqql81gj30p20c5q45.jpg" alt="img" style="zoom:67%;" /><p><strong>针对不同服务选择不同存储</strong></p><p><img src="https://pic1.zhimg.com/80/v2-13cab4d5f56e3ecb682c351c0eb4a24b_1440w.jpg?source=1940ef5c" alt="img"></p><p><strong>设计数据表的结构</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruu4homyj31400ht405.jpg" alt="img"></p><p>基本差不多就形成了一个解决方案，但是并不是完美的，仍然需要小步快跑的不断的针对<strong>消息队列、缓存、分布式事务、分表分库、大数据、监控、可伸缩</strong>方面进行优化</p><h1 id="八、领域模型落地"><a href="#八、领域模型落地" class="headerlink" title="八、领域模型落地"></a>八、领域模型落地</h1><h3 id="1、拆分微服务"><a href="#1、拆分微服务" class="headerlink" title="1、拆分微服务"></a>1、拆分微服务</h3><blockquote><p>​微服务内高内聚，微服务间低耦合</p></blockquote><p><strong>微服务内高内聚</strong>即单一职责原则</p><p>​每个微服务中的代码变化都是同一类原因。因这类原因而需要变更的代码都在这个微服务中，与其他微服务无关，那么就可以将代码修改的范围缩小到这个微服务内。把这个微服务修改好了，独立修改、独立发布，该需求就实现了。这样，微服务的优势才能发挥出来。</p><p><strong>微服务间低耦合</strong>开放封闭原则</p><p>​就是说在微服务实现自身业务的过程中，如果需要执行的某些过程不是自己的职责，就应当将这些过程交给其他微服务去实现，你只需要对它的接口进行调用。这样，微服务之间的调用就实现了解耦。</p><p>​<strong>领域建模</strong>就是将一个系统划分成了多个子域，每个子域都是一个独立的业务场景，每个子域的边界就是“<strong>限界上下文</strong>”。该业务场景会涉及许多领域对象，但<strong>分析建模</strong>始终需要围绕着业务场景的上下文进行。</p><p>​<strong>领域事件通知机制</strong>最有效的方式就是通过消息队列，实现领域事件在微服务间的通知。</p><blockquote><p>“核心通讯录”微服务只负责发送变更消息到消息队列，不管谁会接收并处理这些消息；</p><p>“门禁管理”微服务只负责接收照片变更消息，不管谁发送的这个消息。</p></blockquote><h3 id="2、关联微服务"><a href="#2、关联微服务" class="headerlink" title="2、关联微服务"></a>2、关联微服务</h3><ol><li><p>按照<strong>限界上下文</strong>进行微服务的拆分，将领域模型<strong>划分到多个问题子域</strong></p></li><li><p>基于<strong>充血模型</strong>与<strong>贫血模型</strong>设计各个微服务的业务领域层（Service、Entity、Value）</p></li><li><p>通过<strong>领域事件通知机制</strong>和<strong>微服务调用</strong>的推拉结合，将各个子域进行解耦关联</p><ul><li><strong>核心</strong>：</li></ul></li></ol><ul><li><p>通讯录 | 短信 | 推送通知 | 支付 | 文件服务</p></li><li><p><strong>智慧通行</strong></p><blockquote><p>解决物业多品牌、多系统应用造成的<strong>信息孤岛</strong>，<strong>数据混乱</strong>的问题</p></blockquote><ul><li>人脸门禁 | 可视对讲 | 电梯梯控 | 停车系统 | 访客预约</li></ul></li><li><p><strong>安全社区</strong></p><blockquote><p>通过<strong>图像视频识别</strong>、<strong>传感数据采集</strong>，实现<strong>报警联动</strong>和<strong>风险预警</strong></p></blockquote><ul><li>视频监控 | 周界报警 | 高空抛物 | 跨域追踪</li></ul></li><li><p><strong>全屋智能</strong></p><blockquote><p>围绕业主需求，逐步引入社区医疗、社区养老、<strong>社区团购</strong>、<strong>社区家政</strong>等服务</p></blockquote><ul><li>超级面板 | 无线门锁 | 烟感雾感</li></ul></li><li><p><strong>增值服务</strong></p><blockquote><p>实现跨品牌的产品体验，支持基于<strong>matrix引擎</strong>的智能生活场景裂变能力</p></blockquote><ul><li>智能充电 | 云广播 | 出入提醒 | 定向投放</li></ul></li></ul><h3 id="3、微服务的落地"><a href="#3、微服务的落地" class="headerlink" title="3、微服务的落地"></a><strong>3、微服务的落地</strong></h3><blockquote><p>​通过合理的微服务设计，尽量让每次的需求变更都交给某个小团队独立完成，让需求变更落到某个微服务上进行变更。唯有这样，每次变更只需独立地修改这个微服务，独立打包、独立升级，新需求独立实现，才能发挥微服务的优势。</p></blockquote><ul><li><p><strong>数据隔离：</strong>数据库中用户信息表的读写只有<strong>通讯录</strong>微服务。当其他微服务需要读写用户信息时，就不能直接读取用户信息表，而是通过 API 接口去调用<strong>通讯录</strong>微服务。</p></li><li><p><strong>接口复用：</strong>因此，当多个团队向你提需求时，必须要对这些接口进行规划，通过复用<strong>尽可能少的接口满足他们的需求；</strong>当有新的接口提出时，要尽量通过现有接口解决问题。</p></li><li><p><strong>向前兼容：</strong>当调用方需要接口变更时怎么办？变更现有接口应当尽可能向前兼容，即接口的名称与参数都不变，只是在内部增加新的功能。<strong>宁愿增加一个新的接口也最好不要去变更原有的接口。</strong></p></li><li><p><strong>本地调用：</strong>在<strong>访客申请</strong>微服务的本地，增加一个<strong>查询用户Service</strong>的 feign 接口。这样，<strong>访客申请Service</strong>就像本地调用一样调用<strong>查询用户Service</strong>，再通过 feign 接口实现远程调用。这种<strong>防腐层</strong>的设计，可以隔离当前微服务以外的其他微服务拆分变更导致的接口的失效的影响。</p></li><li><p><strong>数据库去中心化：</strong></p><ul><li>微服务中<strong>通讯录服务</strong>与<strong>健康码服务</strong>分别对应的<strong>用户库与权限库</strong>，它们的共同特点是数据量小但频繁读取，可以选用小型的 MySQL 数据库并在前面架设 Redis 来提高查询性能；</li><li>微服务中<strong>访客通行</strong>与<strong>生活缴费</strong>分别对应的<strong>通行记录库、订单库</strong>，其特点是数据量大并且高并发写，选用一个数据库显然扛不住这样的压力，因此可以选用了 TiDB 这样的 NewSQL 数据库进行分布式存储，将数据压力分散到多个数据节点中，从而解决 I&#x2F;O 瓶颈；</li><li>微服务中<strong>数据分析</strong>与<strong>通讯录查询</strong>这样的查询分析业务，则选用 <strong>NoSQL 数据库</strong>或<strong>大数据平台</strong>，通过读写分离将生产库上的数据同步过来进行分布式存储，然后宽表一系列的预处理，应对海量历史数据的决策分析与秒级查询。（ NoSQL 为空的字段是不占用空间的，因此字段再多都不影响查询性能）</li></ul></li></ul><h3 id="4、领域模型的意义"><a href="#4、领域模型的意义" class="headerlink" title="4、领域模型的意义"></a>4、领域模型的意义</h3><p>​<strong>贫血模型、充血模型、策略模式、装饰者模式</strong>只是DDD实现的方式，而DDD的真谛是<strong>领域建模</strong>。</p><p>​做事不能仅凭一腔热血，一定要符合自然规律。其实软件的设计开发过程也是这样。对业务理解不深刻全局架构设计往往是过度设计，这时候<strong>应该抓主要流程</strong>，开始领域建模。</p><ul><li>接着，每次添加新功能的时候，一方面要满足当前的需求，另一方面业务相关的<strong>领域建模设计</strong>刚刚满足需求，从而使设计最简化、代码最少。</li><li>这样的设计过程叫<strong>小步快跑</strong>。采用小步快跑的设计方法，一开始不用思考那么多问题，从简单问题开始逐步深入。<strong>领域模型</strong>就像小树一样一点儿一点儿成长，最后完成所有的功能。</li></ul><blockquote><p>保持软件设计不退化的关键在于每次需求变更的设计，只有保证每次需求变更时做出正确的设计，才能保证软件以一种良性循环的方式不断维护下去。</p></blockquote><p>​有没有一种方法，让我们在第十次变更、第二十次变更、第三十次变更时，依然能够找到正确的设计呢？有，那就是<strong>领域驱动设计</strong></p><p>​那么在每次需求变更时，将变更还原到真实世界中，看看真实世界是什么样子的，根据真实世界进行变更。</p><h3 id="5、战略建模"><a href="#5、战略建模" class="headerlink" title="5、战略建模"></a>5、战略建模</h3><p>​<img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jet6kizj310c0ngtp4.jpg" alt="image-20210504174616848" style="zoom:50%;" /></p><h3 id="6、相关名词"><a href="#6、相关名词" class="headerlink" title="6、相关名词"></a><strong>6、相关名词</strong></h3><p><strong>领域和子域（Domain&#x2F;Subdomain）</strong></p><p>​在<strong>上下文地图</strong>构建的领域中，对应模块，使用<strong>限界上下文</strong>划分领域，对应微服务</p><p><strong>限界上下文（Bounded Context）</strong></p><p>​在一个领域&#x2F;子域中，有概念上的领域边界，任何<strong>领域对象</strong>在该边界内部的有不依赖外部的确切含义。</p><p><strong>领域对象</strong></p><p>​服务、实体与值对象是领域驱动设计的领域对象，可以通过<strong>贫血模型</strong>和<strong>充血模型</strong>转换为程序设计</p><p><strong>实体和值对象</strong></p><p>​通过一个<strong>唯一标识字段来区分</strong>真实世界中的每一个个体的领域对象，称为实体。真实世界中那些<strong>一成不变的</strong>、本质性的事物的领域对象，称为值对象。<strong>可变性</strong>是实体的特点，而<strong>不变性</strong>则是值对象的本质。</p><p><strong>贫血模型与充血模型</strong></p><p>​POJO对象中只保存get&#x2F;set方法，没有任何业务逻辑，这样的设计被称为<strong>贫血模型</strong></p><p>​<strong>充血模型</strong>是封装和继承思想的体现，门禁设备实体中，包含特征值下发、广告下发、通行记录回调等方法，不同厂商的实体针对多态进行<strong>聚合</strong>，并通过<strong>工厂或仓库</strong>对外提供服务。在充血模型中， Service 只干一件非常简单的事，就是直接去调用对象中的<strong>工厂方法</strong>生成不同产品，其他的什么都不干。</p><p><strong>聚合</strong></p><p>​聚合体现的是一种<strong>整体与部分</strong>的关系。正是因为有这样的关系，在操作整体的时候，整体就封装了对部分的操作。如何正确理解是否存在聚合的关系：就是当<strong>整体不存在</strong>时，部分就变得<strong>没有了意义</strong>。部分是整体的一个部分，与<strong>整体有相同的生命周期</strong>。</p><p><strong>工厂</strong></p><p><strong>通过装配，创建领域对象，是领域对象生命周期的起点。</strong>譬如，系统要通过 ID 装载一个访客申请：</p><ol><li><p>表单工厂分别调用表单信息DAO、表单明细 DAO 和用户DAO 去进行查询；</p></li><li><p>将得到的表单明细对象、用户对象进行装配，分别 set 到<strong>表单信息对象</strong>的<strong>表单明细</strong>与<strong>用户属性</strong>中；</p></li><li><p>最后，表单工厂将装配好的表单对象返回给表单仓库。</p></li></ol><p><strong>仓库</strong></p><p>​如果服务器是一个非常强大的服务器，那么我们不需要任何数据库。系统创建的所有领域对象都放在仓库中，当需要这些对象时，通过 ID 到仓库中去获取。</p><ul><li><p>当客户程序通过 ID 去获取某个领域对象时，仓库会通过这个 ID 先到<strong>缓存中进行查找</strong>：</p></li><li><p>查找到了，则<strong>直接返回</strong>，不需要查询数据库；</p></li><li><p>没有找到，则通知工厂，工厂调用 DAO 去数据库中查询，然后<strong>装配成领域对象返回给仓库</strong>。</p></li><li><p>仓库在收到这个领域对象以后，在返回给客户程序的同时，将该<strong>对象放到缓存中</strong></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="系统设计" scheme="https://blog.elfred.top/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面试题" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>那些年我们背过的JAVA面试题</title>
    <link href="https://blog.elfred.top/posts/d64d980f.html"/>
    <id>https://blog.elfred.top/posts/d64d980f.html</id>
    <published>2022-05-21T03:24:00.000Z</published>
    <updated>2025-03-08T14:46:55.113Z</updated>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h3><p>​<strong>三次握手过程：</strong></p><p>​客户端——发送带有SYN标志的数据包——服务端       <strong>一次握手</strong>  Client进入syn_sent状态</p><p>​服务端——发送带有SYN&#x2F;ACK标志的数据包——客户端   <strong>二次握手</strong>  服务端进入syn_rcvd</p><p>​客户端——发送带有ACK标志的数据包——服务端               <strong>三次握手</strong>   连接就进入Established状态</p><p>​<strong>为什么三次：</strong></p><p>​主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力</p><p>​<strong>为什么两次不行？</strong></p><p>​1、防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源</p><p>​2、 两次握手只能保证单向连接是畅通的。（为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认）</p><p><strong>TCP四次挥手过程</strong> </p><p><strong>四次挥手过程：</strong></p><p>​客户端——发送带有FIN标志的数据包——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态</p><p>​服务端收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加1，服务端就进入了CLOSE-WAIT状态</p><p>​服务端——发送⼀个FIN数据包——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态</p><p>​客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加1，TIME-WAIT状态</p><p><strong>为什么四次：</strong></p><p>​因为需要确保客户端与服务端的数据能够完成传输。</p><p><strong>CLOSE-WAIT：</strong></p><p>​这种状态的含义其实是表示在等待关闭</p><p><strong>TIME-WAIT：</strong></p><p>​为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接</p><p><strong>如何查看TIME-WAIT状态的链接数量？</strong></p><p>​netstat -an |grep TIME_WAIT|wc -l  查看连接数等待time_wait状态连接数</p><p><strong>为什么会TIME-WAIT过多？解决方法是怎样的？</strong></p><p>​<strong>可能原因：</strong> 高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接</p><p>​<strong>解决：</strong>负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接</p><h4 id="1、OSI与TCP-IP-模型"><a href="#1、OSI与TCP-IP-模型" class="headerlink" title="1、OSI与TCP&#x2F;IP 模型"></a><strong>1、OSI与TCP&#x2F;IP 模型</strong></h4><p>​OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><p>​TCP&#x2F;IP五层：物理层、数据链路层、网络层、传输层、应用层</p><h4 id="2、常见网络服务分层"><a href="#2、常见网络服务分层" class="headerlink" title="2、常见网络服务分层"></a><strong>2、常见网络服务分层</strong></h4><p>​应用层：HTTP、SMTP、DNS、FTP</p><p>​传输层：TCP 、UDP</p><p>​网络层：ICMP 、IP、路由器、防火墙</p><p>​数据链路层：网卡、网桥、交换机</p><p>​物理层：中继器、集线器</p><h4 id="3、TCP与UDP区别及场景"><a href="#3、TCP与UDP区别及场景" class="headerlink" title="3、TCP与UDP区别及场景"></a><strong>3、TCP与UDP区别及场景</strong></h4><table><thead><tr><th>类型</th><th align="center">特点</th><th align="center">性能</th><th align="center">应用过场景</th><th align="center">首部字节</th><th></th></tr></thead><tbody><tr><td>TCP</td><td align="center">面向连接、可靠、字节流</td><td align="center">传输效率慢、所需资源多</td><td align="center">文件、邮件传输</td><td align="center">20-60</td><td></td></tr><tr><td>UDP</td><td align="center">无连接、不可靠、数据报文段</td><td align="center">传输效率快、所需资源少</td><td align="center">语音、视频、直播</td><td align="center">8个字节</td><td></td></tr></tbody></table><p>​<strong>基于TCP的协议：</strong>HTTP、FTP、SMTP</p><p>​<strong>基于UDP的协议：</strong>RIP、DNS、SNMP</p><h4 id="4、TCP滑动窗口，拥塞控制"><a href="#4、TCP滑动窗口，拥塞控制" class="headerlink" title="4、TCP滑动窗口，拥塞控制"></a><strong>4、TCP滑动窗口，拥塞控制</strong></h4><p>​<strong>TCP通过：</strong>应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、超时重传等措施保证数据的可靠传输；</p><p>​<strong>拥塞控制目的：</strong>为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载</p><p>​<strong>拥塞控制过程：</strong>TCP维护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。</p><h4 id="5、TCP粘包原因和解决方法"><a href="#5、TCP粘包原因和解决方法" class="headerlink" title="5、TCP粘包原因和解决方法"></a><strong>5、TCP粘包原因和解决方法</strong></h4><p>​<strong>TCP粘包是指</strong>：发送方发送的若干包数据到接收方接收时粘成一包</p><p>​<strong>发送方原因：</strong></p><p>​TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量）：</p><p>​收集多个小分组，在一个确认到来时一起发送、导致发送方可能会出现粘包问题</p><p>​<strong>接收方原因：</strong></p><p>​TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p><p>​<strong>解决粘包问题：</strong></p><p>​最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：</p><ul><li><p>发送定长包。每个消息的大小都是一样的，接收方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</p></li><li><p>包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。</p></li><li><p>包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。</p></li></ul><h4 id="6、TCP、UDP报文格式"><a href="#6、TCP、UDP报文格式" class="headerlink" title="6、TCP、UDP报文格式"></a><strong>6、TCP、UDP报文格式</strong></h4><p>​<strong>TCP报文格式：</strong></p><p>​<img src="https://farm1.staticflickr.com/792/27194088468_4cb0141fc8_b.jpg" style="zoom: 67%;" /></p><p>​<strong>源端口号和目的端口号</strong>：</p><p>​用于寻找发端和收端应用进程。这两个值加上ip首部源端ip地址和目的端ip地址唯一确定一个tcp连接。</p><p>​<strong>序号字段：</strong></p><p>​序号用来标识从T C P发端向T C P收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 T C P用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达 2^32-1后又从0开始。</p><p>　　当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号</p><p>​<strong>确认序号</strong>：</p><p>​既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有ACK标志为 1时确认序号字段才有效。发送ACK无需任何代价，因为 32 bit的确认序号字段和A C K标志一样，总是T C P首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK标志也总是被设置为1。TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p><p>​<strong>首都长度</strong>：</p><p>​首部长度给出首部中 32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此T C P最多有6 0字节的首部。然而，没有任选字段，正常的长度是 2 0字节。</p><p>​<strong>标志字段</strong>：在T C P首部中有 6个标志比特。它们中的多个可同时被设置为1.<br>　　URG紧急指针（u rgent pointer）有效<br>　　ACK确认序号有效。<br>　　PSH接收方应该尽快将这个报文段交给应用层。<br>　　RST重建连接。<br>　　SYN同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8章介绍。<br>　　FIN发端完成发送任务。</p><p>​<strong>窗口大小</strong>：</p><p>​T C P的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个 16 bit字段，因而窗口大小最大为 65535字节。</p><p>​<strong>检验和：</strong></p><p>​检验和覆盖了整个的 T C P报文段：T C P首部和T C P数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</p><p>​<strong>紧急指针</strong>：</p><p>​只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 T C P的紧急方式是发送端向另一端发送紧急数据的一种方式。</p><p>​<strong>选项</strong>：</p><p>​最常见的可选字段是最长报文大小，又称为 MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 S Y N标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。</p><p>​<strong>UDP报文格式：</strong></p><p>​<img src="https://appwk.baidu.com/naapi/doc/view?ih=482&o=png_6_0_0_176_917_504_247_892.979_1262.879&iw=986&ix=0&iy=0&aimw=986&rn=1&doc_id=182d935c3186bceb18e8bb77&pn=1&sign=b88bda03b9954e506622f97b8b2ae438&type=1&app_ver=2.9.8.2&ua=bd_800_800_IncredibleS_2.9.8.2_2.3.7&bid=1&app_ua=IncredibleS&uid=&cuid=&fr=3&Bdi_bear=WIFI&from=3_10000&bduss=&pid=1&screen=800_800&sys_ver=2.3.7" style="zoom:50%;" /></p><p>​<strong>端口号</strong>：</p><p>​用来表示发送和接受进程。由于 I P层已经把I P数据报分配给T C P或U D P（根据I P首部中协议字段值），因此T C P端口号由T C P来查看，而 U D P端口号由UDP来查看。T C P端口号与UDP端口号是相互独立的。</p><p>​<strong>长度</strong>：</p><p>​UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为 8字节（发送一份0字节的UDP数据报是 O K）。</p><p>​<strong>检验和</strong>：</p><p>​UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。</p><p>​<strong>IP报文格式：</strong>普通的IP首部长为20个字节，除非含有可选项字段。</p><p>​<img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1614312792,1954581760&fm=26&gp=0.jpg" style="zoom:67%;" /></p><p>​<strong>4位版本</strong>：</p><p>​目前协议版本号是4，因此IP有时也称作IPV4.</p><p>​<strong>4位首部长度</strong>：</p><p>​首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。</p><p>​<strong>服务类型（TOS）</strong>：</p><p>​服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。</p><p>​<strong>总长度</strong>：</p><p>​总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。</p><p>​<strong>标识字段</strong>：</p><p>​标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</p><p>​<strong>生存时间</strong>：</p><p>​TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机。</p><p>​<strong>首部检验和</strong>：</p><p>​首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p><p>​<strong>以太网报文格式：</strong></p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2733576797,55677727&fm=26&gp=0.jpg"></p><p>​<strong>目的地址和源地址：</strong></p><p>​是指网卡的硬件地址（也叫MAC 地址），长度是48 位，是在网卡出厂时固化的。</p><p>​<strong>数据：</strong></p><p>​以太网帧中的数据长度规定最小46 字节，最大1500 字节，ARP 和RARP 数据包的长度不够46 字节，要在后面补填充位。最大值1500 称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的MTU了，则需要对数据包进行分片fragmentation）。ifconfig 命令的输出中也有“MTU:1500”。注意，MTU 个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h3><h4 id="1、HTTP协议1-0-1-1-2-0"><a href="#1、HTTP协议1-0-1-1-2-0" class="headerlink" title="1、HTTP协议1.0_1.1_2.0"></a>1、HTTP协议1.0_1.1_2.0</h4><p>​<strong>HTTP1.0：</strong>服务器处理完成后立即断开TCP连接（<strong>无连接</strong>），服务器不跟踪每个客户端也不记录过去的请求（<strong>无状态</strong>）</p><p>​<strong>HTTP1.1：</strong>KeepAlived<strong>长连接</strong>避免了连接建立和释放的开销；通过Content-Length来判断当前请求数据是否已经全部接受（<strong>有状态</strong>）</p><p>​<strong>HTTP2.0：</strong>引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以<strong>并行</strong>的传输数据。</p><p>​<strong>http1.0和http1.1的主要区别如下：</strong><br>​1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）<br>​2、网络连接的优化：1.1支持断点续传<br>​3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态<br>​4、Host头处理：支持Host头域，不在以IP为请求方标志<br>​5、长连接：减少了建立和关闭连接的消耗和延迟。</p><p>​<strong>http1.1和http2.0的主要区别：</strong><br>​1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式<br>​2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成正常的请求）<br>​3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的hearder大小<br>​4、服务端推送：同google的SPDUY（1.0的一种升级）一样</p><h4 id="2、HTTP与HTTPS之间的区别"><a href="#2、HTTP与HTTPS之间的区别" class="headerlink" title="2、HTTP与HTTPS之间的区别"></a>2、HTTP与HTTPS之间的区别</h4><p>​<strong>HTTP与HTTPS之间的区别：</strong></p><table><thead><tr><th align="center">HTTP</th><th align="center">HTTPS</th></tr></thead><tbody><tr><td align="center">默认端口80</td><td align="center">HTTPS默认使用端口443</td></tr><tr><td align="center">明文传输、数据未加密、安全性差</td><td align="center">传输过程ssl加密、安全性较好</td></tr><tr><td align="center">响应速度快、消耗资源少</td><td align="center">响应速度较慢、消耗资源多、需要用到CA证书</td></tr></tbody></table><p>​<strong>HTTPS链接建立的过程：</strong></p><p>​1.首先客户端先给服务器发送一个请求</p><p>​2.服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥</p><p>​3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密</p><p>​4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端</p><p>​5.随后客户端和服务端就使用对称密钥进行信息传输</p><p>​<strong>对称加密算法：</strong></p><p>​双方持有相同的密钥，且加密速度快，典型对称加密算法：DES、AES</p><p>​<strong>非对称加密算法：</strong></p><p>​密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA</p><h4 id="3、Get和Post请求区别"><a href="#3、Get和Post请求区别" class="headerlink" title="3、Get和Post请求区别"></a><strong>3、Get和Post请求区别</strong></h4><p><strong>HTTP请求：</strong></p><table><thead><tr><th align="left">方法</th><th>描述</th></tr></thead><tbody><tr><td align="left">GET</td><td>向特定资源发送请求，查询数据，并返回实体</td></tr><tr><td align="left">POST</td><td>向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改</td></tr><tr><td align="left">PUT</td><td>向服务器上传新的内容</td></tr><tr><td align="left">HEAD</td><td>类似GET请求，返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">DELETE</td><td>请求服务器删除指定标识的资源</td></tr><tr><td align="left">OPTIONS</td><td>可以用来向服务器发送请求来测试服务器的功能性</td></tr><tr><td align="left">TRACE</td><td>回显服务器收到的请求，用于测试或诊断</td></tr><tr><td align="left">CONNECT</td><td>HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table><p><strong>get和Post区别：</strong></p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>可见性</td><td>数据在URL中对所有人可见</td><td>数据不会显示在URL中</td></tr><tr><td>安全性</td><td>与post相比，get的安全性较差，因为所<br/>发送的数据是URL的一部分</td><td>安全，因为参数不会被保存在浏览器<br/>历史或web服务器日志中</td></tr><tr><td>数据长度</td><td>受限制，最长2kb</td><td>无限制</td></tr><tr><td>编码类型</td><td>application&#x2F;x-www-form-urlencoded</td><td>multipart&#x2F;form-data</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能被缓存</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="4、HTTP常见响应状态码"><a href="#4、HTTP常见响应状态码" class="headerlink" title="4、HTTP常见响应状态码"></a><strong>4、HTTP常见响应状态码</strong></h4><p>​100：Continue — 继续。客户端应继续其请求。</p><p>​200：OK — 请求成功。一般用于GET与POST请求。</p><p>​301：Moved Permanently — 永久重定向。</p><p>​302：Found — 暂时重定向。</p><p>​400：Bad Request — 客户端请求的语法错误，服务器无法理解。</p><p>​403：Forbideen — 服务器理解请求客户端的请求，但是拒绝执行此请求。</p><p>​404：Not Found — 服务器无法根据客户端的请求找到资源（网页）。</p><p>​500：Internal Server Error — 服务器内部错误，无法完成请求。</p><p>​502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</p><h4 id="5、重定向和转发区别"><a href="#5、重定向和转发区别" class="headerlink" title="5、重定向和转发区别"></a><strong>5、重定向和转发区别</strong></h4><p>​<strong>重定向：redirect：</strong></p><p>​地址栏发生变化</p><p>​重定向可以访问其他站点（服务器）的资源</p><p>​重定向是两次请求。不能使用request对象来共享数据</p><p>​<strong>转发：forward：</strong></p><p>​转发地址栏路径不变</p><p>​转发只能访问当前服务器下的资源</p><p>​转发是一次请求，可以使用request对象共享数据</p><h4 id="6、Cookie和Session区别。"><a href="#6、Cookie和Session区别。" class="headerlink" title="6、Cookie和Session区别。"></a><strong>6、Cookie和Session区别。</strong></h4><p>​Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但两者有所区别：</p><p>​Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>​cookie不是很安全，别人可以分析存放在本地的COOKIE并进行欺骗,考虑到安全应当使用session。</p><p>​Cookie ⼀般⽤来保存⽤户信息，Session 的主要作⽤就是通过服务端记录⽤户的状态</p><h3 id="浏览器输入URL过程"><a href="#浏览器输入URL过程" class="headerlink" title="浏览器输入URL过程"></a><strong>浏览器输入URL过程</strong></h3><p>​<strong>过程：</strong>DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束</p><table><thead><tr><th>过程</th><th>使用的协议</th></tr></thead><tbody><tr><td>1、浏览器查找域名DNS的IP地址<br />DNS查找过程（浏览器缓存、路由器缓存、DNS缓存）</td><td>DNS：获取域名对应的ip</td></tr><tr><td>2、根据ip建立TCP连接</td><td>TCP：与服务器建立连接</td></tr><tr><td>3、浏览器向服务器发送HTTP请求</td><td>HTTP：发送请求</td></tr><tr><td>4、服务器响应HTTP响应</td><td>HTTP</td></tr><tr><td>5、浏览器进行渲染</td><td></td></tr></tbody></table><h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a><strong>操作系统基础</strong></h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a><strong>进程和线程的区别</strong></h3><p>​<strong>进程：</strong>是资源分配的最小单位，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，不共享栈、程序计数器</p><p>​<strong>线程：</strong>是任务调度和执行的最小单位，线程并行执行存在资源竞争和上下文切换的问题</p><p>​<strong>协程：</strong>是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p><h4 id="1、进程间通信方式IPC"><a href="#1、进程间通信方式IPC" class="headerlink" title="1、进程间通信方式IPC"></a><strong>1、进程间通信方式IPC</strong></h4><p><strong>管道pipe：</strong></p><p>​亲缘关系使用匿名管道，非亲缘关系使用命名管道，管道遵循FIFO，半双工，数据只能单向通信；</p><p><strong>信号：</strong></p><p>​信号是一种比较复杂的通信方式，用户调用kill命令将信号发送给其他进程。</p><p><strong>消息队列：</strong></p><p>​消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。</p><p><strong>共享内存(share memory)：</strong></p><ul><li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li></ul><p><strong>信号量(Semaphores) ：</strong></p><p>​信号量是⼀个计数器，⽤于多进程对共享数据的访问，这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</p><p><strong>套接字(Sockets) :</strong> </p><p>​简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</p><h4 id="2、用户态和核心态"><a href="#2、用户态和核心态" class="headerlink" title="2、用户态和核心态"></a><strong>2、用户态和核心态</strong></h4><p><strong>用户态：</strong>只能受限的访问内存，运行所有的应用程序</p><p><strong>核心态：</strong>运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备</p><p><strong>为什么要有用户态和内核态：</strong></p><p>​由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络</p><p><strong>用户态切换到内核态的3种方式：</strong></p><p>​<strong>a. 系统调用</strong></p><p>​主动调用，系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p><p>​<strong>b. 异常</strong></p><p>​当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，比如缺页异常，这时会触发切换内核态处理异常。</p><p>​<strong>c. 外围设备的中断</strong></p><p>​当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会由用户态到内核态的切换。</p><h4 id="3、操作系统的进程空间"><a href="#3、操作系统的进程空间" class="headerlink" title="3、操作系统的进程空间"></a><strong>3、操作系统的进程空间</strong></h4><p>​栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。</p><p>​堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。</p><p>​静态区（static）—存放全局变量和静态变量的存储</p><p>​代码区(text)—存放函数体的二进制代码。</p><p>​<strong>线程共享堆区、静态区</strong></p><h3 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h3><p><strong>存管理方式：</strong>页式管理、段式管理、段页式管理</p><p><strong>分段管理：</strong></p><p>​将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p><p><strong>分页管理：</strong></p><p>​在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）</p><p><strong>段页式管理：</strong></p><p>​段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的</p><h4 id="1、页面置换算法FIFO、LRU"><a href="#1、页面置换算法FIFO、LRU" class="headerlink" title="1、页面置换算法FIFO、LRU"></a><strong>1、页面置换算法FIFO、LRU</strong></h4><p><strong>置换算法：</strong>先进先出FIFO、最近最久未使用LRU、最佳置换算法OPT</p><p><strong>先进先出FIFO:</strong></p><p>​缺点：没有考虑到实际的页面使用频率，性能差、与通常页面使用的规则不符合，实际应用较少</p><p><strong>最近最久未使用LRU:</strong></p><p>​原理：选择最近且最久未使用的页面进行淘汰</p><p>​优点：考虑到了程序访问的时间局部性，有较好的性能，实际应用也比较多</p><p>​缺点：没有合适的算法，只有适合的算法，lFU、random都可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: LRU最近最久未使用置换算法，通过LinkedHashMap实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Li</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-17 10:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer,Integer&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;   <span class="comment">//容量大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *初始化构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(capacity);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//缓存中不存在此key，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        cache.remove(key);   <span class="comment">//先从链表中删除</span></span><br><span class="line">        cache.put(key,res);  <span class="comment">//再把该节点放到链表末尾处</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(key); <span class="comment">//已经存在，在当前链表移除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(capacity == cache.size()) &#123;</span><br><span class="line">            <span class="comment">//cache已满，删除链表头位置</span></span><br><span class="line">            Set&lt;Integer&gt; keySet = cache.keySet();</span><br><span class="line">            Iterator&lt;Integer&gt; iterator = keySet.iterator();</span><br><span class="line">            cache.remove(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key,value);  <span class="comment">//插入到链表末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: LRU最近最久未使用置换算法，通过LinkedHashMap内部removeEldestEntry方法实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Li</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-17 10:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *初始化构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Integer, Integer&gt;(capacity, <span class="number">0.75f</span>, <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; capacity;  <span class="comment">// 容量大于capacity 时就删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//返回key对应的value值，若不存在，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最佳置换算法OPT:</strong></p><p>​原理：每次选择当前物理块中的页面在未来长时间不被访问的或未来不再使用的页面进行淘汰</p><p>​优点：具有较好的性能，可以保证获得最低的缺页率</p><p>​缺点：过于理想化，但是实际上无法实现（没办法预知未来的页面）</p><h4 id="2、死锁条件、解决方式。"><a href="#2、死锁条件、解决方式。" class="headerlink" title="2、死锁条件、解决方式。"></a><strong>2、死锁条件、解决方式。</strong></h4><p>​死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象；</p><p>​<strong>死锁的条件：</strong></p><p>​互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源；</p><p>​请求与保持条件：进程获得一定的资源后，又对其他资源发出请求，阻塞过程中不会释放自己已经占有的资源</p><p>​非剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p><p>​循环等待条件：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源</p><p>​<strong>解决方法：</strong>破坏死锁的任意一条件</p><p>​乐观锁，破坏资源互斥条件，<strong>CAS</strong></p><p>​资源一次性分配，从而剥夺请求和保持条件、<strong>tryLock</strong></p><p>​可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，<strong>数据库deadlock超时</strong></p><p>​资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，<strong>转账场景</strong></p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a><strong>Java基础</strong></h2><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>特性：</strong>封装、继承、多态</p><p>​<strong>封装：</strong>对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法；</p><p>​<strong>继承</strong>：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；</p><p>​<strong>多态：</strong>通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝）</p><h4 id="1、Java与C-区别"><a href="#1、Java与C-区别" class="headerlink" title="1、Java与C++区别"></a><strong>1、Java与C++区别</strong></h4><p>​不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存</p><h4 id="2、多态实现原理"><a href="#2、多态实现原理" class="headerlink" title="2、多态实现原理"></a><strong>2、多态实现原理</strong></h4><p>多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。</p><p><strong>静态绑定与动态绑定：</strong></p><p>​一种是在编译期确定，被称为静态分派，比如方法的重载；</p><p>​    一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）和接口的实现。</p><p><strong>多态的实现</strong></p><p>​虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p><h4 id="3、static和final关键字"><a href="#3、static和final关键字" class="headerlink" title="3、static和final关键字"></a>3、static和final关键字</h4><p><strong>static：</strong>可以修饰属性、方法</p><p>​<strong>static修饰属性：</strong></p><p>​类级别属性，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。</p><p>​<strong>static修饰方法：</strong></p><p>​随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用this；</p><p><strong>final：</strong>关键字主要⽤在三个地⽅：变量、⽅法、类。</p><p>​<strong>final修饰变量：</strong></p><p>​如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；</p><p>​如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。</p><p>​<strong>final修饰方法：</strong></p><p>​把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。</p><p>​<strong>final修饰类：</strong></p><p>​ final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。</p><p>一个类不能被继承，除了final关键字之外，还有可以私有化构造器。（内部类无效）</p><h4 id="4、抽象类和接口"><a href="#4、抽象类和接口" class="headerlink" title="4、抽象类和接口"></a>4、抽象类和接口</h4><p><strong>抽象类：</strong>包含抽象方法的类，即使用abstract修饰的类；抽象类只能被继承，所以不能使用final修饰，抽象类不能被实例化，</p><p><strong>接口：</strong>接口是一个抽象类型，是抽象方法的集合，接口支持多继承，接口中定义的方法，默认是public abstract修饰的抽象方法</p><p><strong>相同点：</strong></p><p>​① 抽象类和接口都不能被实例化</p><p>​② 抽象类和接口都可以定义抽象方法，子类&#x2F;实现类必须覆写这些抽象方法</p><p><strong>不同点：</strong></p><p>​① 抽象类有构造方法，接口没有构造方法</p><p>​③抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8之后可以）</p><p>​③ 抽象类只能单继承，接口可以多继承</p><p>​④ 抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量</p><p><strong>抽象类的使用场景：</strong></p><p>​既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量</p><p><strong>接口的应用场景：</strong></p><p>​约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类中各个功能之间可能没有任何联系</p><h4 id="5、泛型以及泛型擦除"><a href="#5、泛型以及泛型擦除" class="headerlink" title="5、泛型以及泛型擦除"></a>5、泛型以及泛型擦除</h4><p>参考：<a href="https://blog.csdn.net/baoyinwang/article/details/107341997">https://blog.csdn.net/baoyinwang/article/details/107341997</a></p><p><strong>泛型：</strong></p><p>​泛型的本质是参数化类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p><p><strong>泛型擦除：</strong></p><p>​Java的泛型是伪泛型，使用泛型的时候加上类型参数，在编译器编译生成的字节码的时候会去掉，这个过程成为类型擦除。</p><p>​如List<String>等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</p><p>可以通过反射添加其它类型元素</p><h4 id="6、反射原理以及使用场景"><a href="#6、反射原理以及使用场景" class="headerlink" title="6、反射原理以及使用场景"></a><strong>6、反射原理以及使用场景</strong></h4><p><strong>Java反射：</strong></p><p>​是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；</p><p><strong>反射原理：</strong></p><p>​反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类</p><p>​<strong>如何得到Class的实例:</strong></p><pre><code>     1.类名.class(就是一份字节码)     2.Class.forName(String className);根据一个类的全限定名来构建Class对象     3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型</code></pre><p><strong>使用场景：</strong></p><ul><li><p><strong>开发通用框架 -</strong> 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，需要根据配置文件运行时动态加载不同的对象或类，调用不同的方法。</p></li><li><p><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</p><p>JDK：spring默认动态代理，需要实现接口</p><p>CGLIB：通过asm框架序列化字节流，可配置，性能差</p></li><li><p><strong>自定义注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。</p></li></ul><h4 id="7、Java异常体系"><a href="#7、Java异常体系" class="headerlink" title="7、Java异常体系"></a><strong>7、Java异常体系</strong></h4><p>​<img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3137389296,1222888772&fm=26&gp=0.jpg" style="zoom:67%;" /></p><p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</p><p><strong>Error ：</strong></p><p>​是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p><p><strong>Exception 包含：RuntimeException 、CheckedException</strong></p><p>编程错误可以分成三类：语法错误、逻辑错误和运行错误。</p><p><strong>语法错误</strong>（也称编译错误）是在编译过程中出现的错误，由编译器检查发现语法错误</p><p><strong>逻辑错误</strong>指程序的执行结果与预期不符，可以通过调试定位并发现错误的原因</p><p><strong>运行错误</strong>是引起程序非正常终端的错误，需要通过异常处理的方式处理运行错误</p><p><strong>RuntimeException：</strong> 运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>​ 如 NullPointerException 、 ClassCastException ； </p><p><strong>CheckedException：</strong>受检异常，程序使用trycatch进行捕捉处理</p><p>​如IOException、SQLException、NotFoundException；</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goe17hajvzj316d0lhju3.jpg" alt="JavaCollection"></p><h4 id="1、ArrayList和LinkedList"><a href="#1、ArrayList和LinkedList" class="headerlink" title="1、ArrayList和LinkedList"></a><strong>1、ArrayList和LinkedList</strong></h4><p><strong>ArrayList：</strong></p><p>​底层基于数组实现，支持对元素进行快速随机访问，适合随机查找和遍历，不适合插入和删除。（提一句实际上）<br>​默认初始大小为10，当数组容量不够时，会触发扩容机制（扩大到当前的1.5倍），需要将原来数组的数据复制到新的数组中；当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。</p><p><strong>LinkedList：</strong></p><p>​底层基于双向链表实现，适合数据的动态插入和删除；<br>​内部提供了 List 接口中没有定义的方法，用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。（比如jdk官方推荐使用基于linkedList的Deque进行堆栈操作）</p><p><strong>ArrayList与LinkedList区别：</strong></p><p>​都是线程不安全的，ArrayList 适用于查找的场景，LinkedList 适用于增加、删除多的场景</p><p><strong>实现线程安全：</strong></p><p>​可以使用原生的Vector，或者是Collections.synchronizedList(List list)函数返回一个线程安全的ArrayList集合。<br>​建议使用concurrent并发包下的<strong>CopyOnWriteArrayList</strong>的。</p><p>​①<strong>Vector:</strong> 底层通过synchronize修饰保证线程安全，效率较差</p><p>​②<strong>CopyOnWriteArrayList：</strong>写时加锁，使用了一种叫<strong>写时复制</strong>的方法；读操作是可以不用加锁的</p><p>​</p><h4 id="2、List遍历快速和安全失败"><a href="#2、List遍历快速和安全失败" class="headerlink" title="2、List遍历快速和安全失败"></a><strong>2、List遍历快速和安全失败</strong></h4><p><strong>①普通for循环遍历List删除指定元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(list.get(i) == <span class="number">5</span>) </span><br><span class="line">       list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② 迭代遍历,用list.remove(i)方法删除元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">5</span>)&#123;</span><br><span class="line">        list.remove(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③foreach遍历List删除元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i:list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>) list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fail—fast：</strong>快速失败</p><p>​当异常产生时，直接抛出异常，程序终止;</p><p>​fail-fast主要是体现在当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。</p><p><strong>fail—safe：</strong>安全失败</p><p>    采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p><p>    缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>    场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h4 id="3、详细介绍HashMap"><a href="#3、详细介绍HashMap" class="headerlink" title="3、详细介绍HashMap"></a><strong>3、详细介绍HashMap</strong></h4><p>角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N，JDK1.7与1.8的区别。</p><p>参考：<a href="https://www.jianshu.com/p/9fe4cb316c05">https://www.jianshu.com/p/9fe4cb316c05</a></p><p><strong>数据结构：</strong></p><p>​HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据</p><p><strong>扩容情况：</strong></p><p>​默认的负载因子是0.75，如果数组中已经存储的元素个数大于数组长度的75%，将会引发扩容操作。</p><p>​【1】创建一个长度为原来数组长度<strong>两倍的新数组</strong>。</p><p>​【2】1.7采用Entry的重新hash运算，1.8采用高于与运算。</p><p><strong>put操作步骤：</strong></p><p>​<img src="https://s0.lgstatic.com/i/image3/M01/73/D9/CgpOIF5rDYmATP43AAB3coc0R64799.png" alt="img" style="zoom:67%;" /></p><p>​1、判断数组是否为空，为空进行初始化;</p><p>​2、不为空，则计算 key 的 hash 值，通过(n - 1) &amp; hash计算应当存放在数组中的下标 index;</p><p>​3、查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</p><p>​4、存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据；</p><p>​5、若不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；</p><p>​6、若不是红黑树，创建普通Node加入链表中；判断链表长度是否大于 8，大于则将链表转换为红黑树；</p><p>​7、插入完成之后判断当前节点数是否大于阈值，若大于，则扩容为原数组的二倍</p><p><strong>哈希函数：</strong></p><p>​ 通过hash函数（优质因子31循环累加）先拿到 key 的hashcode，是一个32位的值，然后让hashcode的高16位和低16位进行<strong>异或</strong>操作。该函数也称为扰动函数，做到尽可能降低hash碰撞，通过尾插法进行插入。</p><p><strong>容量为什么始终都是2^N：</strong></p><p>​先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“  (n - 1) &amp; hash ”。（n代表数组⻓度）。方便数组的扩容和增删改时的取模。</p><p><strong>JDK1.7与1.8的区别：</strong></p><p><strong>JDK1.7 HashMap：</strong></p><p>​底层是 <strong>数组和链表</strong> 结合在⼀起使⽤也就是链表散列。如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。扩容翻转时顺序不一致使用头插法会产生死循环，导致cpu100%</p><p><strong>JDK1.8 HashMap：</strong></p><p>​底层数据结构上采用了<strong>数组＋链表＋红黑树</strong>；当链表⻓度⼤于阈值（默认为 8-泊松分布），数组的⻓度大于 64时，链表将转化为红⿊树，以减少搜索时间。（解决了tomcat臭名昭著的url参数dos攻击问题）</p><h4 id="4、ConcurrentHashMap"><a href="#4、ConcurrentHashMap" class="headerlink" title="**4、ConcurrentHashMap **"></a>**4、ConcurrentHashMap **</h4><p>​可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；Hashtable 是原始API类，通过synchronize同步修饰，效率低下；ConcurrentHashMap 通过分段锁实现，效率较比Hashtable要好；</p><p><strong>ConcurrentHashMap的底层实现：</strong></p><p>​<strong>JDK1.7的 ConcurrentHashMap</strong> 底层采⽤ 分段的数组+链表 实现；采用 <strong>分段锁</strong>（Sagment） 对整个桶数组进⾏了分割分段(Segment默认16个)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1035283471,1167301443&fm=26&gp=0.jpg"></p><p>​<strong>JDK1.8的 ConcurrentHashMap</strong> 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表&#x2F;红⿊树；摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，通过并发控制 <strong>synchronized 和CAS</strong>来操作保证线程的安全。</p><h4 id="5、序列化和反序列化"><a href="#5、序列化和反序列化" class="headerlink" title="5、序列化和反序列化"></a><strong>5、序列化和反序列化</strong></h4><p>​序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。</p><p><strong>序列化：</strong>将java对象转化为字节序列的过程。</p><p><strong>反序列化：</strong>将字节序列转化为java对象的过程。 </p><p><strong>优点：</strong></p><p>​a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis的RDB</p><p>​b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google的protoBuf</p><p><strong>反序列化失败的场景：</strong></p><p>​序列化ID：serialVersionUID不一致的时候，导致反序列化失败</p><h4 id="6、String"><a href="#6、String" class="headerlink" title="6、String"></a><strong>6、String</strong></h4><p>String 使用<strong>数组</strong>存储内容，数组使用 <strong>final</strong> 修饰，因此 String 定义的字符串的值也是<strong>不可变的</strong></p><p>StringBuffer 对方法加了同步锁，线程安全，效率略低于 StringBuilder</p><h3 id="设计模式与原则"><a href="#设计模式与原则" class="headerlink" title="设计模式与原则"></a>设计模式与原则</h3><h4 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h4><p>​某个类只能生成一个实例，该实例全局访问，例如Spring容器里一级缓存里的单例池。</p><p><strong>优点</strong>：</p><p>​<strong>唯一访问</strong>：如生成唯一序列化的场景、或者spring默认的bean类型。</p><p>​<strong>提高性能</strong>：频繁实例化创建销毁或者耗时耗资源的场景，如连接池、线程池。</p><p><strong>缺点</strong>：</p><p>​不适合有状态且需变更的</p><p><strong>实现方式</strong>：</p><p>​<strong>饿汉式</strong>：线程安全速度快</p><p>​<strong>懒汉式</strong>：双重检测锁，第一次减少锁的开销、第二次防止重复、volatile防止重排序导致实例化未完成</p><p>​<strong>静态内部类</strong>：线程安全利用率高</p><p>​<strong>枚举</strong>：effictiveJAVA推荐，反射也无法破坏</p><h4 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h4><p>​定义一个用于创建产品的接口，由子类决定生产何种产品。</p><p><strong>优点：</strong>解耦：提供参数即可获取产品，通过配置文件可以不修改代码增加具体产品。</p><p><strong>缺点：</strong>每增加一个产品就得新增一个产品类</p><h4 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h4><p>​提供一个接口，用于创建相关或者依赖对象的家族，并由此进行约束。</p><p><strong>优点：</strong>可以在类的内部对产品族进行约束</p><p><strong>缺点</strong>：假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法可以被重载，只有当类中没有显性声明任何构造方法时，才会有默认构造方法。</p><p>构造方法没有返回值，构造方法的作用是创建新对象。</p><h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>静态初始化块的优先级最高，会最先执行，在非静态初始化块之前执行。</p><p>静态初始化块会在类第一次被加载时最先执行，因此在 main 方法之前。</p><h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>关键字 <code>this</code> 代表当前对象的引用。当前对象指的是调用类中的属性或方法的对象</p><p>关键字 <code>this</code> 不可以在静态方法中使用。静态方法不依赖于类的具体对象的引用</p><h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a><strong>重写和重载的区别</strong></h3><p>重载指在同一个类中定义多个方法，这些方法名称相同，签名不同。</p><p>重写指在子类中的方法的名称和签名都和父类相同，使用override注解</p><h3 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h3><p><strong>toString</strong>     默认是个指针，一般需要重写</p><p><strong>equals</strong>        比较对象是否相同，默认和&#x3D;&#x3D;功能一致</p><p><strong>hashCode</strong>  散列码，equals则hashCode相同，所以重写equals必须重写hashCode</p><p>**finalize   **    用于垃圾回收之前做的遗嘱，默认空，子类需重写</p><p><strong>clone</strong>           深拷贝，类需实现cloneable的接口</p><p><strong>getClass</strong>     反射获取对象元数据，包括类名、方法、</p><p><strong>notify、wait</strong>   用于线程通知和唤醒</p><h3 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goe1gq2yipj318s0ruwj4.jpg" alt="image-20210309224910999"></p><table><thead><tr><th>类型</th><th>缓存范围</th></tr></thead><tbody><tr><td>Byte,Short,Integer,Long</td><td>[-128, 127]</td></tr><tr><td>Character</td><td>[0, 127]</td></tr><tr><td>Boolean</td><td>[false, true]</td></tr></tbody></table><h1 id="二、JVM篇"><a href="#二、JVM篇" class="headerlink" title="二、JVM篇"></a>二、JVM篇</h1><h3 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a><strong>JVM内存划分</strong></h3><h4 id="1、JVM运行时数据区域"><a href="#1、JVM运行时数据区域" class="headerlink" title="1、JVM运行时数据区域"></a><strong>1、JVM运行时数据区域</strong></h4><p>​堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobgnw8m8uj30l10bejs4.jpg" alt="xxx"></p><p><strong>Heap(堆)：</strong></p><p>​对象的实例以及数组的内存都是要在堆上进行分配的，堆是线程共享的一块区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；开启逃逸分析后，某些未逃逸的对象可以通过标量替换的方式在栈中分配</p><p>​堆细分：新生代、老年代，对于新生代又分为：<strong>Eden区</strong>和<strong>Surviver1</strong>和<strong>Surviver2</strong>区；</p><p><strong>方法区：</strong></p><p>​对于JVM的方法区也可以称之为永久区，它储存的是已经被java虚拟机加载的类信息、常量、静态变量；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）；</p><p>​当应用中的 Java 类过多时，比如 <strong>Spring 等一些使用动态代理的框架生成了很多类</strong>，如果占用空间超出了我们的设定值，就会发生<strong>元空间溢出</strong></p><p><strong>虚拟机栈：</strong></p><p>​虚拟机栈<strong>是线程私有的</strong>，他的生命周期和线程的生命周期是一致的。里面装的是一个一个的<strong>栈帧</strong>，每一个方法在执行的时候都会创建一个栈帧，栈帧中用来存放（<strong>局部变量表</strong>、<strong>操作数栈</strong> 、<strong>动态链接</strong> 、<strong>返回地址</strong>）；在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常。</p><ul><li><p><strong>局部变量表：</strong>局部变量表是一组变量值存储空间，用来存放<strong>方法参数</strong>、方法内部定义的<strong>局部变量</strong>。底层是变量槽（variable slot）</p></li><li><p><strong>操作数栈：</strong>是用来记录一个方法在执行的过程中，<strong>字节码指令向操作数栈中进行入栈和出栈的过程</strong>。大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种<strong>字节码指令</strong>往操作数栈中<strong>入栈和出栈</strong>。</p></li><li><p><strong>动态链接：</strong>因为字节码文件中有很多符号的引用，这些符号引用一部分会在<strong>类加载的解析阶段</strong>或<strong>第一次使用</strong>的时候转化成<strong>直接引用</strong>，这种称为<strong>静态解析</strong>；另一部分会<strong>在运行期间</strong>转化为直接引用，称为<strong>动态链接</strong>。</p></li><li><p><strong>返回地址（returnAddress）：</strong>类型（指向了一条字节码指令的地址）</p><p><strong>JIT即时编译器（Just In Time Compiler），简称 JIT 编译器</strong>: </p><p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，比如锁粗化等</p></li></ul><p><strong>本地方法栈：</strong></p><p>​本地方法栈和虚拟机栈类似，不同的是虚拟机栈服务的是Java方法，而<strong>本地方法栈服务的是Native方法</strong>。在HotSpot虚拟机实现中是把本地方法栈和虚拟机栈合二为一的，同理它也会抛出<strong>StackOverflowError</strong>和<strong>OOM</strong>异常。</p><p><strong>PC程序计数器：</strong></p><p>​PC，指的是存放下一条指令的位置的一个指针。它是一块较小的内存空间，且是<strong>线程私有</strong>的。由于线程的切换，CPU在执行的过程中，需要记住原线程的下一条指令的位置，所以每一个线程都需要有自己的PC。</p><h4 id="2、堆内存分配策略"><a href="#2、堆内存分配策略" class="headerlink" title="2、堆内存分配策略"></a><strong>2、堆内存分配策略</strong></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnjl5glvj30l10h9jrt.jpg" alt="img"></p><ul><li><p>对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次MinorGC。而那些无需回收的存活对象，将会进到 Survivor 的 From 区（From 区内存不足时，直接进入 Old 区）。</p></li><li><p>大对象直接进入老年代（需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值（默认15次），对象进入老年区。</p><p>（<strong>动态对象年龄判定</strong>：程序从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 作为新的阈值，年龄大于此阈值的对象则直接进入老年代）</p></li><li><p>每次进行Minor GC或者大对象直接进入老年区时，JVM会计算所需空间大小如小于老年区的剩余值大小，则进行一次<strong>Full GC</strong>。</p></li></ul><h4 id="3、创建一个对象的步骤"><a href="#3、创建一个对象的步骤" class="headerlink" title="3、创建一个对象的步骤"></a><strong>3、创建一个对象的步骤</strong></h4><p><strong>步骤：类加载检查、分配内存、初始化零值、设置对象头、执行init方法</strong></p><p><strong>①类加载检查：</strong> </p><p>​虚拟机遇到 new 指令时，⾸先去检查是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。</p><p><strong>②分配内存：</strong></p><p>​ 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存，分配⽅式有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。</p><p><strong>③初始化零值：</strong></p><p>​ 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>④设置对象头：</strong> </p><p>​初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p><p><strong>⑤执⾏ init ⽅法：</strong> </p><p>​从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看， <init> ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说（除循环依赖），执⾏ new 指令之后会接着执⾏  <init> ⽅法，这样⼀个真正可⽤的对象才算产⽣出来。</p><h4 id="4、对象引用"><a href="#4、对象引用" class="headerlink" title="4、对象引用"></a>4、<strong>对象引用</strong></h4><p>普通的对象引用关系就是<strong>强引用</strong>。</p><p><strong>软引用</strong>用于维护一些可有可无的对象。只有在<strong>内存不足时，系统则会回收软引用对象</strong>，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。</p><p><strong>弱引用</strong>对象相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，<strong>无论内存是否充足</strong>，都会回收被弱引用关联的对象。</p><p><strong>虚引用</strong>是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来<strong>跟踪对象被垃圾回收</strong>的活动。</p><h3 id="JVM类加载过程"><a href="#JVM类加载过程" class="headerlink" title="JVM类加载过程"></a><strong>JVM类加载过程</strong></h3><p><strong>过程：加载、验证、准备、解析、初始化</strong></p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnnbem87j30eq0cogmj.jpg" alt="img" style="zoom:50%;" /><p><strong>加载阶段：</strong></p><p>​1.通过一个类的全限定名来获取定义此类的二进制字节流。</p><p>​2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>​3.在Java堆中生成一个代表这个类的java.lang.class对象，作为方法区这些数据的访问入口。</p><p><strong>验证阶段：</strong></p><p>​1.文件格式验证（是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理）</p><p>​2.元数据验证（对字节码描述的信息进行语意分析，以保证其描述的信息符合Java语言规范要求）</p><p>​3.字节码验证（保证被校验类的方法在运行时不会做出危害虚拟机安全的行为）</p><p>​4.符号引用验证（虚拟机将符号引用转化为直接引用时，解析阶段中发生）</p><p><strong>准备阶段：</strong></p><p>​准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。将对象初始化为“零”值</p><p><strong>解析阶段：</strong></p><p>​解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>​<strong>字符串常量池</strong>：堆上，默认class文件的静态常量池</p><p>​<strong>运行时常量池</strong>：在方法区，属于元空间</p><p><strong>初始化阶段：</strong></p><p>​初始化阶段时加载过程的最后一步，而这一阶段也是真正意义上开始执行类中定义的Java程序代码。</p><h4 id="1、双亲委派机制"><a href="#1、双亲委派机制" class="headerlink" title="1、双亲委派机制"></a><strong>1、双亲委派机制</strong></h4><p>​每⼀个类都有⼀个对应它的类加载器。系统中的 ClassLoder 在协同⼯作的时候会默认使⽤ 双亲委派模型 。即在类加载的时候，系统会⾸先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，⾸先会把该请求委派该⽗类加载器的  loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器  BootstrapClassLoader 中。当⽗类加载器⽆法处理时，才由⾃⼰来处理。当⽗类加载器为null时，会使⽤启动类加载器  BootstrapClassLoader 作为⽗类加载器。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobn5lh4f6j30hk08rjso.jpg" alt="img"></p><p><strong>使用好处：</strong></p><p>​此机制保证JDK核心类的优先加载；使得Java程序的稳定运⾏，可以避免类的重复加载，也保证了 Java 的核⼼ API 不被篡改。如果不⽤没有使⽤双亲委派模型，⽽是每个类加载器加载⾃⼰的话就会出现⼀些问题，⽐如我们编写⼀个称为  java.lang.Object 类的话，那么程序运⾏的时候，系统就会出现多个不同的Object 类。</p><p><strong>破坏双亲委派机制：</strong></p><ul><li><p>可以⾃⼰定义⼀个类加载器，重写loadClass方法；</p></li><li><p>Tomcat 可以加载自己目录下的 class 文件，并不会传递给父类的加载器；</p></li><li><p>Java 的 SPI，发起者 BootstrapClassLoader 已经是最上层了，它直接获取了 AppClassLoader 进行驱动加载，和双亲委派是相反的。</p></li></ul><h4 id="2、tomcat的类加载机制"><a href="#2、tomcat的类加载机制" class="headerlink" title="2、tomcat的类加载机制"></a><strong>2、tomcat的类加载机制</strong></h4><p><strong>步骤：</strong></p><ol><li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li><li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li><li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。</li><li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li><li>加载依然失败，才使用 AppClassLoader 继续加载。</li><li>都没有加载成功的话，抛出异常。</li></ol><p>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</p><h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="1、存活算法和两次标记过程"><a href="#1、存活算法和两次标记过程" class="headerlink" title="1、存活算法和两次标记过程"></a><strong>1、存活算法和两次标记过程</strong></h4><p><strong>引用计数法：</strong></p><p>​给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>​优点：实现简单，判定效率也很高</p><p>​缺点：他很难解决对象之间相互循环引用的问题，基本上被抛弃</p><p><strong>可达性分析法：</strong></p><p>​通过一系列的成为“GC Roots”(活动线程相关的各种引用，虚拟机<strong>栈帧引用</strong>，<strong>静态变量引用</strong>，<strong>JNI引用</strong>)的对象作为起始点，从这些节点ReferenceChains开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的；</p><p><strong>两次标记过程：</strong></p><p>​对象被回收之前，该对象的finalize()方法会被调用；两次标记，即第一次标记不在“关系网”中的对象。第二次的话就要先判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收；如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它，随后就会进行第二次的小规模标记，在这次被标记的对象就会真正的被回收了。</p><h4 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a><strong>2、垃圾回收算法</strong></h4><p><strong>垃圾回收算法</strong>：复制算法、标记清除、标记整理、分代收集</p><p><strong>复制算法：(young)</strong></p><p>​将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收；</p><p>​优点：实现简单，内存效率高，不易产生碎片</p><p>​缺点：内存压缩了一半，倘若存活对象多，Copying 算法的效率会大大降低</p><p><strong>标记清除：(cms)</strong></p><p>​标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象</p><p>​缺点：效率低，标记清除后会产⽣⼤量不连续的碎⽚，需要预留空间给分配阶段的浮动垃圾</p><p><strong>标记整理：(old)</strong></p><p>​标记过程仍然与“标记-清除”算法⼀样，再让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存；解决了产生大量不连续碎片问题</p><p><strong>分代收集：</strong></p><p>​根据各个年代的特点选择合适的垃圾收集算法。</p><p>​新生代采用复制算法，新生代每次垃圾回收都要回收大部分对象，存活对象较少，即要复制的操作比较少，一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><p>​老年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</p><p><strong>Safepoint</strong> 当发生 GC 时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为 JVM 是安全的（safe），整个堆的状态是稳定的。如果在 GC 前，有线程迟迟进入不了 safepoint，那么整个 JVM 都在等待这个阻塞的线程，造成了整体 GC 的时间变长</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnmip32vj30l109q0t3.jpg" alt="img"></p><h5 id="MinorGC、MajorGC、FullGC"><a href="#MinorGC、MajorGC、FullGC" class="headerlink" title="MinorGC、MajorGC、FullGC"></a><strong>MinorGC、MajorGC、FullGC</strong></h5><p><strong>MinorGC</strong> 在年轻代空间不足的时候发生，</p><p><strong>MajorGC</strong> 指的是老年代的 GC，出现 MajorGC 一般经常伴有 MinorGC。</p><p><strong>FullGC</strong> 1、当老年代无法再分配内存的时候；2、元空间不足的时候；3、显示调用 System.gc 的时候。另外，像 CMS 一类的垃圾回收器，在 MinorGC 出现 promotion failure 的时候也会发生 FullGC。</p><p><strong>对象优先在 Eden 区分配</strong><br>    大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p><p><strong>大对象直接进入老年代</strong><br>    大对象是指需要连续内存空间的对象，比如很长的字符串以及数组。老年代直接分配的<strong>目的是</strong>避免在 Eden 区和 Survivor 区之间出现大量内存复制。</p><p><strong>长期存活的对象进入老年代</strong><br>    虚拟机给每个对象定义了年龄计数器，对象在 Eden 区出生之后，如果经过一次 Minor GC 之后，将进入 Survivor 区，同时对象年龄变为 1，增加到一定阈值时则进入老年代（阈值默认为 15）</p><p><strong>动态对象年龄判定</strong><br>    为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</p><p><strong>空间分配担保</strong><br>    在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立则进行 Full GC。</p><h4 id="3、垃圾收集器"><a href="#3、垃圾收集器" class="headerlink" title="3、垃圾收集器"></a><strong>3、垃圾收集器</strong></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnjx3zcej30l10ctaat.jpg" alt="img"></p><p>​<strong>JDK3：Serial Parnew 关注效率</strong></p><p><strong>Serial：</strong></p><p>​Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。适合用于客户端垃圾收集器。</p><p><strong>Parnew：</strong></p><p>​ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p><p>​<strong>JDK5：parallel Scavenge+（Serial old&#x2F;parallel old）关注吞吐量</strong></p><p><strong>parallel Scavenge：</strong>(关注吞吐量)</p><p>​Parallel Scavenge收集器关注点是吞吐量（⾼效率的利⽤CPU）。CMS等垃圾收集器的关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）；高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。</p><p><strong>Serial old：</strong></p><p>Serial收集器的⽼年代版本，它同样是⼀个单线程收集器，使用标记-整理算法。主要有两个用途：</p><ul><li><p>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</p></li><li><p>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</p></li></ul><p><strong>parallel old：</strong></p><p>​Parallel Scavenge收集器的⽼年代版本。使⽤多线程和“标记-整理”算法。</p><p><strong>JDK8-CMS：（关注最短垃圾回收停顿时间）</strong></p><p>​CMS收集器是一种年老代垃圾收集器，其最主要目标是获取<strong>最短垃圾回收停顿时间</strong>，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p><p>​<strong>初始标记：</strong>只是标记一下 GC Roots 能直接关联的对象，速度很快，STW。</p><p>​<strong>并发标记：</strong>进行 ReferenceChains跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p><p>​<strong>重新标记：</strong>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，STW。</p><p>​<strong>并发清除：</strong>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。</p><p>​由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</p><p>​<strong>优点：</strong>并发收集、低停顿</p><p>​<strong>缺点：</strong>对CPU资源敏感；⽆法处理浮动垃圾；使⽤“标记清除”算法，会导致⼤量空间碎⽚产⽣。</p><p><strong>JDK9-G1：（精准控制停顿时间，避免垃圾碎片）</strong></p><p>​是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器.以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征；相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p><p>​【1】基于标记-整理算法，不产生内存碎片。</p><p>​【2】可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p><p>​G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。<strong>区域划分</strong>和<strong>优先级区域</strong>回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p><ul><li><p><strong>初始标记</strong>：<strong>Stop The World，</strong>仅使用一条初始标记线程对GC Roots关联的对象进行标记</p></li><li><p><strong>并发标记</strong>：使用一条标记线程与用户线程并发执行。此过程进行<strong>可达性分析，速度很慢</strong></p></li><li><p><strong>最终标记</strong>：<strong>Stop The World</strong>，使用多条标记线程并发执行</p></li><li><p><strong>筛选回收</strong>：回收废弃对象，此时也要 <strong>Stop The World</strong>，并使用多条筛选回收线程并发执行</p></li></ul><p>**JDK11-ZGC:**（在不关注容量的情况获取最小停顿时间5TB&#x2F;10ms）</p><p>​着色笔技术：加快标记过程</p><p>​读屏障：解决GC和应用之间并发导致的STW问题</p><ul><li><p>支持 TB 级堆内存（最大 4T， JDK13 最大16TB）</p></li><li><p>最大 GC 停顿 10ms</p></li><li><p>对吞吐量影响最大，不超过 15%</p></li></ul><h4 id="4、配置垃圾收集器"><a href="#4、配置垃圾收集器" class="headerlink" title="4、配置垃圾收集器"></a><strong>4、配置垃圾收集器</strong></h4><ul><li>首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。</li><li>通常，堆空间我会设置成操作系统的 2&#x2F;3，超过 8GB 的堆，优先选用 G1</li><li>然后我会对 JVM 进行初步优化，比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例</li><li>依据系统容量、访问延迟、吞吐量等进行专项优化，我们的服务是高并发的，对 STW 的时间敏感</li><li>我会通过记录详细的 GC 日志，来找到这个瓶颈点，借用 GCeasy 这样的日志分析工具，定位问题</li></ul><h4 id="4、JVM性能调优"><a href="#4、JVM性能调优" class="headerlink" title="4、JVM性能调优"></a><strong>4、JVM性能调优</strong></h4><p>对应进程的JVM状态以定位问题和解决问题并作出相应的优化</p><p><strong>常用命令：</strong>jps、jinfo、jstat、jstack、jmap</p><p><strong>jps：查看java进程及相关信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jps -l 输出jar包路径，类全名</span><br><span class="line">jps -m 输出main参数</span><br><span class="line">jps -v 输出JVM参数</span><br></pre></td></tr></table></figure><p><strong>jinfo：查看JVM参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jinfo <span class="number">11666</span></span><br><span class="line">jinfo -flags <span class="number">11666</span></span><br><span class="line">Xmx、Xms、Xmn、MetaspaceSize</span><br></pre></td></tr></table></figure><p><strong>jstat：查看JVM运行时的状态信息，包括内存状态、垃圾回收</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br><span class="line">其中LVMID是进程id，interval是打印间隔时间（毫秒），count是打印次数（默认一直打印）</span><br><span class="line">  </span><br><span class="line">option参数解释：</span><br><span class="line">-gc 垃圾回收堆的行为统计</span><br><span class="line">-gccapacity 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计</span><br><span class="line">-gcutil 垃圾回收统计概述</span><br><span class="line">-gcnew 新生代行为统计</span><br><span class="line">-gcold 年老代和永生代行为统计</span><br></pre></td></tr></table></figure><p><strong>jstack：查看JVM线程快照，jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jstack [-l] &lt;pid&gt; (连接运行中的进程)</span><br><span class="line">  </span><br><span class="line">option参数解释：</span><br><span class="line">-F 当使用jstack &lt;pid&gt;无响应时，强制输出线程堆栈。</span><br><span class="line">-m 同时输出java和本地堆栈(混合模式)</span><br><span class="line">-l 额外显示锁信息</span><br></pre></td></tr></table></figure><p><strong>jmap：可以用来查看内存信息</strong>(配合jhat使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;pid&gt; (连接正在执行的进程)</span><br><span class="line"></span><br><span class="line">option参数解释：</span><br><span class="line">-heap 打印java heap摘要</span><br><span class="line">-dump:&lt;dump-options&gt; 生成java堆的dump文件</span><br></pre></td></tr></table></figure><h4 id="5、JDK新特性"><a href="#5、JDK新特性" class="headerlink" title="5、JDK新特性"></a>5、JDK新特性</h4><p>JDK8</p><p>支持 Lamda 表达式、集合的 stream 操作、提升HashMap性能</p><p><strong>JDK9</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream API中iterate方法的新重载方法，可以指定什么时候结束迭代</span></span><br><span class="line">IntStream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>默认G1垃圾回收器</p><p><strong>JDK10</strong> </p><p>其重点在于通过完全GC并行来改善G1最坏情况的等待时间。</p><p><strong>JDK11</strong></p><p>ZGC (并发回收的策略) 4TB</p><p>用于 Lambda 参数的局部变量语法</p><p><strong>JDK12</strong></p><p>Shenandoah GC (GC 算法)停顿时间和堆的大小没有任何关系，并行关注停顿响应时间。</p><p><strong>JDK13</strong></p><p>增加ZGC以将未使用的堆内存返回给操作系统，16TB</p><p><strong>JDK14</strong></p><p>删除cms垃圾回收器、弃用ParallelScavenge+SerialOldGC垃圾回收算法组合</p><p>将ZGC垃圾回收器应用到macOS和windows平台</p><h3 id="线上故障排查"><a href="#线上故障排查" class="headerlink" title="线上故障排查"></a>线上故障排查</h3><h4 id="1、硬件故障排查"><a href="#1、硬件故障排查" class="headerlink" title="1、硬件故障排查"></a>1、硬件故障排查</h4><p>如果一个实例发生了问题，根据情况选择，要不要着急去重启。如果出现的CPU、内存飙高或者日志里出现了OOM异常</p><p><strong>第一步是隔离</strong>，第二步是<strong>保留现场</strong>，第三步才是<strong>问题排查</strong>。</p><p><strong>隔离</strong></p><p>就是把你的这台机器从请求列表里摘除，比如把 nginx 相关的权重设成零。</p><p><strong>现场保留</strong></p><p><strong>瞬时态和历史态</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnwy22d2j30l10cpt9d.jpg" alt="img"></p><p>查看比如 CPU、系统内存等，通过历史状态可以体现一个趋势性问题，而这些信息的获取一般依靠监控系统的协作。           </p><p><strong>保留信息</strong></p><p>（1）<strong>系统当前网络连接</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -antp &gt; $DUMP_DIR/ss.dump 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>使用 ss 命令而不是 netstat 的原因，是因为 netstat 在网络连接非常多的情况下，执行非常缓慢。</p><p>后续的处理，可通过查看各种网络连接状态的梳理，来排查 TIME_WAIT 或者 CLOSE_WAIT，或者其他连接过高的问题，非常有用。</p><p>（2）<strong>网络状态统计</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s &gt; $DUMP_DIR/netstat-s.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>它能够按照各个协议进行统计输出，对把握当时整个网络状态，有非常大的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -n DEV <span class="number">1</span> <span class="number">2</span> &gt; $DUMP_DIR/sar-traffic.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>在一些速度非常高的模块上，比如 Redis、Kafka，就经常发生跑满网卡的情况。表现形式就是网络通信非常缓慢。</p><p>（3）<strong>进程资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p $PID &gt; $DUMP_DIR/lsof-$PID.dump</span><br></pre></td></tr></table></figure><p>通过查看进程，能看到打开了哪些文件，可以以进程的维度来查看整个资源的使用情况，包括每条网络连接、每个打开的文件句柄。同时，也可以很容易的看到连接到了哪些服务器、使用了哪些资源。这个命令在资源非常多的情况下，输出稍慢，请耐心等待。</p><p>（4）<strong>CPU 资源</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mpstat &gt; $DUMP_DIR/mpstat.dump 2&gt;&amp;1</span><br><span class="line">vmstat 1 3 &gt; $DUMP_DIR/vmstat.dump 2&gt;&amp;1</span><br><span class="line">sar -p ALL  &gt; $DUMP_DIR/sar-cpu.dump  2&gt;&amp;1</span><br><span class="line">uptime &gt; $DUMP_DIR/uptime.dump 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>主要用于输出当前系统的 CPU 和负载，便于事后排查。</p><p>（5）<strong>I&#x2F;O 资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x &gt; $DUMP_DIR/iostat.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>一般，以计算为主的服务节点，I&#x2F;O 资源会比较正常，但有时也会发生问题，比如<strong>日志输出过多，或者磁盘问题</strong>等。此命令可以输出每块磁盘的基本性能信息，用来排查 I&#x2F;O 问题。在第 8 课时介绍的 GC 日志分磁盘问题，就可以使用这个命令去发现。</p><p>（6）<strong>内存问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h &gt; $DUMP_DIR/free.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>free 命令能够大体展现操作系统的内存概况，这是故障排查中一个非常重要的点，比如 SWAP 影响了 GC，SLAB 区挤占了 JVM 的内存。</p><p>（7）<strong>其他全局</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef &gt; $DUMP_DIR/ps.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">dmesg &gt; $DUMP_DIR/dmesg.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">sysctl -a &gt; $DUMP_DIR/sysctl.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>dmesg 是许多静悄悄死掉的服务留下的最后一点线索。当然，ps 作为执行频率最高的一个命令，由于内核的配置参数，会对系统和 JVM 产生影响，所以我们也输出了一份。</p><p>（8）<strong>进程快照</strong>，最后的遗言（jinfo）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jinfo $PID &gt; $DUMP_DIR/jinfo.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>此命令将输出 Java 的基本进程信息，包括<strong>环境变量和参数配置</strong>，可以查看是否因为一些错误的配置造成了 JVM 问题。</p><p><strong>（9）dump 堆信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jstat -gcutil $PID &gt; $DUMP_DIR/jstat-gcutil.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jstat -gccapacity $PID &gt; $DUMP_DIR/jstat-gccapacity.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>jstat 将输出当前的 gc 信息。一般，基本能大体看出一个端倪，如果不能，可将借助 jmap 来进行分析。</p><p><strong>（10）堆信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jmap $PID &gt; $DUMP_DIR/jmap.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jmap -heap $PID &gt; $DUMP_DIR/jmap-heap.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jmap -histo $PID &gt; $DUMP_DIR/jmap-histo.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jmap -dump:format=b,file=$DUMP_DIR/heap.bin $PID &gt; /dev/<span class="literal">null</span>  <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>jmap 将会得到当前 Java 进程的 dump 信息。如上所示，其实最有用的就是第 4 个命令，但是前面三个能够让你初步对系统概况进行大体判断。因为，第 4 个命令产生的文件，一般都非常的大。而且，需要下载下来，导入 MAT 这样的工具进行深入分析，才能获取结果。这是分析内存泄漏一个必经的过程。</p><p><strong>（11）JVM 执行栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jstack $PID &gt; $DUMP_DIR/jstack.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>jstack 将会获取当时的执行栈。一般会多次取值，我们这里取一次即可。这些信息非常有用，能够还原 Java 进程中的线程情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp $PID -b -n <span class="number">1</span> -c &gt;  $DUMP_DIR/top-$PID.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了能够得到更加精细的信息，我们使用 top 命令，来获取进程中所有线程的 CPU 信息，这样，就可以看到资源到底耗费在什么地方了。</p><p><strong>（12）高级替补</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -<span class="number">3</span> $PID</span><br></pre></td></tr></table></figure><p>有时候，jstack 并不能够运行，有很多原因，比如 Java 进程几乎不响应了等之类的情况。我们会尝试向进程发送 kill -3 信号，这个信号将会打印 jstack 的 trace 信息到日志文件中，是 jstack 的一个替补方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcore -o $DUMP_DIR/core $PID</span><br></pre></td></tr></table></figure><p>对于 jmap 无法执行的问题，也有替补，那就是 GDB 组件中的 gcore，将会生成一个 core 文件。我们可以使用如下的命令去生成 dump：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jhsdb jmap --exe $&#123;JDK&#125;java  --core $DUMP_DIR/core --binaryheap</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>内存泄漏的现象</strong></li></ol><p>稍微提一下 jmap 命令，它在 9 版本里被干掉了，取而代之的是 jhsdb，你可以像下面的命令一样使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jhsdb jmap  --heap --pid  <span class="number">37340</span></span><br><span class="line">jhsdb jmap  --pid  <span class="number">37288</span></span><br><span class="line">jhsdb jmap  --histo --pid  <span class="number">37340</span></span><br><span class="line">jhsdb jmap  --binaryheap --pid  <span class="number">37340</span></span><br></pre></td></tr></table></figure><p>一般内存溢出，表现形式就是 Old 区的占用持续上升，即使经过了多轮 GC 也没有明显改善。比如ThreadLocal里面的GC Roots，内存泄漏的根本就是，这些对象并没有切断和 GC Roots 的关系，可通过一些工具，能够看到它们的联系。</p><h4 id="2、报表异常-JVM调优"><a href="#2、报表异常-JVM调优" class="headerlink" title="2、报表异常 | JVM调优"></a>2、报表异常 | JVM调优</h4><p>有一个报表系统，频繁发生内存溢出，在高峰期间使用时，还会频繁的发生拒绝服务，由于大多数使用者是管理员角色，所以很快就反馈到研发这里。</p><p>业务场景是由于有些结果集的字段不是太全，因此需要对结果集合进行循环，并通过 HttpClient 调用其他服务的接口进行数据填充。使用 Guava 做了 JVM 内缓存，但是响应时间依然很长。</p><p>初步排查，JVM 的资源太少。接口 A 每次进行报表计算时，都要涉及几百兆的内存，而且在内存里驻留很长时间，有些计算又非常耗 CPU，特别的“吃”资源。而我们分配给 JVM 的内存只有 3 GB，在多人访问这些接口的时候，内存就不够用了，进而发生了 OOM。在这种情况下，没办法，只有升级机器。把机器配置升级到 4C8G，给 JVM 分配 6GB 的内存，这样 OOM 问题就消失了。但随之而来的是频繁的 GC 问题和超长的 GC 时间，平均 GC 时间竟然有 5 秒多。</p><p>进一步，由于报表系统和高并发系统不太一样，它的对象，存活时长大得多，并不能仅仅通过增加年轻代来解决；而且，如果增加了年轻代，那么必然减少了老年代的大小，由于 CMS 的碎片和浮动垃圾问题，我们可用的空间就更少了。虽然服务能够满足目前的需求，但还有一些不太确定的风险。</p><p>第一，了解到程序中有很多缓存数据和静态统计数据，为了减少 MinorGC 的次数，通过分析 GC 日志打印的对象年龄分布，把 MaxTenuringThreshold 参数调整到了 3（特殊场景特殊的配置）。这个参数是让年轻代的这些对象，赶紧回到老年代去，不要老呆在年轻代里。</p><p>第二，我们的 GC 时间比较长，就一块开了参数 CMSScavengeBeforeRemark，使得在 CMS remark 前，先执行一次 Minor GC 将新生代清掉。同时配合上个参数，其效果还是比较好的，一方面，对象很快晋升到了老年代，另一方面，年轻代的对象在这种情况下是有限的，在整个 MajorGC 中占的时间也有限。</p><p>第三，由于缓存的使用，有大量的弱引用，拿一次长达 10 秒的 GC 来说。我们发现在 GC 日志里，处理 weak refs 的时间较长，达到了 4.5 秒。这里可以加入参数 ParallelRefProcEnabled 来并行处理Reference，以加快处理速度，缩短耗时。</p><p>优化之后，效果不错，但并不是特别明显。经过评估，针对高峰时期的情况进行调研，我们决定再次提升机器性能，改用 8core16g 的机器。但是，这带来另外一个问题。</p><p><strong>高性能的机器带来了非常大的服务吞吐量</strong>，通过 jstat 进行监控，能够看到年轻代的分配速率明显提高，但随之而来的 MinorGC 时长却变的不可控，有时候会超过 1 秒。累积的请求造成了更加严重的后果。</p><p>这是由于堆空间明显加大造成的回收时间加长。为了获取较小的停顿时间，我们在堆上<strong>改用了 G1 垃圾回收器</strong>，把它的目标设定在 200ms。G1 是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的 GC 暂停目标，就能得到不错的性能。修改之后，虽然 GC 更加频繁了一些，但是停顿时间都比较小，应用的运行较为平滑。</p><p>到目前为止，也只是勉强顶住了已有的业务，但是，这时候领导层面又发力，<strong>要求报表系统可以支持未来两年业务10到100倍的增长</strong>，并保持其可用性，但是这个“千疮百孔”的报表系统，稍微一压测，就宕机，那如何应对十倍百倍的压力呢 ? 硬件即使可以做到动态扩容，但是毕竟也有极限。</p><p>使用 MAT 分析堆快照，发现很多地方可以通过代码优化，那些占用内存特别多的对象：</p><p>1、select * 全量排查，只允许获取必须的数据</p><p>2、报表系统中cache实际的命中率并不高，将Guava 的 Cache 引用级别改成弱引用（WeakKeys）</p><p>3、限制报表导入文件大小，同时拆分用户超大范围查询导出请求。</p><p>每一步操作都使得JVM使用变得更加可用，一系列优化以后，机器相同压测数据性能提升了数倍。</p><h4 id="3、大屏异常-JUC调优"><a href="#3、大屏异常-JUC调优" class="headerlink" title="3、大屏异常 | JUC调优"></a>3、大屏异常 | JUC调优</h4><p>有些数据需要使用 HttpClient 来获取进行补全。提供数据的服务提供商有的响应时间可能会很长，也有可能会造成服务整体的阻塞。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobr4whjzwj30l1058dfx.jpg" alt="img"></p><p>接口 A 通过 HttpClient 访问服务 2，响应 100ms 后返回；接口 B 访问服务 3，耗时 2 秒。HttpClient 本身是有一个最大连接数限制的，如果服务 3 迟迟不返回，就会造成 HttpClient 的连接数达到上限，<strong>概括来讲，就是同一服务，由于一个耗时非常长的接口，进而引起了整体的服务不可用</strong></p><p>这个时候，通过 jstack 打印栈信息，会发现大多数竟然阻塞在了接口 A 上，而不是耗时更长的接口 B，这个现象起初十分具有迷惑性，不过经过分析后，我们猜想其实是因为接口 A 的速度比较快，在问题发生点进入了更多的请求，它们全部都阻塞住的同时被打印出来了。</p><p>为了验证这个问题，我搭建了一个demo 工程，模拟了两个使用同一个 HttpClient 的接口。fast 接口用来访问百度，很快就能返回；slow 接口访问谷歌，由于众所周知的原因，会阻塞直到超时，大约 10 s。 利用ab对两个接口进行压测，同时使用 jstack 工具 dump 堆栈。首先使用 jps 命令找到进程号，然后把结果重定向到文件（可以参考 10271.jstack 文件）。</p><p>过滤一下 nio 关键字，可以查看 tomcat 相关的线程，足足有 200 个，这和 Spring Boot 默认的 maxThreads 个数不谋而合。更要命的是，有大多数线程，都处于 BLOCKED 状态，说明线程等待资源超时。通过grep fast | wc -l 分析，确实200个中有150个都是blocked的fast的进程。</p><p>问题找到了，解决方式就顺利成章了。</p><p>1、fast和slow争抢连接资源，通过线程池限流或者熔断处理</p><p>2、有时候slow的线程也不是一直slow，所以就得加入监控</p><p>3、使用带countdownLaunch对线程的执行顺序逻辑进行控制</p><h4 id="4、接口延迟-SWAP调优"><a href="#4、接口延迟-SWAP调优" class="headerlink" title="4、接口延迟 | SWAP调优"></a><strong>4、接口延迟 | SWAP调优</strong></h4><p>有一个关于服务的某个实例，经常发生服务卡顿。由于服务的并发量是比较高的，每多停顿 1 秒钟，几万用户的请求就会感到延迟。</p><p>我们统计、类比了此服务其他实例的 CPU、内存、网络、I&#x2F;O 资源，区别并不是很大，所以一度怀疑是机器硬件的问题。</p><p>接下来我们对比了节点的 GC 日志，发现无论是 Minor GC，还是 Major GC，这个节点所花费的时间，都比其他实例长得多。</p><p>通过仔细观察，我们发现在 GC 发生的时候，vmstat 的 si、so 飙升的非常严重，这和其他实例有着明显的不同。</p><p>使用 free 命令再次确认，发现 SWAP 分区，使用的比例非常高，引起的具体原因是什么呢？</p><p>更详细的操作系统内存分布，从 &#x2F;proc&#x2F;meminfo 文件中可以看到具体的逻辑内存块大小，有多达 40 项的内存信息，这些信息都可以通过遍历 &#x2F;proc 目录的一些文件获取。我们注意到 slabtop 命令显示的有一些异常，dentry（目录高速缓冲）占用非常高。</p><p>问题最终定位到是由于某个运维工程师删除日志时，定时执行了一句命令：</p><p>find &#x2F; | grep “xxx.log”</p><p>他是想找一个叫做 要被删除 的日志文件，看看在哪台服务器上，结果，这些老服务器由于文件太多，扫描后这些文件信息都缓存到了 slab 区上。而服务器开了 swap，操作系统发现物理内存占满后，并没有立即释放 cache，导致每次 GC 都要和硬盘打一次交道。</p><p><strong>解决方式就是关闭 SWAP 分区。</strong></p><p>swap 是很多性能场景的万恶之源，建议禁用。在高并发 SWAP 绝对能让你体验到它魔鬼性的一面：进程倒是死不了了，但 GC 时间长的却让人无法忍受。</p><h4 id="5、内存溢出-Cache调优"><a href="#5、内存溢出-Cache调优" class="headerlink" title="5、内存溢出 | Cache调优"></a>5、<strong>内存溢出 | Cache调优</strong></h4><blockquote><p>有一次线上遇到故障，重新启动后，使用 jstat 命令，发现 Old 区一直在增长。我使用 jmap 命令，导出了一份线上堆栈，然后使用 MAT 进行分析，通过对 GC Roots 的分析，发现了一个非常大的 HashMap 对象，这个原本是其他同事做缓存用的，但是做了一个无界缓存，没有设置超时时间或者 LRU 策略，在使用上又没有重写key类对象的hashcode和equals方法，对象无法取出也直接造成了堆内存占用一直上升，后来，将这个缓存改成 guava 的 Cache，并设置了弱引用，故障就消失了。</p><p>关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p></blockquote><p>内存溢出是一个结果，而<strong>内存泄漏</strong>是一个原因。内存溢出的原因有<strong>内存空间不足、配置错误</strong>等因素。一些错误的编程方式，不再被使用的对象、没有被回收、没有及时切断与 GC Roots 的联系，这就是内存泄漏。</p><p>举个例子，有团队使用了 HashMap 做缓存，但是并没有设置超时时间或者 LRU 策略，造成了放入 Map 对象的数据越来越多，而产生了内存泄漏。</p><p>再来看一个经常发生的内存泄漏的例子，也是由于 HashMap 产生的。代码如下，由于没有重写 Key 类的 hashCode 和 equals 方法，造成了放入 HashMap 的所有对象都无法被取出来，它们和外界失联了。所以下面的代码结果是 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leak example</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapLeakDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">        String title;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Key, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;1&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;2&quot;</span>), <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.get(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使提供了 equals 方法和 hashCode 方法，也要非常小心，尽量避免使用自定义的对象作为 Key。</p><p>再看一个例子，关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p><h4 id="6：CPU飙高-死循环"><a href="#6：CPU飙高-死循环" class="headerlink" title="6：CPU飙高 | 死循环"></a>6：CPU飙高 | 死循环</h4><p>我们有个线上应用，单节点在运行一段时间后，CPU 的使用会飙升，一旦飙升，一般怀疑某个业务逻辑的计算量太大，或者是触发了死循环（比如著名的 HashMap 高并发引起的死循环），但排查到最后其实是 GC 的问题。        </p><p>（1）使用 top 命令，查找到使用 CPU 最多的某个进程，记录它的 pid。使用 Shift + P 快捷键可以按 CPU 的使用率进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>（2）再次使用 top 命令，加 -H 参数，查看某个进程中使用 CPU 最多的某个线程，记录线程的 ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp $pid</span><br></pre></td></tr></table></figure><p>（3）使用 printf 函数，将十进制的 tid 转化成十六进制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf %x $tid</span><br></pre></td></tr></table></figure><p>（4）使用 jstack 命令，查看 Java 进程的线程栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack $pid &gt;$pid.log</span><br></pre></td></tr></table></figure><p>（5）使用 less 命令查看生成的文件，并查找刚才转化的十六进制 tid，找到发生问题的线程上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less $pid.log</span><br></pre></td></tr></table></figure><p>我们在 jstack 日志搜关键字DEAD，以及中找到了 CPU 使用最多的几个线程id。</p><p>可以看到问题发生的根源，是我们的堆已经满了，但是又没有发生 OOM，于是 GC 进程就一直在那里回收，回收的效果又非常一般，造成 CPU 升高应用假死。接下来的具体问题排查，就需要把内存 dump 一份下来，使用 MAT 等工具分析具体原因了。</p><h1 id="三、多线程篇"><a href="#三、多线程篇" class="headerlink" title="三、多线程篇"></a>三、多线程篇</h1><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="1、线程状态"><a href="#1、线程状态" class="headerlink" title="1、线程状态"></a><strong>1、线程状态</strong></h4><p>​线程是cpu任务调度的最小执行单位，每个线程拥有自己独立的程序计数器、虚拟机栈、本地方法栈</p><p><strong>线程状态：创建、就绪、运行、阻塞、死亡</strong></p><img src="https://s0.lgstatic.com/i/image3/M01/77/29/Cgq2xl5xxGKAKBpeAAEw9Ifr07Y662.png" alt="img" style="zoom: 40%;" /><h4 id="2、线程状态切换"><a href="#2、线程状态切换" class="headerlink" title="2、线程状态切换"></a><strong>2、线程状态切换</strong></h4><table><thead><tr><th>方法</th><th>作用</th><th>区别</th></tr></thead><tbody><tr><td>start</td><td>启动线程，由虚拟机自动调度执行run()方法</td><td>线程处于就绪状态</td></tr><tr><td>run</td><td>线程逻辑代码块处理，JVM调度执行</td><td>线程处于运行状态</td></tr><tr><td>sleep</td><td>让当前正在执行的线程休眠（暂停执行）</td><td>不释放锁</td></tr><tr><td>wait</td><td>使得当前线程等待</td><td>释放同步锁</td></tr><tr><td>notify</td><td>唤醒在此对象监视器上等待的单个线程</td><td>唤醒单个线程</td></tr><tr><td>notifyAll</td><td>唤醒在此对象监视器上等待的所有线程</td><td>唤醒多个线程</td></tr><tr><td>yiled</td><td>停止当前线程，让同等优先权的线程运行</td><td>用Thread类调用</td></tr><tr><td>join</td><td>使当前线程停下来等待，直至另一个调用join方法的线程终止</td><td>用线程对象调用</td></tr></tbody></table><img src="https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_Qfy2ACkrLAAD2DLkc2qw212.png" alt="img" style="zoom:67%;" /><h4 id="3、阻塞唤醒过程"><a href="#3、阻塞唤醒过程" class="headerlink" title="3、阻塞唤醒过程"></a><strong>3、阻塞唤醒过程</strong></h4><p><strong>阻塞：</strong></p><p>​这三个方法的调用都会使当前线程阻塞。该线程将会被放置到对该Object的请求等待队列中，然后让出当前对Object所拥有的所有的同步请求。线程会一直暂停所有线程调度，直到下面其中一种情况发生：</p><p>　　　　① 其他线程调用了该Object的notify方法，而该线程刚好是那个被唤醒的线程；</p><p>　　　　② 其他线程调用了该Object的notifyAll方法；</p><p><strong>唤醒：</strong></p><p>​线程将会从等待队列中移除，重新成为可调度线程。它会与其他线程以常规的方式竞争对象同步请求。<strong>一旦它重新获得对象的同步请求，所有之前的请求状态都会恢复，也就是线程调用wait的地方的状态。线程将会在之前调用wait的地方继续运行下去。</strong></p><p><strong>为什么要出现在同步代码块中：</strong></p><p>​由于<code>wait()属于Object方法，调用之后会强制释放当前对象锁，所以在wait()</code> 调用时必须拿到当前对象的监视器monitor对象。因此，wait()方法在同步方法&#x2F;代码块中调用。</p><h4 id="4、wait和sleep区别"><a href="#4、wait和sleep区别" class="headerlink" title="4、wait和sleep区别"></a><strong>4、wait和sleep区别</strong></h4><ul><li><p>wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。</p></li><li><p>wait 方法会主动释放 monitor 锁，在同步代码中执行 sleep 方法时，并不会释放 monitor 锁。</p></li><li><p>wait 方法意味着永久等待，直到被中断或被唤醒才能恢复，不会主动恢复，sleep 方法中会定义一个时间，时间到期后会主动恢复。</p></li><li><p>wait&#x2F;notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。</p></li></ul><h4 id="5、创建线程方式"><a href="#5、创建线程方式" class="headerlink" title="5、创建线程方式"></a>5、创建线程方式</h4><p><strong>实现 Runnable 接口</strong>（优先使用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;System.out.println(<span class="string">&#x27;用实现Runnable接口实现线程&#x27;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现Callable接口</strong>（有返回值可抛出异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承Thread类</strong>（java不支持多继承）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;System.out.println(<span class="string">&#x27;用Thread类实现线程&#x27;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用线程池</strong>（底层都是实现run方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="literal">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> + poolNumber.getAndIncrement() +<span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,namePrefix + threadNumber.getAndIncrement(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon()) t.setDaemon(<span class="literal">false</span>);  <span class="comment">//是否守护线程</span></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); <span class="comment">//线程优先级</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>优点：通过复用已创建的线程，<strong>降低资源损耗</strong>、线程可以直接处理队列中的任务<strong>加快响应速度</strong>、同时便于<strong>统一监控和管理</strong>。</p><h4 id="1、线程池构造函数"><a href="#1、线程池构造函数" class="headerlink" title="1、线程池构造函数"></a><strong>1、线程池构造函数</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程池构造函数7大参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">    TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程池大小</td></tr><tr><td>maximumPoolSize</td><td>最大线程池大小</td></tr><tr><td>keepAliveTime</td><td>线程池中超过 corePoolSize 数目的空闲线程最大存活时间；</td></tr><tr><td>TimeUnit</td><td>keepAliveTime 时间单位</td></tr><tr><td>workQueue</td><td>阻塞任务队列</td></tr><tr><td>threadFactory</td><td>新建线程工厂</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略。当提交任务数超过 maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处理</td></tr></tbody></table><h4 id="2、线程处理任务过程："><a href="#2、线程处理任务过程：" class="headerlink" title="2、线程处理任务过程："></a><strong>2、线程处理任务过程：</strong></h4><img src="https://s0.lgstatic.com/i/image3/M01/78/50/Cgq2xl5zjxGAXOA-AABF0Dv8GMI518.png" alt="img" style="zoom: 67%;" /><ol><li>当线程池小于corePoolSize，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li><li>当线程池达到corePoolSize时，新提交任务将被放入 workQueue 中，等待线程池中任务调度执行。</li><li>当workQueue已满，且 maximumPoolSize 大于 corePoolSize 时，新提交任务会创建新线程执行任务。</li><li>当提交任务数超过 maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理。</li><li>当线程池中超过corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程 。</li></ol><h4 id="3、线程拒绝策略"><a href="#3、线程拒绝策略" class="headerlink" title="3、线程拒绝策略"></a><strong>3、线程拒绝策略</strong></h4><p>​线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。</p><p>JDK 内置的拒绝策略如下：</p><p>​<strong>AbortPolicy：</strong>直接抛出异常，阻止系统正常运行。可以根据业务逻辑选择重试或者放弃提交等策略。</p><p>​<strong>CallerRunsPolicy ：</strong>只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。</p><p>​不会造成任务丢失，同时减缓提交任务的速度，给执行任务缓冲时间。</p><p>​<strong>DiscardOldestPolicy ：</strong>丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p><p>​<strong>DiscardPolicy ：</strong>该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</p><h4 id="4、Execuors类实现线程池"><a href="#4、Execuors类实现线程池" class="headerlink" title="4、Execuors类实现线程池"></a><strong>4、Execuors类实现线程池</strong></h4><img src="https://s0.lgstatic.com/i/image3/M01/63/5A/CgpOIF4z1EiAFjNQAAAtVe5xjgQ999.png" alt="img" style="zoom: 50%;" /><ul><li><strong>newSingleThreadExecutor()：</strong>只有一个线程的线程池，任务是顺序执行，适用于一个一个任务执行的场景</li><li><strong>newCachedThreadPool()：</strong>线程池里有很多线程需要同时执行，60s内复用，适用执行很多短期异步的小程序或者负载较轻的服务</li><li><strong>newFixedThreadPool()：</strong>拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，适用执行长期的任务。</li><li><strong>newScheduledThreadPool()：</strong>用来调度即将执行的任务的线程池</li><li>**newWorkStealingPool()**：底层采用forkjoin的Deque，采用独立的任务队列可以减少竞争同时加快任务处理</li><li></li><li><img src="https://s0.lgstatic.com/i/image2/M01/AF/80/CgoB5l3kzomAckv5AAAxf6FCPco696.png" alt="img" style="zoom:50%;" /></li></ul><p><strong>因为以上方式都存在弊端：</strong></p><p>​FixedThreadPool 和 SingleThreadExecutor ： 允许请求的<strong>队列⻓度</strong>为 Integer.MAX_VALUE，会导致OOM。<br>​CachedThreadPool 和 ScheduledThreadPool ： 允许创建的<strong>线程数量</strong>为 Integer.MAX_VALUE，会导致OOM。</p><p>手动创建的线程池底层使用的是ArrayBlockingQueue可以防止OOM。</p><h4 id="5、线程池大小设置"><a href="#5、线程池大小设置" class="headerlink" title="5、线程池大小设置"></a><strong>5、线程池大小设置</strong></h4><ul><li>CPU 密集型（n+1）</li></ul><p>​CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。</p><p>​CPU 密集型任务尽可能的少的线程数量，一般为 CPU 核数 + 1 个线程的线程池。</p><ul><li>IO 密集型（2*n）</li></ul><p>​由于 IO 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 CPU * 2 </p><p>​也可以使用公式：CPU 核心数 *（1+平均等待时间&#x2F;平均工作时间）。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="1、乐观锁，CAS思想"><a href="#1、乐观锁，CAS思想" class="headerlink" title="1、乐观锁，CAS思想"></a><strong>1、乐观锁，CAS思想</strong></h4><p><strong>java乐观锁机制：</strong></p><p>​乐观锁体现的是悲观锁的反面。它是一种积极的思想，它总是认为数据是不会被修改的，所以是不会对数据上锁的。但是乐观锁在更新的时候会去判断数据是否被更新过。乐观锁的实现方案一般有两种（版本号机制和CAS）。乐观锁适用于<strong>读多写少的场景，这样可以提高系统的并发量</strong>。在Java中 <strong>java.util.concurrent.atomic</strong>下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>　　乐观锁，大多是基于数据版本  (Version)记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p><strong>CAS思想：</strong></p><p>​CAS就是compare and swap（<strong>比较交换</strong>），是一种很出名的无锁的算法，就是可以不使用锁机制实现线程间的同步。使用CAS线程是不会被阻塞的，所以又称为非阻塞同步。CAS算法涉及到三个操作：</p><p>​需要读写内存值V；进行比较的值A；准备写入的值B</p><p>​当且仅当V的值等于A的值等于V的值的时候，才用B的值去更新V的值，否则不会执行任何操作（比较和替换是一个原子操作-A和V比较，V和B替换），一般情况下是一个<strong>自旋操作</strong>，即<strong>不断重试</strong></p><p><strong>缺点：</strong></p><p>​<a href="https://www.zhihu.com/question/23281499/answer/854522984">ABA问题-知乎</a></p><p>​高并发的情况下，很容易发生并发冲突，如果CAS一直失败，那么就会一直重试，浪费CPU资源</p><p><strong>原子性：</strong></p><p>​功能限制CAS是能保证单个变量的操作是原子性的，在Java中要配合使用volatile关键字来保证线程的安全；当涉及到多个变量的时候CAS无能为力；除此之外CAS实现需要硬件层面的支持，在Java的普通用户中无法直接使用，只能<strong>借助atomic包下的原子类</strong>实现，灵活性受到了限制</p><h4 id="2、synchronized底层实现"><a href="#2、synchronized底层实现" class="headerlink" title="2、synchronized底层实现"></a><strong>2、synchronized底层实现</strong></h4><p><strong>使用方法：</strong>主要的三种使⽤⽅式</p><p>​<strong>修饰实例⽅法:</strong> 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁</p><p>​<strong>修饰静态⽅法:</strong> 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀个实例对象，是类成员。</p><p>​<strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。</p><p>​<strong>总结：</strong>synchronized锁住的资源只有两类：一个是<strong>对象</strong>，一个是<strong>类</strong>。</p><p><strong>底层实现：</strong></p><p>​对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由<code>Mark Word</code> 组成，<strong>其中<code>Mark Word</code>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</strong>。</p><p>​锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁</strong>，其中无锁就是一种状态了。锁的类型和状态在对象头<code>Mark Word</code>中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的<code>Mark Word</code>数据。</p><p>​同步代码块是利用 monitorenter 和 monitorexit 指令实现的，而同步方法则是利用 flags 实现的。</p><h4 id="3、ReenTrantLock底层实现"><a href="#3、ReenTrantLock底层实现" class="headerlink" title="3、ReenTrantLock底层实现"></a><strong>3、ReenTrantLock底层实现</strong></h4><p>​由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能</p><p><strong>使用方法：</strong></p><p>​基于API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成</p><p><strong>底层实现：</strong></p><p>​ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p><p><strong>和synchronized区别：</strong></p><p>​1、<strong>底层实现</strong>：synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁。</p><p>​2、<strong>实现原理****：synchronized 的实现涉及到</strong>锁的升级<strong>，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁；ReentrantLock实现则是通过利用</strong>CAS**（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。</p><p>​3、<strong>是否可手动释放：</strong>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致<strong>死锁现象</strong>。</p><p>​4、<strong>是否可中断</strong>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p><p>​5、<strong>是否公平锁</strong>synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁,公平锁性能非常低。</p><h4 id="4、公平锁和非公平锁区别"><a href="#4、公平锁和非公平锁区别" class="headerlink" title="4、公平锁和非公平锁区别"></a><strong>4、公平锁和非公平锁区别</strong></h4><p><strong>公平锁：</strong></p><p>​公平锁自然是遵循<strong>FIFO</strong>（先进先出）原则的，先到的线程会优先获取资源，后到的会进行排队等待</p><p>​<strong>优点：</strong>所有的线程都能得到资源，不会饿死在队列中。适合大任务</p><p>​<strong>缺点：</strong>吞吐量会下降，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大</p><p><strong>非公平锁：</strong></p><p>​多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><p>​<strong>优点：</strong>可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</p><p>​<strong>缺点：</strong>你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁</p><img src="https://s0.lgstatic.com/i/image3/M01/02/7D/Ciqah157DAiAK_DJAAC0JawhGp4730.png" alt="img" style="zoom:67%;" /><p><strong>公平锁效率低原因：</strong></p><p>​公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在 wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面线程。这种情况下相比较非公平锁多了一次<strong>挂起和唤醒</strong>。</p><p>​<strong>线程切换的开销</strong>，其实就是非公平锁效率高于公平锁的原因，因为<strong>非公平锁减少了线程挂起的几率</strong>，后来的线程有一定几率逃离被挂起的开销。</p><h4 id="5、使用层面锁优化"><a href="#5、使用层面锁优化" class="headerlink" title="5、使用层面锁优化"></a><strong>5、使用层面锁优化</strong></h4><p>​【1】<strong>减少锁的时间：</strong><br>​不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</p><p>​【2】<strong>减少锁的粒度：</strong><br>​它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；java中很多数据结构都是采用这种方法提高并发操作的效率，比如：</p><p>​<strong>ConcurrentHashMap：</strong></p><p>​java中的ConcurrentHashMap在jdk1.8之前的版本，使用一个Segment 数组：Segment&lt; K,V &gt;[] segments</p><p>​Segment继承自ReenTrantLock，所以每个Segment是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</p><p>​【3】<strong>锁粗化：</strong><br>​大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度; </p><p>​假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；</p><p>​【4】<strong>使用读写锁：</strong></p><p>​ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可并发读，写操作使用写锁，只能单线程写；</p><p>​【5】<strong>使用CAS：</strong></p><p>​如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择；</p><h4 id="6、系统层面锁优化"><a href="#6、系统层面锁优化" class="headerlink" title="6、系统层面锁优化"></a>6、系统层面锁优化</h4><p><strong>自适应自旋锁：</strong></p><p>​自旋锁可以避免等待竞争锁进入阻塞挂起状态被唤醒造成的<strong>内核态和用户态之间的切换</strong>的损耗，它们只需要等一等（自旋），但是如果锁被其他线程长时间占用，一直不释放CPU，死等会带来更多的性能开销；自旋次数默认值是10</p><p>​对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的<strong>自旋时间及锁的拥有者的状态</strong>来决定，这就解决了自旋锁带来的缺点</p><p><strong>锁消除：</strong></p><p>​锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。Netty中无锁化设计pipeline中channelhandler会进行锁消除的优化。</p><p><strong>锁升级：</strong></p><p>​<strong>偏向锁：</strong></p><p>​如果线程已经占有这个锁，当他在次试图去获取这个锁的时候，他会已最快的方式去拿到这个锁，而不需要在进行一些monitor操作，因为在大部分情况下是没有竞争的，所以使用偏向锁是可以提高性能的；</p><p>​<strong>轻量级锁：</strong></p><p>​在竞争不激烈的情况下，通过CAS避免线程上下文切换，可以显著的提高性能。</p><p>​<strong>重量级锁：</strong></p><p>​重量级锁的加锁、解锁过程造成的损耗是固定的，重量级锁适合于竞争激烈、高并发、同步块执行时间长的情况。</p><h4 id="7、ThreadLocal原理"><a href="#7、ThreadLocal原理" class="headerlink" title="7、ThreadLocal原理"></a><strong>7、ThreadLocal原理</strong></h4><p><strong>ThreadLocal简介：</strong></p><p>​通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现每⼀个线程都有⾃⼰的<br>专属本地变量该如何解决呢？ JDK中提供的 ThreadLocal 类正是为了解决这样的问题。类似操作系统中的TLAB</p><p><strong>原理：</strong></p><p>​首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。</p><p>​最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</p><p>​我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。例如下面的 </p><p><strong>如何使用：</strong></p><p>​1）存储用户Session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br></pre></td></tr></table></figure><p>​2）解决线程安全的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; format1 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;()</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal内存泄漏的场景</strong> </p><p>​实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，⽽ value 是强引⽤。弱引用的特点是，如果这个对象持有弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p><p>​所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。 假如我们不做任何措施的话，value 永远⽆法被GC 回收，如果线程长时间不被销毁，可能会产⽣内存泄露。</p><img src="https://s0.lgstatic.com/i/image3/M01/68/C4/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png" alt="img" style="zoom:67%;" /><p>​ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。因此使⽤完ThreadLocal ⽅法后，<strong>最好⼿动调⽤ remove() ⽅法</strong>。</p><h4 id="8、HashMap线程安全"><a href="#8、HashMap线程安全" class="headerlink" title="8、HashMap线程安全"></a><strong>8、HashMap线程安全</strong></h4><p>​<strong>死循环造成 CPU 100%</strong></p><p>​HashMap 有可能会发生死循环并且造成  CPU 100% ，这种情况发生最主要的原因就是在<strong>扩容</strong>的时候，也就是内部<strong>新建新的 HashMap</strong> 的时候，扩容的逻辑会<strong>反转散列桶中的节点顺序</strong>，当有多个线程同时进行扩容的时候，由于 HashMap 并非线程安全的，所以如果<strong>两个线程同时反转的话，便可能形成一个循环</strong>，并且这种循环是链表的循环，相当于 A 节点指向 B 节点，B 节点又指回到 A 节点，这样一来，在下一次想要获取该 key 所对应的 value 的时候，便会在遍历链表的时候发生永远无法遍历结束的情况，也就发生 CPU 100% 的情况。</p><p>​所以综上所述，HashMap 是线程不安全的，在多线程使用场景中推荐使用线程安全同时性能比较好的 ConcurrentHashMap。</p><h4 id="9、String不可变原因"><a href="#9、String不可变原因" class="headerlink" title="9、String不可变原因"></a>9、String不可变原因</h4><ol><li><p>可以使用<strong>字符串常量池</strong>，多次创建同样的字符串会指向同一个内存地址</p></li><li><p>可以很方便地用作 <strong>HashMap 的 key</strong>。通常建议把不可变对象作为 HashMap的 key</p></li><li><p>hashCode生成后就不会改变，使用时无需重新计算</p></li><li><p>线程安全，因为具备不变性的对象一定是线程安全的</p></li></ol><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>​Java 内存模型（Java Memory Model，JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p><img src="https://s0.lgstatic.com/i/image3/M01/7A/05/Cgq2xl54fTKALhevAAB_l3axT_o532.png" alt="img"></p><p>​JMM 是一种规范，是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</p><p><strong>原子性：</strong></p><p>​在 Java 中，为了保证原子性，提供了两个高级的字节码指令 Monitorenter 和 Monitorexit。这两个字节码，在 Java 中对应的关键字就是 Synchronized。因此，在 Java 中可以使用 Synchronized 来保证方法和代码块内的操作是原子性的。</p><p><strong>可见性：</strong></p><p>​Java 中的 Volatile 关键字修饰的变量在被修改后可以立即同步到主内存。被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用 Volatile 来保证多线程操作时变量的可见性。除了 Volatile，Java 中的 Synchronized 和 Final 两个关键字也可以实现可见性。只不过实现方式不同</p><p><strong>有序性</strong></p><p>​在 Java 中，可以使用 Synchronized 和 Volatile 来保证多线程之间操作的有序性。区别：Volatile 禁止指令重排。Synchronized 保证同一时刻只允许一条线程操作。</p><h4 id="1、volatile底层实现"><a href="#1、volatile底层实现" class="headerlink" title="1、volatile底层实现"></a><strong>1、volatile底层实现</strong></h4><p><strong>作用：</strong></p><p>​保证数据的“可见性”：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p><p>​禁止指令重排：在多线程操作情况下，指令重排会导致计算结果不一致</p><p><strong>底层实现：</strong></p><p>​“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>　　lock前缀指令实际上相当于一个<strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；</p><p>　　2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><p><strong>单例模式中volatile的作用：</strong></p><p>防止代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123; <span class="comment">//减少加锁的损耗</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>) <span class="comment">//确认是否初始化完成</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、AQS思想"><a href="#2、AQS思想" class="headerlink" title="2、AQS思想"></a><strong>2、AQS思想</strong></h4><p>​AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器，是⼀个⽤来构建锁和同步器的框架，使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，如：基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore需解决的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">状态的原子性管理</span><br><span class="line">线程的阻塞与解除阻塞</span><br><span class="line">队列的管理</span><br></pre></td></tr></table></figure><p>​AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤<strong>CLH（虚拟的双向队列）</strong>队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。</p><p><strong>lock：</strong></p><p>​是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。默认为非公平锁，但可以初始化为公平锁； 通过方法 lock()与 unlock()来进行加锁与解锁操作；</p><p><strong>CountDownLatch：</strong></p><p>​通过计数法（倒计时器），让一些线程堵塞直到另一个线程完成一系列操作后才被唤醒；该⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。具体可以使用countDownLatch.await()来等待结果。多用于多线程信息汇总。</p><p><strong>CompletableFuture：</strong></p><p>​通过设置参数，可以完成CountDownLatch同样的多平台响应问题，但是可以针对其中部分返回结果做更加灵活的展示。</p><p><strong>CyclicBarrier：</strong></p><p>​字面意思是可循环(Cyclic)使用的屏障（Barrier）。他要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。可以用于批量发送消息队列信息、异步限流。</p><p><strong>Semaphore：</strong></p><p>​信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。SpringHystrix限流的思想</p><h4 id="3、happens-before"><a href="#3、happens-before" class="headerlink" title="3、happens-before"></a>3、happens-before</h4><p>​用来描述和可见性相关问题：如果第一个操作 happens-before 第二个操作，那么我们就说第一个操作对于第二个操作是可见的</p><p>​常见的happens-before：volatile 、锁、线程生命周期。</p><h1 id="四、MySQL篇"><a href="#四、MySQL篇" class="headerlink" title="四、MySQL篇"></a>四、MySQL篇</h1><h3 id="WhyMysql？"><a href="#WhyMysql？" class="headerlink" title="WhyMysql？"></a>WhyMysql？</h3><p>NoSQL数据库四大家族 </p><ul><li>列存储 Hbase</li><li>K-V存储 Redis</li><li>图像存储 Neo4j</li><li>文档存储 MongoDB</li></ul><p>云存储OSS</p><h4 id="海量Aerospike"><a href="#海量Aerospike" class="headerlink" title="海量Aerospike"></a>海量Aerospike</h4><p>​Aerospike（简称AS）是一个分布式，可扩展的键值存储的NoSQL<strong>数据库</strong>。T级别大数据高并发的结构化<strong>数据存储，</strong>采用混合架构，索引存储在内存中，而数据可存储在机械硬盘(HDD)或固态硬盘(SSD) 上，读写操作达微妙级，99%的响应可在1毫秒内实现。</p><table><thead><tr><th></th><th>Aerospike</th><th>Redis</th></tr></thead><tbody><tr><td>类型</td><td>Nosql数据库</td><td>缓存</td></tr><tr><td>线程数</td><td>多线程</td><td>单线程</td></tr><tr><td>数据分片</td><td>自动处理相当于分片</td><td>提供分片算法、平衡各分片数据</td></tr><tr><td>数据扩容</td><td>动态增加数据卷平衡流量</td><td>需停机</td></tr><tr><td>数据同步</td><td>设置复制因子后可以透明的完成故障转移</td><td>手动故障转移和数据同步</td></tr><tr><td>载体</td><td>内存存储索引+SSD存储数据</td><td>内存</td></tr></tbody></table><p>​Aerospike作为一个大容量的NoSql解决方案，适合对<strong>容量要求比较大，QPS相对低</strong>一些的场景，主要用在广告行业，<strong>个性化推荐厂告</strong>是建立在了和掌握消费者独特的偏好和习性的基础之上，对消费者的购买需求做出准确的预测或引导，在合适的位置、合适的时间，以合适的形式向消费者呈现与其需求高度吻合的广告，以此来促进用户的消费行为。</p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmam43b44bj30d90d4aa7.jpg" alt="image-20210103170039711" style="zoom:50%;" /><p>​（ETL数据仓库技术）抽取（extract）、转换（transform）、加载（load）</p><ul><li><p>用户行为日志收集系统收集日志之后推送到ETL做数据的清洗和转换</p></li><li><p>把ETL过后的数据发送到推荐引擎计算每个消费者的推荐结果，其中推荐逻辑包括规则和算法两部分</p></li><li><p>收集用户最近浏览、最长停留等特征，分析商品相似性、用户相似性、相似性等算法。</p></li><li><p>把推荐引擎的结果存入Aerospike集群中，并提供给广告投放引擎实时获取</p><p>分别通过HDFS和HBASE对日志进行离线和实时的分析，然后把用户画像的标签(tag : 程序猿、宅男…)结果存入高性能的Nosql数据库Aerospike中，同时把数据备份到异地数据中心。前端广告投放请求通过决策引擎（投放引擎）向用户画像数据库中读取相应的用户画像数据，然后根据竞价算法出价进行竞价。竞价成功之后就可以展现广告了。而在竞价成功之后，具体给用户展现什么样的广告，就是有上面说的个性化推荐广告来完成的。</p></li></ul><table><thead><tr><th></th><th>Aerospike</th><th>Mysql</th></tr></thead><tbody><tr><td>库名</td><td>Namespace</td><td>Database</td></tr><tr><td>表名</td><td>Set</td><td>Table</td></tr><tr><td>记录</td><td>Bin</td><td>Column</td></tr><tr><td>字段</td><td>Record</td><td>Row</td></tr><tr><td>索引</td><td>key 、 pk 、kv</td><td>pk</td></tr></tbody></table><h4 id="图谱Neo4j"><a href="#图谱Neo4j" class="headerlink" title="图谱Neo4j"></a>图谱Neo4j</h4><blockquote><p>Neo4j是一个开源基于java开发的图形noSql数据库，它将结构化数据存储在图中而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。程序数据是在一个面向对象的、灵活的网络结构下，而不是严格的表中，但具备完全的事务特性、企业级的数据库的所有好处。</p></blockquote><p>一种基于图的数据结构，由节点(Node)和边(Edge)组成。其中节点即实体，由一个全局唯一的ID标示，边就是关系用于连接两个节点。通俗地讲，知识图谱就是把所有不同种类的信息，连接在一起而得到的一个关系网络。知识图谱提供了从“关系”的角度去分析问题的能力。</p><p>互联网、大数据的背景下，谷歌、百度、搜狗等搜索引擎纷纷基于该背景，创建自己的知识图<strong>Knowledge Graph（谷歌</strong>）、<strong>知心（百度）</strong>和<strong>知立方（搜狗）</strong>，主要用于改进搜索质量。</p><p>自己项目主要用作好友推荐，图数据库(Graph database)指的是以图数据结构的形式来存储和查询数据的数据库。关系图谱中，关系的组织形式采用的就是图结构，所以非常适合用图库进行存储。</p><ul><li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaq0j9otdj30pz0en0vm.jpg" alt="image-20210103191540372"></p><p>优势总结:</p></li><li><p>性能上，使用cql查询，对长程关系的查询速度快</p></li><li><p>擅于发现隐藏的关系，例如通过判断图上两点之间有没有走的通的路径，就可以发现事物间的关联</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaqc75y6bj30wc0d60u4.jpg" alt="image-20210103192653004"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询三层级关系节点如下：with可以将前面查询结果作为后面查询条件</span></span><br><span class="line">match (na:Person)-[re]-(nb:Person) where na.name=<span class="string">&quot;林婉儿&quot;</span> WITH na,re,nb <span class="title function_">match</span> <span class="params">(nb:Person)</span>- [re2:Friends]-&gt;(nc:Person) <span class="keyword">return</span> na,re,nb,re2,nc</span><br><span class="line"><span class="comment">// 直接拼接关系节点查询</span></span><br><span class="line">match data=(na:Person&#123;name:<span class="string">&quot;范闲&quot;</span>&#125;)-[re]-&gt;(nb:Person)-[re2]-&gt;(nc:Person) <span class="keyword">return</span> data</span><br><span class="line"><span class="comment">// 使用深度运算符</span></span><br><span class="line">显然使用以上方式比较繁琐,可变数量的关系-&gt;节点可以使用-[:TYPE*minHops..maxHops]-。</span><br><span class="line">match data=(na:Person&#123;name:<span class="string">&quot;范闲&quot;</span>&#125;)-[*<span class="number">1.</span><span class="number">.2</span>]-(nb:Person) <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h4 id="文档MongoDB"><a href="#文档MongoDB" class="headerlink" title="文档MongoDB"></a><strong>文档MongoDB</strong></h4><blockquote><p>MongoDB 是一个基于分布式文件存储的数据库，是非关系数据库中功能最丰富、最像关系数据库的。在高负载的情况下，通过添加更多的节点，可以保证服务器性能。由 C++ 编写，可以为 WEB 应用提供可扩展、高性能、易部署的数据存储解决方案。</p></blockquote><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaqyp75qsj312q0i8q5f.jpg" alt="image-20210103194830654" style="zoom:80%;" /><p><strong>什么是BSON</strong></p><blockquote><p>{key:value,key2:value2}和Json类似，是一种二进制形式的存储格式，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，比如 value包括字符串,double,Array,DateBSON可以做为网络数据交换的一种存储形式,它的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p></blockquote><p>BSON有三个特点：轻量性、可遍历性、高效性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 查询 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开*/</span><br><span class="line">db.collection.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br><span class="line">/* 更新 $set ：设置字段值 $unset :删除指定字段 $inc：对修改的值进行自增*/</span><br><span class="line">db.collection.update(&#123;where&#125;,&#123;$set:&#123;字段名:值&#125;&#125;,&#123;multi:true&#125;)</span><br><span class="line">/* 删除 justOne :如果设为true，只删除一个文档，默认false，删除所有匹配条件的文档*/</span><br><span class="line">db.collection.remove(&#123;where&#125;, &#123;justOne: &lt;boolean&gt;, writeConcern: &lt;回执&gt; &#125; )</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><p><strong>文档结构的存储方式，能够更便捷的获取数据。</strong></p><p>对于一个层级式的数据结构来说，使用扁平式的，表状的结构来查询保存数据非常的困难。</p></li><li><p><strong>内置GridFS，支持大容量的存储。</strong></p><p>GridFS是一个出色的分布式文件系统，支持海量的数据存储，满足对大数据集的快速范围查询。</p></li><li><p><strong>性能优越</strong></p><p>千万级别的文档对象，近10G的数据，对有索引的ID的查询 不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在牛逼。写入性能同样很令人满意，同样写入百万级别的数据，mongodb基本10分钟以下可以解决。</p></li></ul><p>缺点：</p><ul><li>不支持事务</li><li>磁盘占用空间大</li></ul><p>MySQL 8.0 版本</p><p><strong>1. 性能</strong>：MySQL 8.0 的速度要比 MySQL 5.7 快 2 倍。</p><p><strong>2. NoSQL</strong>：MySQL 从 5.7 版本开始提供 NoSQL 存储功能，在 8.0 版本中nosql得到了更大的改进。</p><p><strong>3. 窗口函数</strong>：实现若干新的查询方式。窗口函数与 SUM()、COUNT() 这种集合函数类似，但它不会将多行查询结果合并为一行，而是将结果放回多行当中，即窗口函数不需要 GROUP BY。</p><p><strong>4. 隐藏索引</strong>：在 MySQL 8.0 中，索引可以被“隐藏”和“显示”。当对索引进行隐藏时，它不会被查询优化器所使用。我们可以使用这个特性用于性能调试，例如我们先隐藏一个索引，然后观察其对数据库的影响。如果数据库性能有所下降，说明这个索引是有用的，然后将其“恢复显示”即可；如果数据库性能看不出变化，说明这个索引是多余的，可以考虑删掉。</p><h4 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a><strong>云存储</strong></h4><table><thead><tr><th></th><th>OSS</th><th>自建</th></tr></thead><tbody><tr><td>可靠性</td><td>可用性不低于99.995%<br />数据设计持久性不低于99.9999999999%（12个9）</td><td>受限于硬件可靠性，易出问题，一旦出现磁盘坏道，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。</td></tr><tr><td>安全</td><td>服务端加密、客户端加密、防盗链、IP黑白名单等。多用户资源隔离机制，支持异地容灾机制。</td><td>需要另外购买清洗和黑洞设备。需要单独实现安全机制。</td></tr><tr><td>成本</td><td>多线BGP骨干网络，无带宽限制，上行流量免费。无需运维人员与托管费用，0成本运维。</td><td>单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容。需专人运维，成本高。</td></tr></tbody></table><p><strong>使用步骤</strong></p><p>​1、开通服务</p><p>​2、创建存储空间</p><p>​3、上传文件、下载文件、删除文件</p><p>​4、域名绑定、日志记录</p><p>​5、根据开放接口进行鉴权访问</p><p><strong>功能</strong></p><p>​图片编辑（裁剪、模糊、水印）</p><p>​视频截图</p><p>​音频转码、视频修复</p><p><strong>CDN加速</strong></p><p>​对象存储OSS与阿里云CDN服务结合，可优化静态热点文件下载加速的场景（即同一地区大量用户同时下载同一个静态文件的场景）。可以将OSS的存储空间（Bucket）作为源站，利用阿里云CDN将源内容发布到边缘节点。当大量终端用户重复访问同一文件时，可以直接从边缘节点获取已缓存的数据，提高访问的响应速度</p><h4 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a><strong>FastDFS</strong></h4><blockquote><p><strong>开源的轻量级分布式文件系统</strong>。它对文件进行管理，功能包括：<strong>文件存储、文件同步、文件访问</strong>（文件上传、文件下载）等，解决了<strong>大容量存储和负载均衡</strong>的问题。使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。如<strong>相册网站、视频网站</strong>等</p></blockquote><p><strong>扩展能力:</strong> 支持水平扩展，可以动态扩容；</p><p><strong>高可用性:</strong> 一是整个文件系统的可用性，二是数据的完整和一致性；</p><p><strong>弹性存储:</strong> 可以根据业务需要灵活地增删存储池中的资源，而不需要中断系统运行。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfhjkvo59j30zu0b4dib.jpg" alt="image-20210107221022658"></p><p>特性</p><ul><li>和流行的web server无缝衔接，FastDFS已提供apache和nginx扩展模块</li><li>文件ID由FastDFS生成，作为文件访问凭证，FastDFS不需要传统的name server</li><li>分组存储，灵活简洁、对等结构，不存在单点</li><li>文件不分块存储，上传的文件和OS文件系统中的文件一一对应</li><li>中、小文件均可以很好支持，支持海量小文件存储</li><li>支持相同内容的文件只保存一份，节约磁盘空间</li><li>支持多块磁盘，支持单盘数据恢复</li><li>支持在线扩容 支持主从文件</li><li>下载文件支持多线程方式，支持断点续传</li></ul><p><strong>组成</strong></p><ul><li><p><strong>客户端（client）</strong></p><p>通过专有接口，使用TCP&#x2F;IP协议与跟踪器服务器或存储节点进行数据交互。</p></li><li><p><strong>跟踪器（tracker）</strong> </p><p>Trackerserver作用是负载均衡和调度，通过Tracker server在文件上传时可以根据策略找到文件上传的地址。Tracker在访问上起负载均衡的作用。</p></li><li><p><strong>存储节点（storage）</strong></p><p>Storageserver作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server<strong>没有实现自己的文件系统而是利用操作系统的文件系统来管理文件</strong>。存储节点中的服务器均可以<strong>随时增加或下线而不会影响线上服务</strong>。</p></li></ul><p><strong>上传</strong></p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfhvk0wwzj30ue0h4dlw.jpg" alt="image-20210107222155291" style="zoom:50%;" /><p><strong>下载</strong></p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfhww8zmfj30uw0g6n37.jpg" alt="image-20210107222312338" style="zoom:50%;" /><p><strong>断点续传</strong></p><p>​续传涉及到的文件大小MD5不会改变。续传流程与文件上传类似，先<strong>定位到源storage</strong>，完成完整或部分上传，再<strong>通过binlog进行同group内server文件同步</strong>。</p><p><strong>配置优化</strong></p><p>配置文件：tracker.conf 和 storage.conf </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FastDFS采用内存池的做法。 </span></span><br><span class="line"><span class="comment">// v5.04对预分配采用增量方式，tracker一次预分配 1024个，storage一次预分配256个。 </span></span><br><span class="line">max_connections = <span class="number">10240</span></span><br><span class="line"><span class="comment">// 根据实际需要将 max_connections 设置为一个较大的数值，比如 10240 甚至更大。</span></span><br><span class="line"><span class="comment">// 同时需要将一个进程允许打开的最大文件数调大</span></span><br><span class="line">vi /etc/security/limits.conf 重启系统生效 </span><br><span class="line">* soft nofile <span class="number">65535</span> </span><br><span class="line">* hard nofile <span class="number">65535</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work_threads = <span class="number">4</span> </span><br><span class="line"><span class="comment">// 说明：为了避免CPU上下文切换的开销，以及不必要的资源消耗，不建议将本参数设置得过大。</span></span><br><span class="line"><span class="comment">// 公式为： work_threads + (reader_threads + writer_threads) = CPU数</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于单盘挂载方式，磁盘读写线程分 别设置为 1即可 </span></span><br><span class="line"><span class="comment">// 如果磁盘做了RAID，那么需要酌情加大读写线程数，这样才能最大程度地发挥磁盘性能</span></span><br><span class="line">disk_rw_separated：磁盘读写是否分离 </span><br><span class="line">disk_reader_threads：单个磁盘读线程数 </span><br><span class="line">disk_writer_threads：单个磁盘写线程数 </span><br></pre></td></tr></table></figure><p><strong>避免重复</strong></p><p>​如何避免文件重复上传 解决方案 上传成功后计算文件对应的MD5然后<strong>存入MySQL</strong>,添加文件时把<strong>文件MD5和之前存入MYSQL中的存储的信息对比</strong> 。DigestUtils.md5DigestAsHex(bytes)。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="1、事务4大特性"><a href="#1、事务4大特性" class="headerlink" title="1、事务4大特性"></a><strong>1、事务4大特性</strong></h4><p><strong>事务4大特性：</strong>原子性、一致性、隔离性、持久性</p><p>​<strong>原⼦性：</strong> 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么全不执行</p><p>​<strong>一致性：</strong> 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；</p><p>​<strong>隔离性：</strong> 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；</p><p>​<strong>持久性：</strong> ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p><p><strong>实现保证：</strong></p><p>​MySQL的存储引擎InnoDB使用重做日志保证一致性与持久性，回滚日志保证原子性，使用各种锁来保证隔离性。</p><h4 id="2、事务隔离级别"><a href="#2、事务隔离级别" class="headerlink" title="2、事务隔离级别"></a><strong>2、事务隔离级别</strong></h4><p><strong>读未提交：</strong>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p><strong>读已提交：</strong>允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</p><p><strong>可重复读：</strong>同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，会有幻读。</p><p><strong>串行化：</strong>最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰。</p><table><thead><tr><th>隔离级别</th><th>并发问题</th></tr></thead><tbody><tr><td>读未提交</td><td>可能会导致脏读、幻读或不可重复读</td></tr><tr><td>读已提交</td><td>可能会导致幻读或不可重复读</td></tr><tr><td>可重复读</td><td>可能会导致幻读</td></tr><tr><td>可串行化</td><td>不会产⽣⼲扰</td></tr></tbody></table><p>ms</p><h4 id="3、默认隔离级别-RR"><a href="#3、默认隔离级别-RR" class="headerlink" title="3、默认隔离级别-RR"></a><strong>3、默认隔离级别-RR</strong></h4><p><strong>默认隔离级别：</strong>可重复读；</p><p>​同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改；</p><p>​可重复读是有可能出现幻读的，如果要保证绝对的安全只能把隔离级别设置成SERIALIZABLE；这样所有事务都只能顺序执行，自然不会因为并发有什么影响了，但是性能会下降许多。</p><p>​第二种方式，使用MVCC解决<strong>快照读幻读问题</strong>（如简单select），读取的不是最新的数据。维护一个字段作为version，这样可以控制到每次只能有一个人更新一个版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id = ? and version = V</span><br><span class="line">update id from table_xx where id = ? and version = V+1</span><br></pre></td></tr></table></figure><p>​第三种方式，如果需要读最新的数据，可以通过GapLock+Next-KeyLock可以解决<strong>当前读幻读问题</strong>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id &gt; 100 for update;</span><br><span class="line">select id from table_xx where id &gt; 100 lock in share mode;</span><br></pre></td></tr></table></figure><h4 id="4、RR和RC使用场景"><a href="#4、RR和RC使用场景" class="headerlink" title="4、RR和RC使用场景"></a><strong>4、RR和RC使用场景</strong></h4><p>​事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。</p><table><thead><tr><th></th><th>RC</th><th>RR</th></tr></thead><tbody><tr><td>实现</td><td>多条查询语句会创建多个不同的ReadView</td><td>仅需要一个版本的ReadView</td></tr><tr><td>粒度</td><td>语句级读一致性</td><td>事务级读一致性</td></tr><tr><td>准确性</td><td>每次语句执行时间点的数据</td><td>第一条语句执行时间点的数据</td></tr></tbody></table><h4 id="5、行锁，表锁，意向锁"><a href="#5、行锁，表锁，意向锁" class="headerlink" title="5、行锁，表锁，意向锁"></a><strong>5、行锁，表锁，意向锁</strong></h4><p><strong>InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁</strong></p><p>​InnoDB按照不同的分类的锁：</p><p>​共享&#x2F;排它锁(Shared and Exclusive Locks)：行级别锁，</p><p>​意向锁(Intention Locks)，表级别锁</p><p>​间隙锁(Gap Locks)，锁定一个区间</p><p>​记录锁(Record Locks)，锁定一个行记录</p><p><strong>表级锁：（串行化）</strong></p><p>​Mysql中锁定 粒度最大的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p><p><strong>行级锁：（RR、RC）</strong></p><p>​Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种：</p><p>​<strong>记录锁（Record Lock）:</strong> 对索引项加锁，锁定<strong>符合条件的行</strong>。其他事务不能修改和删除加锁项；</p><p>​<strong>间隙锁（Gap Lock）:</strong> 对索引项之间的“间隙”加锁，锁定<strong>记录的范围</strong>，不包含索引项本身，其他事务不能在锁范围内插入数据。</p><p>​<strong>Next-key Lock：</strong> 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p><p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。</p><p><strong>共享锁</strong>（ shared lock, S ）锁允许持有锁读取行的事务。加锁时将自己和子节点全加S锁，父节点直到表头全加IS锁</p><p><strong>排他锁</strong>（ exclusive lock， X ）锁允许持有锁修改行的事务。 加锁时将自己和子节点全加X锁，父节点直到表头全加IX锁  </p><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p><table><thead><tr><th>互斥性</th><th>共享锁（S）</th><th>排它锁（X）</th><th>意向共享锁IS</th><th>意向排他锁IX</th></tr></thead><tbody><tr><td>共享锁（S）</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>排它锁（X）</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>意向共享锁IS</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>意向排他锁IX</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr></tbody></table><h4 id="6、MVCC多版本并发控制"><a href="#6、MVCC多版本并发控制" class="headerlink" title="6、MVCC多版本并发控制"></a><strong>6、MVCC多版本并发控制</strong></h4><p>​MVCC是一种多版本并发控制机制，通过事务的可见性看到自己预期的数据，能降低其系统开销.（RC和RR级别工作）</p><p>​InnoDB的MVCC,是通过在每行记录后面保存系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的，防止幻读的产生。</p><p>​1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.</p><p>​2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.</p><p>​3.简单的select快照度不会加锁，删改及select for update等需要当前读的场景会加锁</p><p>​原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。客观上，mysql使用的是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p><p><strong>版本链</strong></p><p>在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p><p><strong>trx_id</strong></p><p>这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。</p><p><strong>roll_pointer</strong></p><p>每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p><p>每次修改都会在版本链中记录。<strong>SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，</strong>提升了系统的性能。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="1、Innodb和Myisam引擎"><a href="#1、Innodb和Myisam引擎" class="headerlink" title="1、Innodb和Myisam引擎"></a><strong>1、Innodb和Myisam引擎</strong></h4><p><strong>Myisam：</strong>支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件</p><p><strong>Innodb：</strong>支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件</p><h4 id="2、哈希索引"><a href="#2、哈希索引" class="headerlink" title="2、哈希索引"></a><strong>2、哈希索引</strong></h4><p>​哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能</p><h4 id="3、B-树索引"><a href="#3、B-树索引" class="headerlink" title="3、B+树索引"></a><strong>3、B+树索引</strong></h4><p><strong>优点：</strong></p><p>​B+树的磁盘读写代价低，更少的查询次数，查询效率更加稳定，有利于对数据库的扫描</p><p>​B+树是B树的升级版，B+树只有叶节点存放数据，其余节点用来索引。索引节点可以全部加入内存，增加查询效率，叶子节点可以做双向链表，从而<strong>提高范围查找的效率，增加的索引的范围</strong></p><p>​在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树与B+树可以有多个子女，从几十到上千，可以降低树的高度。</p><p>​<strong>磁盘预读原理</strong>：将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p><h4 id="4、创建索引"><a href="#4、创建索引" class="headerlink" title="4、创建索引"></a>4、创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT]  INDEX  索引名 <span class="keyword">ON</span>  表名(字段名) [<span class="keyword">USING</span> 索引方法]；</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="keyword">UNIQUE</span>:可选。表示索引为唯一性索引。</span><br><span class="line">FULLTEXT:可选。表示索引为全文索引。</span><br><span class="line">INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</span><br><span class="line">索引名:可选。给创建的索引取一个新名称。</span><br><span class="line">字段名<span class="number">1</span>:指定索引对应的字段的名称，该字段必须是前面定义好的字段。</span><br><span class="line">注：索引方法默认使用B<span class="operator">+</span>TREE。</span><br></pre></td></tr></table></figure><h4 id="5、聚簇索引和非聚簇索引"><a href="#5、聚簇索引和非聚簇索引" class="headerlink" title="5、聚簇索引和非聚簇索引"></a><strong>5、聚簇索引和非聚簇索引</strong></h4><p>​<strong>聚簇索引：</strong>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据（<strong>主键索引</strong>）</p><p>​<strong>非聚簇索引：</strong>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置（<strong>辅助索引</strong>）</p><p>​聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p><h4 id="6、最左前缀问题"><a href="#6、最左前缀问题" class="headerlink" title="6、最左前缀问题"></a>6、最左前缀问题</h4><p>​最左前缀原则主要使用在联合索引中，联合索引的B+Tree是按照第一个关键字进行索引排列的。</p><p>​联合索引的底层是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p><p>​采用&gt;、&lt;等进行匹配都会导致后面的列无法走索引，因为通过以上方式匹配到的数据是不可知的。</p><h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><h4 id="1、SQL语句的执行过程"><a href="#1、SQL语句的执行过程" class="headerlink" title="1、SQL语句的执行过程"></a><strong>1、SQL语句的执行过程</strong></h4><p><strong>查询语句：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student  A where A.age=&#x27;18&#x27; and A.name=&#x27;张三&#x27;;</span><br></pre></td></tr></table></figure><img src="http://s0.lgstatic.com/i/image2/M01/8B/0F/CgotOV14ySKAMxohAAH2VHcAzkE612.png" alt="img" style="zoom: 67%;" /><p>结合上面的说明，我们分析下这个语句的执行流程：</p><p>①通过客户端&#x2F;服务器通信协议与 MySQL 建立连接。并查询是否有权限</p><p>②Mysql8.0之前开看是否开启缓存，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端；</p><p>③由解析器进行语法语义解析，并生成解析树。如查询是select、表名tb_student、条件是id&#x3D;’1’</p><p>④查询优化器生成执行计划。根据索引看看是否可以优化</p><p>⑤查询执行引擎执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。</p><h4 id="2、回表查询和覆盖索引"><a href="#2、回表查询和覆盖索引" class="headerlink" title="2、回表查询和覆盖索引"></a><strong>2、回表查询和覆盖索引</strong></h4><p><strong>普通索引</strong>（唯一索引+联合索引+全文索引）需要扫描两遍索引树</p><p>（1）先通过普通索引定位到主键值id&#x3D;5；</p><p>（2）在通过聚集索引定位到行记录；</p><p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p><p><strong>覆盖索引</strong>：主键索引&#x3D;&#x3D;聚簇索引&#x3D;&#x3D;覆盖索引</p><p>​如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。</p><p><strong>实现覆盖索引</strong>：常见的方法是，将被查询的字段，建立到联合索引里去。</p><h4 id="3、Explain及优化"><a href="#3、Explain及优化" class="headerlink" title="3、Explain及优化"></a>3、Explain及优化</h4><p>参考：<a href="https://www.jianshu.com/p/8fab76bbf448">https://www.jianshu.com/p/8fab76bbf448</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from staff;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | staff | ALL  | NULL          | 索引  | NULL    | NULL |    2 | NULL  |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p><strong>索引优化：</strong></p><p>​①最左前缀索引：like只用于’string%’，语句中的&#x3D;和in会动态调整顺序</p><p>​②唯一索引：唯一键区分度在0.1以上</p><p>​③无法使用索引：!&#x3D;  、is null 、 or、&gt;&lt; 、（<strong>5.7以后根据数量自动判定）in 、not in</strong></p><p>​④联合索引：避免select * ，查询列使用覆盖索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT uid From user Where gid = 2 order by ctime asc limit 10</span><br><span class="line">ALTER TABLE user add index idx_gid_ctime_uid(gid,ctime,uid) #创建联合覆盖索引，避免回表查询</span><br></pre></td></tr></table></figure><p><strong>语句优化：</strong></p><p>​①char固定长度查询效率高，varchar第一个字节记录数据长度</p><p>​②应该针对Explain中Rows增加索引</p><p>​③group&#x2F;order by字段均会涉及索引</p><p>​④Limit中分页查询会随着start值增大而变缓慢，通过子查询+表连接解决</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>  改进后的<span class="keyword">SQL</span>语句如下：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">where</span> id <span class="operator">&gt;=</span> ( <span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">1</span> ) limit <span class="number">10</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">inner</span> ori <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>) <span class="keyword">as</span> tmp <span class="keyword">on</span> tmp.id<span class="operator">=</span>ori.id;</span><br></pre></td></tr></table></figure><p>​⑤count会进行全表扫描，如果估算可以使用explain</p><p>​⑥delete删除表时会增加大量undo和redo日志， 确定删除可使用trancate</p><p><strong>表结构优化：</strong></p><p>​①单库不超过200张表</p><p>​②单表不超过500w数据</p><p>​③单表不超过40列</p><p>​④单表索引不超过5个</p><p><strong>数据库范式</strong> ：</p><p>​①第一范式（1NF）列不可分割</p><p>​②第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]</p><p>​③第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]</p><p><strong>配置优化：</strong></p><p>​配置连接数、禁用Swap、增加内存、升级SSD硬盘</p><h4 id="4、JOIN查询"><a href="#4、JOIN查询" class="headerlink" title="4、JOIN查询"></a>4、JOIN查询</h4><img src="https://image-static.segmentfault.com/276/780/2767807589-5c122586a23c4_articlex" style="align:left;zoom: 60%;" /><p><strong>left join(左联接)</strong> 返回包括左表中的所有记录和右表中关联字段相等的记录 </p><p><strong>right join(右联接)</strong> 返回包括右表中的所有记录和左表中关联字段相等的记录</p><p><strong>inner join(等值连接)</strong> 只返回两个表中关联字段相等的行</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><h4 id="1、主从复制过程"><a href="#1、主从复制过程" class="headerlink" title="1、主从复制过程"></a>1、主从复制过程</h4><p><strong>MySQl主从复制：</strong></p><ul><li><strong>原理</strong>：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。</li><li><strong>过程</strong>：从库开启一个I&#x2F;O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍</li><li><strong>优点</strong>：<ul><li>作为备用数据库，并且不影响业务</li><li>可做读写分离，一个写库，一个或多个读库，在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性</li></ul></li></ul><p><strong>binlog记录格式：</strong>statement、row、mixed</p><p>​基于语句statement的复制、基于行row的复制、基于语句和行（mix）的复制。其中基于row的复制方式更能保证主从库数据的一致性，但日志量较大，在设置时考虑磁盘的空间问题</p><h4 id="2、数据一致性问题"><a href="#2、数据一致性问题" class="headerlink" title="2、数据一致性问题"></a>2、数据一致性问题</h4><p>“主从复制有延时”，这个延时期间读取从库，可能读到不一致的数据。</p><p><strong>缓存记录写key法：</strong></p><p>​在cache里记录哪些记录发生过的写请求，来路由读主库还是读从库</p><p><strong>异步复制：</strong></p><p>​在异步复制中，主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能<strong>会造成数据的不一致</strong>。</p><p><strong>半同步复制：</strong></p><p>​当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，通过一份在主库的Binlog，另一份在其中一个从库的Relay-log，可以保证了数据的安全性和一致性。</p><p><strong>全同步复制：</strong></p><p>​指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的<strong>性能必然会收到严重的影响</strong>。</p><h4 id="3、集群架构"><a href="#3、集群架构" class="headerlink" title="3、集群架构"></a>3、集群架构</h4><p> <strong>Keepalived + VIP + MySQL 主从&#x2F;双主</strong></p><p>​当写节点 Master db1 出现故障时，由 MMM Monitor 或 Keepalived 触发切换脚本，将 VIP 漂移到可用的 Master db2 上。当出现网络抖动或网络分区时，MMM Monitor 会误判，严重时来回切换写 VIP 导致集群双写，当数据复制延迟时，应用程序会出现数据错乱或数据冲突的故障。有效避免单点失效的架构就是采用共享存储，单点故障切换可以通过分布式哨兵系统监控。</p><img src="http://s0.lgstatic.com/i/image2/M01/89/48/CgoB5l12KuGALf-cAAGuHVmMkHs743.png" alt="img" style="zoom: 67%;" /><p> <strong>架构选型：</strong>MMM 集群  -&gt; MHA集群 -&gt; MHA+Arksentinel。</p><img src="http://s0.lgstatic.com/i/image2/M01/89/68/CgotOV12KuKAe_HOAABl-wRATa0772.png" alt="img"  /><h4 id="4、故障转移和恢复"><a href="#4、故障转移和恢复" class="headerlink" title="4、故障转移和恢复"></a>4、故障转移和恢复</h4><p><strong>转移方式及恢复方法</strong></p><pre><code>1. 虚拟IP或DNS服务 （Keepalived +VIP/DNS  和 MMM 架构）</code></pre><p>​问题：在虚拟 IP 运维过程中，刷新ARP过程中有时会出现一个 VIP 绑定在多台服务器同时提供连接的问题。这也是为什么要避免使用 Keepalived+VIP 和 MMM 架构的原因之一，因为它处理不了这类问题而导致集群多点写入。</p><pre><code>2. 提升备库为主库（MHA、QMHA）</code></pre><p>​尝试将原 Master 设置 read_only 为 on，避免集群多点写入。借助 binlog server 保留 Master 的 Binlog；当出现数据延迟时，再提升 Slave 为新 Master 之前需要进行数据补齐，否则会丢失数据。</p><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h5 id="如何进行分库分表"><a href="#如何进行分库分表" class="headerlink" title="如何进行分库分表"></a>如何进行分库分表</h5><blockquote><p><strong>分表</strong>用户id进行分表，每个表控制在300万数据。</p><p><strong>分库</strong>根据业务场景和地域分库，每个库并发不超过2000</p></blockquote><p><strong>Sharding-jdbc</strong> 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖，升级比较麻烦</p><p><strong>Mycat</strong> 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了</p><p><strong>水平拆分</strong>：一个表放到多个库，分担高并发，加快查询速度</p><ul><li><strong>id</strong>保证业务在关联多张表时可以在同一库上操作</li><li><strong>range</strong>方便扩容和数据统计</li><li><strong>hash</strong>可以使得数据更加平均</li></ul><p><strong>垂直拆分</strong>：一个表拆成多个表，可以将一些冷数据拆分到冗余库中</p><blockquote><p>不是写瓶颈优先进行分表</p></blockquote><ul><li><p>分库数据间的数据无法再通过数据库直接查询了。会产生深分页的问题</p></li><li><p>分库越多，出现问题的可能性越大，维护成本也变得更高。</p></li><li><p>分库后无法保障跨库间事务，只能借助其他中间件实现最终一致性。</p></li></ul><p>分库首先需考虑满足业务最核心的场景：</p><p>1、订单数据按<strong>用户</strong>分库，可以<strong>提升用户的全流程体验</strong></p><p>2、超级客户导致<strong>数据倾斜</strong>可以使用最细粒度唯一标识进行hash拆分</p><p>3、按照最细粒度如订单号拆分以后，数据库就无法进行单库排重了</p><p>三个问题：</p><ul><li><p>富查询：采用分库分表之后，如何满足跨越分库的查询？<strong>使用ES</strong>的宽表</p><p>借助<strong>分库网关+分库业务</strong>虽然能够实现<strong>多维度查询的能力</strong>，但整体上性能不佳且对正常的写入请求有一定的影响。业界应对<strong>多维度实时查询</strong>的最常见方式便是借助 <strong>ElasticSearch</strong></p></li><li><p>数据倾斜：数据分库基础上再进行分表</p></li><li><p>分布式事务：跨多库的修改及多个微服务间的写操作导致的分布式事务问题？</p></li><li><p>深分页问题：按游标查询，或者叫每次查询都带上上一次查询经过排序后的最大 ID</p></li></ul><h4 id="如何将老数据进行迁移"><a href="#如何将老数据进行迁移" class="headerlink" title="如何将老数据进行迁移"></a>如何将老数据进行迁移</h4><p><strong>双写不中断迁移</strong></p><ul><li>线上系统里所有写库的地方，增删改操作，<strong>除了对老库增删改，都加上对新库的增删改</strong></li><li>系统部署以后，还需要跑程序读老库数据写新库，写的时候需要判断updateTime</li><li>循环执行，直至两个库的数据完全一致，最后重新部署分库分表的代码就行了</li></ul><h4 id="系统性能的评估及扩容"><a href="#系统性能的评估及扩容" class="headerlink" title="系统性能的评估及扩容"></a>系统性能的评估及扩容</h4><p>和家亲目前有1亿用户：场景 10万写并发，100万读并发，60亿数据量</p><p>设计时考虑极限情况，32库*32表~64个表，一共1000 ~ 2000张表</p><ul><li><p>支持<strong>3万</strong>的写并发，配合MQ实现每秒10万的写入速度</p></li><li><p>读写分离<strong>6万</strong>读并发，配合分布式缓存每秒100读并发</p></li><li><p>2000张表每张300万，可以最多写入60亿的数据</p></li><li><p>32张用户表，支撑亿级用户，后续最多也就扩容一次</p></li></ul><p><strong>动态扩容的步骤</strong></p><ol><li>推荐是 32 库 * 32 表，对于我们公司来说，可能几年都够了。</li><li>配置路由的规则，uid % 32 &#x3D; 库，uid &#x2F; 32 % 32 &#x3D; 表</li><li>扩容的时候，申请增加更多的数据库服务器，呈倍数扩容</li><li>由 DBA 负责将原先数据库服务器的库，迁移到新的数据库服务器上去</li><li>修改一下配置，重新发布系统，上线，原先的路由规则变都不用变</li><li>直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ol><h4 id="如何生成自增的id主键"><a href="#如何生成自增的id主键" class="headerlink" title="如何生成自增的id主键"></a>如何生成自增的id主键</h4><ul><li>使用redis可以</li><li>并发不高可以单独起一个<strong>服务</strong>，生成自增id</li><li>设置数据库<strong>step</strong>自增步长可以支撑水平伸缩</li><li>UUID适合文件名、编号，但是<strong>不适合做主键</strong></li><li><strong>snowflake雪花算法</strong>，综合了<strong>41时间</strong>（ms）、<strong>10机器</strong>、<strong>12序列号</strong>（ms内自增）</li></ul><p>其中机器预留的10bit可以根据自己的业务场景配置</p><h3 id="线上故障及优化"><a href="#线上故障及优化" class="headerlink" title="线上故障及优化"></a>线上故障及优化</h3><h4 id="更新失败-主从同步延时"><a href="#更新失败-主从同步延时" class="headerlink" title="更新失败 | 主从同步延时"></a>更新失败 | 主从同步延时</h4><p>以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p><p>是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000&#x2F;s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p><p>我们通过 MySQL 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status</span><br></pre></td></tr></table></figure><p>查看 <code>Seconds_Behind_Master</code> ，可以看到从库复制主库的数据落后了几 ms。</p><p>一般来说，如果主从延迟较为严重，有以下解决方案：</p><ul><li>分库，拆分为多个主库，每个主库的写并发就减少了几倍，主从延迟可以忽略不计。</li><li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li><li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>或者<strong>延迟查询</strong>。主从复制延迟一般不会超过50ms</li></ul><h4 id="应用崩溃-分库分表优化"><a href="#应用崩溃-分库分表优化" class="headerlink" title="应用崩溃 | 分库分表优化"></a><strong>应用崩溃 | 分库分表优化</strong></h4><p>​我们有一个线上通行记录的表，由于数据量过大，进行了分库分表，当时分库分表初期经常产生一些问题。典型的就是通行记录查询中使用了深分页，通过一些工具如MAT、Jstack追踪到是由于sharding-jdbc内部引用造成的。</p><p>​通行记录数据被存放在两个库中。如果没有提供<strong>切分键</strong>，查询语句就会被分发到所有的数据库中，比如查询语句是 limit 10、offset 1000，最终结果只需要返回 10 条记录，但是数据库中间件要完成这种计算，则需要 (1000+10)*2&#x3D;2020 条记录来完成这个计算过程。如果 offset 的值过大，使用的内存就会暴涨。虽然 sharding-jdbc 使用归并算法进行了一些优化，但在实际场景中，深分页仍然引起了<strong>内存和性能</strong>问题。</p><p>​这种在中间节点进行<strong>归并聚合</strong>的操作，在分布式框架中非常常见。比如在 ElasticSearch 中，就存在相似的数据获取逻辑，<strong>不加限制的深分页</strong>，同样会造成 ES 的内存问题。</p><p><strong>业界解决方案：</strong></p><p><strong>方法一：全局视野法</strong></p><p>（1）将order by time offset X limit Y，改写成order by time offset 0 limit X+Y</p><p>（2）服务层对得到的N*(X+Y)条数据进行内存排序，内存排序后再取偏移量X后的Y条记录</p><p>这种方法随着翻页的进行，性能越来越低。</p><p><strong>方法二：业务折衷法-禁止跳页查询</strong></p><p>（1）用正常的方法取得第一页数据，并得到第一页记录的time_max</p><p>（2）每次翻页，将order by time offset X limit Y，改写成order by time where time&gt;$time_max limit Y</p><p>以保证每次只返回一页数据，性能为常量。</p><p><strong>方法三：业务折衷法-允许模糊数据</strong></p><p>（1）将order by time offset X limit Y，改写成order by time offset X&#x2F;N limit Y&#x2F;N</p><p><strong>方法四：二次查询法</strong></p><p>（1）将order by time offset X limit Y，改写成order by time offset X&#x2F;N limit Y</p><p>（2）找到最小值time_min</p><p>（3）between二次查询，order by time between $time_min and $time_i_max</p><p>（4）设置虚拟time_min，找到time_min在各个分库的offset，从而得到time_min在全局的offset</p><p>（5）得到了time_min在全局的offset，自然得到了全局的offset X limit Y</p><h4 id="查询异常-SQL-调优"><a href="#查询异常-SQL-调优" class="headerlink" title="查询异常 | SQL 调优"></a>查询异常 | SQL 调优</h4><p>分库分表前，有一段用用户名来查询某个用户的 SQL 语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> user where name = <span class="string">&quot;xxx&quot;</span> <span class="keyword">and</span> community=<span class="string">&quot;other&quot;</span>;</span><br></pre></td></tr></table></figure><p>为了达到动态拼接的效果，这句 SQL 语句被一位同事进行了如下修改。他的本意是，当 name 或者 community 传入为空的时候，动态去掉这些查询条件。这种写法，在 MyBaits 的配置文件中，也非常常见。大多数情况下，这种写法是没有问题的，因为结果集合是可以控制的。但随着系统的运行，用户表的记录越来越多，当传入的 name 和 community 全部为空时，悲剧的事情发生了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where 1=1</span><br></pre></td></tr></table></figure><p>数据库中的所有记录，都会被查询出来，载入到 JVM 的内存中。由于数据库记录实在太多，直接把内存给撑爆了。由于这种原因引起的内存溢出，发生的频率非常高，比如导入Excel文件时。</p><p>通常的解决方式是<strong>强行加入分页功能</strong>，或者对一些<strong>必填的参数进行校验</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobovqjvijj30zd0lctbp.jpg" alt="img"></p><p><strong>Controller 层</strong></p><p>现在很多项目都采用前后端分离架构，所以 Controller 层的方法，一般使用 @ResponseBody 注解，把查询的结果，解析成 JSON 数据返回。这在数据集非常大的情况下，会占用很多内存资源。假如结果集在解析成 JSON 之前，占用的内存是 10MB，那么在解析过程中，有可能会使用 20M 或者更多的内存</p><p>因此，保持结果集的精简，是非常有必要的，这也是 DTO（Data Transfer Object）存在的必要。互联网环境不怕小结果集的高并发请求，却非常恐惧大结果集的耗时请求，这是其中一方面的原因。</p><p><strong>Service 层</strong></p><p>Service 层用于处理具体的业务，更加贴合业务的功能需求。一个 Service，可能会被多个 Controller 层所使用，也可能会使用多个 dao 结构的查询结果进行计算、拼装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getUserSize</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = dao.getAllUser();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> == users ? <span class="number">0</span> : users.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码review中发现了定时炸弹，这种在数据量达到一定程度后，才会暴露问题。</p><p><strong>ORM 层</strong></p><p>比如使用Mybatis时，有一个批量导入服务，在 MyBatis 执行批量插入的时候，竟然产生了内存溢出，按道理这种插入操作是不会引起额外内存占用的，最后通过源码追踪到了问题。</p><p>这是因为 MyBatis 循环处理 batch 的时候，操作对象是数组，而我们在接口定义的时候，使用的是 List；当传入一个非常大的 List 时，它需要调用 List 的 toArray 方法将列表转换成数组（浅拷贝）；在最后的拼装阶段，又使用了 StringBuilder 来拼接最终的 SQL，所以实际使用的内存要比 List 多很多。</p><p>事实证明，不论是插入操作还是查询动作，只要涉及的数据集非常大，就容易出现问题。由于项目中众多框架的引入，想要分析这些具体的内存占用，就变得非常困难。所以保持小批量操作和结果集的干净，是一个非常好的习惯。</p><h1 id="五、Redis篇"><a href="#五、Redis篇" class="headerlink" title="五、Redis篇"></a><strong>五、Redis篇</strong></h1><h3 id="WhyRedis"><a href="#WhyRedis" class="headerlink" title="WhyRedis"></a>WhyRedis</h3><p>​速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；</p><table><thead><tr><th></th><th>GuavaCache</th><th>Tair</th><th>EVCache</th><th>Aerospike</th></tr></thead><tbody><tr><td>类别</td><td>本地JVM缓存</td><td>分布式缓存</td><td>分布式缓存</td><td>分布式nosql数据库</td></tr><tr><td>应用</td><td>本地缓存</td><td>淘宝</td><td>Netflix、AWS</td><td>广告</td></tr><tr><td>性能</td><td>非常高</td><td>较高</td><td>很高</td><td>较高</td></tr><tr><td>持久化</td><td>无</td><td>有</td><td>有</td><td>有</td></tr><tr><td>集群</td><td>无</td><td>灵活配置</td><td>有</td><td>自动扩容</td></tr></tbody></table><p>​与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><h4 id="1、简单高效"><a href="#1、简单高效" class="headerlink" title="1、简单高效"></a>1、简单高效</h4><p>​1）完全基于内存，绝大部分请求是纯粹的内存操作。数据存在内存中，类似于 HashMap，查找和操作的时间复杂度都是O(1)；</p><p>​2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p><p>​3）采用单线程，避免了多线程不必要的上下文切换和竞争条件，不存在加锁释放锁操作，减少了因为锁竞争导致的性能消耗；（6.0以后多线程）</p><p>​4）使用EPOLL多路 I&#x2F;O 复用模型，非阻塞 IO；</p><p>​5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><h4 id="2、Memcache"><a href="#2、Memcache" class="headerlink" title="2、Memcache"></a>2、Memcache</h4><table><thead><tr><th>redis</th><th>Memcached</th></tr></thead><tbody><tr><td>内存高速数据库</td><td>高性能分布式内存缓存数据库</td></tr><tr><td>支持hash、list、set、zset、string结构</td><td>只支持key-value结构</td></tr><tr><td>将大部分数据放到内存</td><td>全部数据放到内存中</td></tr><tr><td>支持持久化、主从复制备份</td><td>不支持数据持久化及数据备份</td></tr><tr><td>数据丢失可通过AOF恢复</td><td>挂掉后，数据不可恢复</td></tr><tr><td>单线程（2~4万TPS）</td><td>多线程（20-40万TPS）</td></tr></tbody></table><p><strong>使用场景：</strong></p><p>​1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。<br>​2、如果简单的key&#x2F;value 存储应该选择memcached。</p><h4 id="3、Tair"><a href="#3、Tair" class="headerlink" title="3、Tair"></a>3、Tair</h4><p>​Tair(Taobao Pair)是淘宝开发的分布式Key-Value存储引擎，既可以做缓存也可以做数据源（三种引擎切换）</p><ul><li>MDB（Memcache）属于内存型产品,支持kv和类hashMap结构,性能最优</li><li>RDB（Redis）支持List.Set.Zset等复杂的数据结构,性能次之,可提供缓存和持久化存储两种模式</li><li>LDB（levelDB）属于持久化产品,支持kv和类hashmap结构,性能较前两者稍低,但持久化可靠性最高</li></ul><p><strong>分布式缓存</strong></p><p>大访问少量临时数据的存储（kb左右）</p><p>用于缓存，降低对后端数据库的访问压力</p><p>session场景</p><p>高速访问某些数据结构的应用和计算（rdb）</p><p><strong>数据源存储</strong></p><p>快速读取数据（fdb）</p><p>持续大数据量的存入读取（ldb），交易快照</p><p>高频度的更新读取（ldb），库存</p><p><strong>痛点</strong>：redis集群中，想借用缓存资源必须得指明redis服务器地址去要。这就增加了程序的维护复杂度。因为redis服务器很可能是需要频繁变动的。所以人家淘宝就想啊，为什么不能像操作分布式数据库或者hadoop那样。增加一个中央节点，让他去代理所有事情。在tair中程序只要跟tair中心节点交互就OK了。同时tair里还有配置服务器概念。又免去了像操作hadoop那样，还得每台hadoop一套一模一样配置文件。改配置文件得整个集群都跟着改。</p><h4 id="4、Guava"><a href="#4、Guava" class="headerlink" title="4、Guava"></a>4、Guava</h4><p>​分布式缓存一致性更好一点，用于集群环境下多节点使用同一份缓存的情况；有网络IO，吞吐率与缓存的数据大小有较大关系；</p><p>​本地缓存非常高效，本地缓存会占用堆内存，影响垃圾回收、影响系统性能。</p><p><strong>本地缓存设计：</strong></p><p>​以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p><strong>解决缓存过期：</strong></p><p>​1、将缓存过期时间调为永久</p><p>​2、将缓存失效时间分散开，不要将缓存时间长度都设置成一样；比如我们可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><p><strong>解决内存溢出：</strong></p><p>​<strong>第一步</strong>，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p><p>　<strong>第二步</strong>，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</p><p>　<strong>第三步</strong>，对代码进行走查和分析，找出可能发生内存溢出的位置。</p><p><strong>Google Guava Cache</strong> </p><p><strong>自己设计本地缓存痛点：</strong></p><ul><li>不能按照一定的规则淘汰数据，如 LRU，LFU，FIFO 等。</li><li>清除数据时的回调通知</li><li>并发处理能力差，针对并发可以使用CurrentHashMap，但缓存的其他功能需要自行实现</li><li>缓存过期处理，缓存数据加载刷新等都需要手工实现</li></ul><p><strong>Guava Cache 的场景：</strong></p><ul><li>对性能有非常高的要求</li><li>不经常变化，占用内存不大</li><li>有访问整个集合的需求</li><li>数据允许不实时一致</li></ul><p><strong>Guava Cache 的优势</strong>：</p><ul><li>缓存过期和淘汰机制</li></ul><p>在GuavaCache中可以设置Key的过期时间，包括访问过期和创建过期。GuavaCache在缓存容量达到指定大小时，采用LRU的方式，将不常使用的键值从Cache中删除</p><ul><li>并发处理能力</li></ul><p>GuavaCache类似CurrentHashMap，是线程安全的。提供了设置并发级别的api，使得缓存支持并发的写入和读取，采用分离锁机制，分离锁能够减小锁力度，提升并发能力，分离锁是分拆锁定，把一个集合看分成若干partition, 每个partiton一把锁。更新锁定</p><ul><li>防止缓存击穿</li></ul><p>一般情况下，在缓存中查询某个key，如果不存在，则查源数据，并回填缓存。（Cache Aside Pattern）在高并发下会出现，多次查源并重复回填缓存，可能会造成源的宕机（DB），性能下降 GuavaCache可以在CacheLoader的load方法中加以控制，对同一个key，只让一个请求去读源并回填缓存，其他请求阻塞等待。（相当于集成数据源，方便用户使用）</p><ul><li>监控缓存加载&#x2F;命中情况</li></ul><p>统计</p><p><strong>问题：</strong></p><p>​OOM-&gt;设置过期时间、使用弱引用、配置过期策略</p><h4 id="5、EVCache"><a href="#5、EVCache" class="headerlink" title="5、EVCache"></a>5、EVCache</h4><p>EVCache是一个Netflflix（网飞）公司开源、快速的分布式缓存，是基于Memcached的内存存储实现的，用以构建超大容量、高性能、低延时、跨区域的全球可用的缓存数据层。</p><p>E：Ephemeral：数据存储是短暂的，有自身的存活时间</p><p>V：Volatile：数据可以在任何时候消失</p><p>EVCache典型地适合对强一致性没有必须要求的场合</p><p>典型用例：Netflflix向用户推荐用户感兴趣的电影</p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmapdnh0yaj30ku0aigmc.jpg" alt="image-20210103185340548" style="zoom:50%;" /><p><strong>EVCache集群</strong>在峰值每秒可以处理<strong>200kb</strong>的请求，</p><p>Netflflix生产系统中部署的EVCache经常要处理超过<strong>每秒3000万个</strong>请求，存储数十亿个对象，</p><p>跨数千台memcached服务器。整个EVCache集群<strong>每天处理近2万亿个</strong>请求。</p><p>EVCache集群响应平均延时大约是1-5毫秒，最多不会超过20毫秒。</p><p>EVCache集群的缓存命中率在99%左右。</p><p><strong>典型部署</strong></p><p>EVCache 是线性扩展的，可以在一分钟之内完成扩容，在几分钟之内完成负载均衡和缓存预热。</p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmapg99q8lj30ix0f3jrw.jpg" alt="image-20210103185611516" style="zoom:50%;" /><p>1、集群启动时，EVCache向服务注册中心（Zookeeper、Eureka）注册各个实例</p><p>2、在web应用启动时，查询命名服务中的EVCache服务器列表，并建立连接。</p><p>3、客户端通过key使用一致性hash算法，将数据分片到集群上。</p><h4 id="6、ETCD"><a href="#6、ETCD" class="headerlink" title="6、ETCD"></a>6、ETCD</h4><p>​<strong>和Zookeeper一样，CP模型追求数据一致性，</strong>越来越多的系统开始用它保存关键数据。比如，秒杀系统经常用它<strong>保存各节点信</strong>息，以便控制消费 MQ 的服务数量。还有些业务系统的<strong>配置数据</strong>，也会通过 etcd 实时同步给业务系统的各节点，比如，秒杀管理后台会使用 etcd 将秒杀活动的<strong>配置数据实时同步给秒杀 API 服务各节点</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2tg9qs00j30ta0g40vc.jpg" alt="image-20210418174251742"></p><h3 id="Redis底层"><a href="#Redis底层" class="headerlink" title="Redis底层"></a>Redis底层</h3><h4 id="1、redis数据类型"><a href="#1、redis数据类型" class="headerlink" title="1、redis数据类型"></a>1、redis数据类型</h4><table><thead><tr><th>类型</th><th>底层</th><th>应用场景</th><th>编码类型</th></tr></thead><tbody><tr><td>String</td><td>SDS数组</td><td>帖子、评论、热点数据、输入缓冲</td><td>RAW &lt;&lt; EMBSTR &lt;&lt; INT</td></tr><tr><td>List</td><td>QuickList</td><td>评论列表、商品列表、发布与订阅、慢查询、监视器</td><td>LINKEDLIST &lt;&lt; ZIPLIST</td></tr><tr><td>Set</td><td>intSet</td><td>适合交集、并集、查集操作，例如朋友关系</td><td>HT &lt;&lt; INSET</td></tr><tr><td>Zset</td><td>跳跃表</td><td>去重后排序，适合排名场景</td><td>SKIPLIST &lt;&lt; ZIPLIST</td></tr><tr><td>Hash</td><td>哈希</td><td>结构化数据，比如存储对象</td><td>HT &lt;&lt; ZIPLIST</td></tr><tr><td>Stream</td><td>紧凑列表</td><td>消息队列</td><td></td></tr></tbody></table><h4 id="2、相关API"><a href="#2、相关API" class="headerlink" title="2、相关API"></a><strong>2、相关API</strong></h4><blockquote><p><a href="http://redisdoc.com/">http://redisdoc.com</a></p></blockquote><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>String</td><td>SET</td><td>SETNX</td><td>SETEX</td><td>GET</td><td>GETSET</td><td>INCR</td><td>DECR</td><td>MSET</td><td>MGET</td></tr><tr><td>Hash</td><td>HSET</td><td>HSETNX</td><td>HGET</td><td>HDEL</td><td>HLEN</td><td>HMSET</td><td>HMGET</td><td>HKEYS</td><td>HGETALL</td></tr><tr><td>LIST</td><td>LPUSH</td><td>LPOP</td><td>RPUSH</td><td>RPOP</td><td>LINDEX</td><td>LREM</td><td>LRANGE</td><td>LLEN</td><td>RPOPLPUSH</td></tr><tr><td>ZSET</td><td>ZADD</td><td>ZREM</td><td>ZSCORE</td><td>ZCARD</td><td>ZRANGE</td><td>ZRANK</td><td>ZREVRANK</td><td></td><td>ZREVRANGE</td></tr><tr><td>SET</td><td>SADD</td><td>SREM</td><td>SISMEMBER</td><td>SCARD</td><td>SINTER</td><td>SUNION</td><td>SDIFF</td><td>SPOP</td><td>SMEMBERS</td></tr><tr><td>事务</td><td>MULTI</td><td>EXEC</td><td>DISCARD</td><td>WATCH</td><td>UNWATCH</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3、redis底层结构"><a href="#3、redis底层结构" class="headerlink" title="3、redis底层结构"></a>3、redis底层结构</h4><p><strong>SDS数组结构</strong>，用于存储字符串和整型数据及输入缓冲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123; </span><br><span class="line">  <span class="type">int</span> len;<span class="comment">//记录buf数组中已使用字节的数量 </span></span><br><span class="line">  <span class="type">int</span> free; <span class="comment">//记录 buf 数组中未使用字节的数量 </span></span><br><span class="line">  <span class="type">char</span> buf[];<span class="comment">//字符数组，用于保存字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>跳跃表</strong>：将有序链表中的部分节点分层，每一层都是一个有序链表。</p><p>​1、可以快速查找到需要的节点 O(logn) ，额外存储了一倍的空间</p><p>​2、可以在O(1)的时间复杂度下，快速获得跳跃表的头节点、尾结点、长度和高度。</p><p><strong>字典dict:</strong> 又称散列表(hash)，是用来存储键值对的一种数据结构。 </p><p>​Redis整个数据库是用字典来存储的(K-V结构) —Hash+数组+链表</p><p>​Redis字典实现包括:**字典(dict)、Hash表(dictht)、Hash表节点(dictEntry)**。</p><p>​字典达到存储上限(阈值 0.75)，需要rehash(扩容)</p><p>​1、初次申请默认容量为4个dictEntry，非初次申请为当前hash表容量的一倍。</p><p>​2、rehashidx&#x3D;0表示要进行rehash操作。</p><p>​3、新增加的数据在新的hash表h[1] 、修改、删除、查询在老hash表h[0]</p><p>​4、将老的hash表h[0]的数据重新计算索引值后全部迁移到新的hash表h[1]中，这个过程称为 rehash。</p><p>​<strong>渐进式rehash</strong></p><pre><code> 由于当数据量巨大时rehash的过程是非常缓慢的，所以需要进行优化。 可根据服务器空闲程度批量rehash部分节点</code></pre><p><strong>压缩列表zipList</strong></p><p>​压缩列表(ziplist)是由一系列特殊编码的连续内存块组成的顺序型数据结构，节省内容</p><p>​<strong>sorted-set和hash元素个数少</strong>且是小整数或短字符串(直接使用) </p><p>​list用快速链表(quicklist)数据结构存储，而<strong>快速链表是双向列表与压缩列表</strong>的组合。(间接使用)</p><p><strong>整数集合intSet</strong></p><p>​整数集合(intset)是一个有序的(整数升序)、存储整数的连续存储结构。 </p><p>​当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内(2^64)，使用该结构体存储。</p><p><strong>快速列表quickList</strong></p><p>​快速列表(quicklist)是Redis底层重要的数据结构。是Redis3.2列表的底层实现。</p><p>​(在Redis3.2之前，Redis采 用双向链表(adlist)和压缩列表(ziplist)实现。)</p><p><strong>Redis Stream</strong>的底层主要使用了listpack(紧凑列表)和Rax树(基数树)。</p><p>​<strong>listpack</strong>表示一个字符串列表的序列化，listpack可用于存储字符串或整数。用于存储stream的消息内 容。</p><p>​<strong>Rax树</strong>是一个有序字典树 (基数树 Radix Tree)，按照 key 的字典序排列，支持快速地定位、插入和删除操 作。</p><h4 id="4、Zset底层实现"><a href="#4、Zset底层实现" class="headerlink" title="4、Zset底层实现"></a>4、Zset底层实现</h4><p>​跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度</p><p>​Zset<strong>数据量少的时候使用压缩链表ziplist</strong>实现，有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。 <strong>数据量大的时候使用跳跃列表skiplist和哈希表hash_map</strong>结合实现，查找删除插入的时间复杂度都是O(longN)</p><p>​Redis使用跳表而不使用红黑树，是因为跳表的索引结构序列化和反序列化更加快速，方便持久化。</p><p><strong>搜索</strong></p><p>​跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 <em>O(logN)，最坏 O(N) 。</em></p><p><strong>插入</strong></p><p>  选用链表作为底层结构支持，为了高效地动态增删。因为跳表底层的单链表是有序的，为了维护这种有序性，在插入前需要遍历链表，找到该插入的位置，单链表遍历查找的时间复杂度是O(n)，同理可得，跳表的遍历也是需要遍历索引数，所以是O(logn)。</p><p><strong>删除</strong></p><p>  如果该节点还在索引中，删除时不仅要删除单链表中的节点，还要删除索引中的节点；单链表在知道删除的节点是谁时，时间复杂度为O(1)，但针对单链表来说，删除时都需要拿到前驱节点O(logN)才可改变引用关系从而删除目标节点。</p><h3 id="Redis可用性"><a href="#Redis可用性" class="headerlink" title="Redis可用性"></a><strong>Redis可用性</strong></h3><h4 id="1、redis持久化"><a href="#1、redis持久化" class="headerlink" title="1、redis持久化"></a>1、redis持久化</h4><p>持久化就是把内存中的数据持久化到本地磁盘，防止服务器宕机了内存数据丢失</p><p>Redis 提供两种持久化机制 <strong>RDB（默认）</strong> 和 <strong>AOF 机制</strong>，Redis4.0以后采用混合持久化，用 AOF 来<strong>保证数据不丢失</strong>，作为数据恢复的第一选择; 用 RDB 来做不同程度的<strong>冷备</strong></p><p><strong>RDB：</strong>是Redis DataBase缩写快照</p><p>​RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p><p>​<strong>优点：</strong></p><p>​1）只有一个文件 dump.rdb，方便持久化；</p><p>​2）容灾性好，一个文件可以保存到安全的磁盘。</p><p>​3）性能最大化，fork 子进程来进行持久化写操作，让主进程继续处理命令，只存在毫秒级不响应请求。</p><p>​4）相对于数据集大时，比 AOF 的启动效率更高。</p><p>​<strong>缺点：</strong></p><p>​数据安全性低，RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。</p><p><strong>AOF：持久化</strong></p><p>​AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p><p>​<strong>优点：</strong></p><p>​1）数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p><p>​2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p><p><strong>缺点：</strong></p><p>​1）AOF 文件比 RDB 文件大，且恢复速度慢。</p><p>​2）数据集大的时候，比 rdb 启动效率低。</p><h4 id="2、redis事务"><a href="#2、redis事务" class="headerlink" title="2、redis事务"></a>2、redis事务</h4><p>​事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p><strong>Redis事务的概念</strong></p><p>​Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><p>Redis的事务总是具有ACID中的<strong>一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><p><strong>事务命令：</strong></p><p><strong>MULTI：</strong>用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p><p><strong>EXEC：</strong>执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</p><p><strong>WATCH ：</strong>是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。（<strong>秒杀场景</strong>）</p><p><strong>DISCARD：</strong>调用该命令，客户端可以清空事务队列，并放弃执行事务，且客户端会从事务状态中退出。</p><p><strong>UNWATCH</strong>：命令可以取消watch对所有key的监控。</p><h4 id="3、redis失效策略"><a href="#3、redis失效策略" class="headerlink" title="3、redis失效策略"></a>3、redis失效策略</h4><p><strong>内存淘汰策略</strong></p><p>1）全局的键空间选择性移除</p><p>​<strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。（字典库常用）</p><p>​<strong>allkeys-lru</strong>：在键空间中，移除最近最少使用的key。（缓存常用）</p><p>​<strong>allkeys-random</strong>：在键空间中，随机移除某个key。</p><p>2）设置过期时间的键空间选择性移除</p><p>​<strong>volatile-lru</strong>：在设置了过期时间的键空间中，移除最近最少使用的key。</p><p>​<strong>volatile-random</strong>：在设置了过期时间的键空间中，随机移除某个key。</p><p>​<strong>volatile-ttl</strong>：在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p><p><strong>缓存失效策略</strong></p><p>​<strong>定时清除：</strong>针对每个设置过期时间的key都创建指定定时器</p><p>​<strong>惰性清除：</strong>访问时判断，对内存不友好</p><p>​<strong>定时扫描清除：</strong>定时100ms随机20个检查过期的字典，若存在25%以上则继续循环删除。</p><h4 id="4、redis读写模式"><a href="#4、redis读写模式" class="headerlink" title="4、redis读写模式"></a>4、redis读写模式</h4><p>​<strong>CacheAside旁路缓存</strong></p><p>写请求更新数据库后删除缓存数据。读请求不命中查询数据库，查询完成写入缓存</p><img src="https://img-blog.csdnimg.cn/20200806194316539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eF92aWN0b3J5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 15%;" /><img src="https://img-blog.csdnimg.cn/20200806194300826.png" style="zoom: 15%;" /><p>​业务端处理所有数据访问细节，同时利用 <strong>Lazy 计算</strong>的思想，更新 DB 后，直接删除 cache 并通过 DB 更新，确保数据以 DB 结果为准，则可以大幅降低 cache 和 DB 中数据不一致的概率</p><p>​如果没有专门的存储服务，同时是对<strong>数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务</strong>，适合使用 Cache Aside 模式。如微博发展初期，不少业务采用这种模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key,Object data)</span>&#123;</span><br><span class="line">redis.delKey(key);</span><br><span class="line">db.updateData(data);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高并发下保证绝对的一致，先删缓存再更新数据，需要用到<strong>内存队列做异步串行化</strong>。非高并发场景，先更新数据再删除缓存，<strong>延迟双删</strong>策略基本满足了</p><ul><li>先更新db后删除redis：删除redis失败则出现问题</li><li>先删redis后更新db：删除redis瞬间，旧数据被回填redis</li><li>先删redis后更新db休眠后删redis：同第二点，休眠后删除redis 可能宕机</li><li>java内部jvm队列：不适用分布式场景且降低并发</li></ul><p>​<strong>Read&#x2F;Write Though</strong>（读写穿透）</p><p>​<strong>先查询</strong>缓存中数据是否存在,如果存在则直接返回,如果<strong>不存在</strong>,则由<strong>缓存组件负责从数据库中同步加载数据.</strong></p><p>​<img src="https://img-blog.csdnimg.cn/20200806194334623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eF92aWN0b3J5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /></p><p>​先查询要<strong>写入的数据在缓存中</strong>是否已经存在,如果已经存在,则<strong>更新缓存中的数据</strong>，并且由<strong>缓存组件同步更新</strong>到数据库中。</p><p>​<img src="https://img-blog.csdnimg.cn/20200806194346642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eF92aWN0b3J5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%" /></p><p>​用户<strong>读操作</strong>较多.相较于Cache aside而言更适合缓存一致的场景。使用简单屏蔽了<strong>底层数据库的操作</strong>,只是操作缓存.</p><p><strong>场景：</strong></p><p>微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。</p><p>​</p><p><strong>Write Behind Caching（异步缓存写入）</strong></p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorlsg74i6j31950e3dhs.jpg" alt="img" style="zoom:35%;" /><p>比如对一些计数业务，一条 <strong>Feed 被点赞</strong> 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。但这种模型有个显著的缺点，即数据的一致性变差，甚至在一些极端场景下可能会丢失数据。</p><h4 id="5、多级缓存"><a href="#5、多级缓存" class="headerlink" title="5、多级缓存"></a>5、多级缓存</h4><p><strong>浏览器本地内存缓存：</strong>专题活动，一旦上线，在活动期间是不会随意变更的。</p><p><strong>浏览器本地磁盘缓存：</strong>Logo缓存，大图片懒加载</p><p><strong>服务端本地内存缓存：</strong>由于没有持久化，重启时必定会被穿透</p><p><strong>服务端网络内存缓存</strong>：Redis等，针对穿透的情况下可以继续分层，必须保证数据库不被压垮</p><p><strong>为什么不是使用服务器本地磁盘做缓存？</strong></p><p>​当系统处理大量磁盘 IO 操作的时候，由于 CPU 和内存的速度远高于磁盘，可能导致 CPU 耗费太多时间等待磁盘返回处理的结果。对于这部分 CPU 在 IO 上的开销，我们称为 <strong>iowait</strong></p><h3 id="Redis七大经典问题"><a href="#Redis七大经典问题" class="headerlink" title="Redis七大经典问题"></a>Redis七大经典问题</h3><h4 id="1、缓存雪崩"><a href="#1、缓存雪崩" class="headerlink" title="1、缓存雪崩"></a>1、缓存雪崩</h4><p>​指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>​<strong>解决方案：</strong></p><ul><li><p><strong>Redis 高可用</strong>，主从+哨兵，Redis cluster，避免全盘崩溃</p></li><li><p>本地 ehcache 缓存 + hystrix <strong>限流&amp;降级</strong>，避免 MySQL 被打死</p></li><li><p>缓存数据的<strong>过期时间设置随机</strong>，防止同一时间大量数据过期现象发生。</p></li><li><p><strong>逻辑上永不过期</strong>给每一个缓存数据增加相应的<strong>缓存标记</strong>，缓存标记失效则更新数据缓存</p></li><li><p><strong>多级缓存</strong>，失效时通过二级更新一级，由第三方插件更新二级缓存。</p></li></ul><h4 id="2、缓存穿透"><a href="#2、缓存穿透" class="headerlink" title="2、缓存穿透"></a><strong>2、缓存穿透</strong></h4><p>​<a href="https://blog.csdn.net/lin777lin/article/details/105666839">https://blog.csdn.net/lin777lin/article/details/105666839</a></p><p>​缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>​<strong>解决方案：</strong></p><p>​1）<strong>接口层增加校验</strong>，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p><p>​2）从缓存取不到的数据，在数据库中也没有取到，这时也可以将<strong>key-value对写为key-null</strong>，缓存有效时间可以设置短点，如30秒。这样可以防止攻击用户反复用同一个id暴力攻击；</p><p>​3）采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。（宁可错杀一千不可放过一人）</p><h4 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a><strong>3、缓存击穿</strong></h4><p>​这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</p><p>​<strong>解决方案：</strong></p><p>​1）设置<strong>热点数据永远不过期</strong>，异步线程处理。</p><p>​2）加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</p><p>​3）缓存预热</p><p>​系统上线后，将相关<strong>可预期（例如排行榜）</strong>热点数据直接加载到缓存。</p><p>​写一个缓存刷新页面，手动操作热点数据<strong>（例如广告推广）</strong>上下线。</p><h4 id="4、数据不一致"><a href="#4、数据不一致" class="headerlink" title="4、数据不一致"></a>4、数据不一致</h4><p>​在缓存机器的带宽被打满，或者机房网络出现波动时，缓存更新失败，新数据没有写入缓存，就会导致缓存和 DB 的数据不一致。缓存 rehash 时，某个缓存机器反复异常，多次上下线，更新请求多次 rehash。这样，一份数据存在多个节点，且每次 rehash 只更新某个节点，导致一些缓存节点产生脏数据。</p><ul><li><p>Cache 更新失败后，可以进行重试，则将重试失败的 key 写入mq，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性</p></li><li><p>缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。</p></li><li><p>不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。</p></li></ul><h4 id="5、数据并发竞争"><a href="#5、数据并发竞争" class="headerlink" title="5、数据并发竞争"></a>5、数据并发竞争</h4><p>​数据并发竞争在大流量系统也比较常见，比如车票系统，如果某个火车车次缓存信息过期，但仍然有大量用户在查询该车次信息。又比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量的转发、评论、赞。上述情况都会造成并发竞争读取的问题。</p><ul><li>​加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</li><li>​对缓存数据保持多个备份，减少并发竞争的概率</li></ul><p>​</p><h4 id="6、热点key问题"><a href="#6、热点key问题" class="headerlink" title="6、热点key问题"></a>6、热点key问题</h4><p>​明星结婚、离婚、出轨这种特殊突发事件，比如奥运、春节这些重大活动或节日，还比如秒杀、双12、618 等线上促销活动，都很容易出现 Hot key 的情况。</p><p>如何提前发现HotKey？</p><ul><li>对于重要节假日、线上促销活动这些提前已知的事情，可以提前评估出可能的热 key 来。</li><li>而对于突发事件，无法提前评估，可以<strong>通过 Spark，对应流任务进行实时分析</strong>，及时发现新发布的热点 key。而对于之前已发出的事情，逐步发酵成为热 key 的，则可以通过 Hadoop 对批处理任务离线计算，找出最近历史数据中的高频热 key。</li></ul><p><strong>解决方案：</strong></p><ul><li><p>这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载</p></li><li><p>缓存集群可以单节点进行主从复制和垂直扩容</p></li><li><p>利用应用内的前置缓存，但是需注意需要设置上限</p></li><li><p>延迟不敏感，定时刷新，实时感知用主动刷新</p></li><li><p>和缓存穿透一样，限制逃逸流量，单请求进行数据回源并刷新前置</p></li><li><p>无论如何设计，最后都要写一个兜底逻辑，千万级流量说来就来</p></li></ul><h4 id="7、BigKey问题"><a href="#7、BigKey问题" class="headerlink" title="7、BigKey问题"></a>7、BigKey问题</h4><p>​比如互联网系统中需要保存用户最新 1万 个粉丝的业务，比如一个用户个人信息缓存，包括基本资料、关系图谱计数、发 feed 统计等。微博的 feed 内容缓存也很容易出现，一般用户微博在 140 字以内，但很多用户也会发表 1千 字甚至更长的微博内容，这些长微博也就成了大 key</p><ul><li>首先Redis底层数据结构里，根据Value的不同，会进行数据结构的重新选择</li><li>可以扩展新的数据结构，进行序列化构建，然后通过 restore 一次性写入</li><li>将大 key 分拆为多个 key，设置较长的过期时间</li></ul><h3 id="Redis分区容错"><a href="#Redis分区容错" class="headerlink" title="Redis分区容错"></a>Redis分区容错</h3><h4 id="1、redis数据分区"><a href="#1、redis数据分区" class="headerlink" title="1、redis数据分区"></a><strong>1、redis数据分区</strong></h4><p><strong>Hash：（不稳定）</strong></p><p>​客户端分片：哈希+取余</p><p>​节点伸缩：数据节点关系变化，导致数据迁移</p><p>​迁移数量和添加节点数量有关：建议翻倍扩容</p><p>​一个简单直观的想法是直接用Hash来计算，以Key做哈希后对节点数取模。可以看出，在key足够分散的情况下，均匀性可以获得，但一旦有节点加入或退出，所有的原有节点都会受到影响，稳定性无从谈起。</p><p><strong>一致性Hash：（不均衡）</strong></p><p>​客户端分片：哈希+顺时针（优化取余）</p><p>​节点伸缩：只影响邻近节点，但是还是有数据迁移</p><p>​翻倍伸缩：保证最小迁移数据和负载均衡</p><p>​一致性Hash可以很好的解决稳定问题，可以将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到先遇到的一组存储节点存放。而当有节点加入或退出时，仅影响该节点在Hash环上顺时针相邻的后续节点，将数据从该节点接收或者给予。但这又带来均匀性的问题，即使可以将存储节点等距排列，也会在<strong>存储节点个数变化时带来数据的不均匀</strong>。</p><p><strong>Codis的Hash槽</strong></p><p>​Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算 哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。</p><p><strong>RedisCluster</strong></p><p>​Redis-cluster把所有的物理节点映射到[0-16383]个<strong>slot</strong>上,对key采用crc16算法得到hash值后对16384取模，基本上采用平均分配和连续分配的方式。</p><h4 id="2、主从模式-简单"><a href="#2、主从模式-简单" class="headerlink" title="2、主从模式&#x3D;简单"></a><strong>2、主从模式&#x3D;简单</strong></h4><p>​主从模式最大的优点是<strong>部署简单</strong>，最少<strong>两个节点便可以构成主从模式</strong>，并且可以通过<strong>读写分离避免读和写同时不可用</strong>。不过，一旦 Master 节点出现故障，主从节点就<strong>无法自动切换</strong>，直接导致 SLA 下降。所以，主从模式一般<strong>适合业务发展初期，并发量低，运维成本低</strong>的情况</p><img src="https://s0.lgstatic.com/i/image/M00/80/25/Ciqc1F_QgPOAaL8TAAC5EiNlvo4795.png" alt="Drawing 1.png" style="zoom:50%;" /><p><strong>主从复制原理：</strong></p><p>​①通过从服务器发送到PSYNC命令给主服务器</p><p>​②如果是首次连接，触发一次<strong>全量复制</strong>。此时主节点会启动一个后台线程，生成 RDB 快照文件</p><p>​③主节点会将这个 RDB 发送给从节点，slave 会先写入本地磁盘，再从本地磁盘加载到内存中</p><p>​④master会将此过程中的写命令写入缓存，从节点<strong>实时同步</strong>这些数据</p><p>​⑤如果网络断开了连接，自动重连后主节点通过命令传播<strong>增量复制</strong>给从节点部分缺少的数据</p><p><strong>缺点</strong></p><p>​所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决，redis4.0中引入psync2 解决了slave重启后仍然可以增量同步。</p><h4 id="3、哨兵模式-读多"><a href="#3、哨兵模式-读多" class="headerlink" title="3、哨兵模式&#x3D;读多"></a>3、<strong>哨兵模式</strong>&#x3D;读多</h4><p>​由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<strong>哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统</strong>中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。</p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluq6vlvglj30nw0e076f.jpg" alt="image-20201220231241725" style="zoom:50%;" /><p>当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。</p><p><strong>检测主观下线状态</strong></p><p>​Sentinel每秒一次向所有与它建立了命令连接的实例(主服务器、从服务器和其他Sentinel)发送PING命 令</p><p>​实例在down-after-milliseconds毫秒内返回无效回复Sentinel就会认为该实例主观下线(<strong>SDown</strong>)</p><p><strong>检查客观下线状态</strong></p><p>​当一个Sentinel将一个主服务器判断为主观下线后 ，Sentinel会向监控这个主服务器的所有其他Sentinel发送查询主机状态的命令</p><p>​如果达到Sentinel配置中的quorum数量的Sentinel实例都判断主服务器为主观下线，则该主服务器就会被判定为客观下线(<strong>ODown</strong>)。</p><p><strong>选举Leader Sentinel</strong> </p><p>​当一个主服务器被判定为客观下线后，监视这个主服务器的所有Sentinel会通过选举算法(raft)，选出一个Leader Sentinel去执行**failover(故障转移)**操作。</p><p>​<strong>Raft算法</strong></p><p>​Raft协议是用来解决分布式系统一致性问题的协议。 Raft协议描述的节点共有三种状态:Leader, Follower, Candidate。 Raft协议将时间切分为一个个的Term(任期)，可以认为是一种“逻辑时间”。 选举流程:<br>     ①Raft采用心跳机制触发Leader选举系统启动后，全部节点初始化为Follower，term为0</p><p>​ ②节点如果收到了RequestVote或者AppendEntries，就会保持自己的Follower身份 </p><p>​ ③节点如果一段时间内没收到AppendEntries消息，在该节点的超时时间内还没发现Leader，Follower就会转换成Candidate，自己开始竞选Leader。 一旦转化为Candidate，该节点立即开始下面几件事情:<br>​–增加自己的term，启动一个新的定时器<br>​–给自己投一票，向所有其他节点发送RequestVote，并等待其他节点的回复。</p><p>​ ④如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时通过 AppendEntries，向其他节点发送通知。</p><p>​ ⑤每个节点在一个term内只能投一票，采取先到先得的策略，Candidate投自己， Follower会投给第一个收到RequestVote的节点。</p><p>​ ⑥Raft协议的定时器采取随机超时时间（选举的关键），先转为Candidate的节点会先发起投票，从而获得多数票。</p><p><strong>主服务器的选择</strong></p><p>​当选举出Leader Sentinel后，Leader Sentinel会根据以下规则去从服务器中选择出新的主服务器。</p><ol><li>过滤掉主观、客观下线的节点</li><li>选择配置slave-priority最高的节点，如果有则返回没有就继续选择</li><li>选择出复制偏移量最大的系节点，因为复制偏移量越大则数据复制的越完整</li><li>选择run_id最小的节点，因为run_id越小说明重启次数越少</li></ol><p><strong>故障转移</strong></p><p>​当Leader Sentinel完成新的主服务器选择后，Leader Sentinel会对下线的主服务器执行故障转移操作，主要有三个步骤:</p><p>​1、它会将失效 Master 的其中一个 Slave 升级为新的 Master , 并让失效 Master 的其他 Slave 改为复制新的 Master ;</p><p>​2、当客户端试图连接失效的 Master 时，集群会向客户端返回新 Master 的地址，使得集群当前状态只有一个Master。</p><p>​3、Master 和 Slave 服务器切换后， Master 的 redis.conf 、 Slave 的 redis.conf 和 sentinel.conf 的配置文件的内容都会发生相应的改变，即 Master 主服务器的 redis.conf配置文件中会多一行 replicaof 的配置， sentinel.conf 的监控目标会随之调换。</p><h4 id="4、集群模式-写多"><a href="#4、集群模式-写多" class="headerlink" title="4、集群模式&#x3D;写多"></a>4、集群模式&#x3D;写多</h4><p>​为了避免单一节点负载过高导致不稳定，集群模式采用<strong>一致性哈希算法或者哈希槽的方法</strong>将 Key 分布到各个节点上。其中，每个 Master 节点后跟若干个 Slave 节点，用于<strong>出现故障时做主备切换</strong>，客户端可以<strong>连接任意 Master 节点</strong>，集群内部会按照<strong>不同 key 将请求转发到不同的 Master</strong> 节点</p><p>​集群模式是如何实现高可用的呢？集群内部节点之间会<strong>互相定时探测</strong>对方是否存活，如果多数节点判断某个节点挂了，则会将其踢出集群，然后从 <strong>Slave</strong> 节点中选举出一个节点<strong>替补</strong>挂掉的 Master 节点。<strong>整个原理基本和哨兵模式一致</strong></p><p>​虽然集群模式避免了 Master 单节点的问题，但<strong>集群内同步数据时会占用一定的带宽</strong>。所以，只有在<strong>写操作比较多的情况下人们才使用集群模式</strong>，其他大多数情况，使用<strong>哨兵模式</strong>都能满足需求</p><h4 id="5、分布式锁"><a href="#5、分布式锁" class="headerlink" title="5、分布式锁"></a>5、分布式锁</h4><p><strong>利用Watch实现Redis乐观锁</strong></p><p>​乐观锁基于CAS(Compare And Swap)比较并替换思想，不会产生锁等待而消耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来实现乐观锁<strong>（秒杀）</strong>。具体思路如下:</p><p>1、利用redis的watch功能，监控这个redisKey的状态值<br>2、获取redisKey的值，创建redis事务，给这个key的值+1<br>3、执行这个事务，如果key的值被修改过则回滚，key不加1</p><p><strong>利用setnx防止库存超卖</strong><br>    分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁推荐使用set的方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(lockKey, requestId); <span class="comment">//如线程死掉，其他线程无法获取到锁</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁，非原子操作，可能会释放其他线程刚加上的锁</span></span><br><span class="line"><span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123; </span><br><span class="line">  jedis.del(lockKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推荐使用redis+lua脚本</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lua</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(lua, Collections.singletonList(lockKey),</span><br></pre></td></tr></table></figure><p><strong>分布式锁存在的问题</strong>：</p><ul><li><strong>客户端长时间阻塞导致锁失效问题</strong></li></ul><p>​计算时间内异步启动另外一个线程去检查的问题，这个key是否超时，当锁超时时间快到期且逻辑未执行完，延长锁超时时间。</p><ul><li><p>**Redis服务器时钟漂移问题导致同时加锁<br>redis的过期时间是依赖系统时钟的，如果时钟漂移过大时 理论上是可能出现的 **会影响到过期时间的计算。</p></li><li><p><strong>单点实例故障，锁未及时同步导致丢失</strong></p><p><strong>RedLock算法</strong></p></li></ul><ol><li><p>获取当前时间戳T0，配置时钟漂移误差T1</p></li><li><p>短时间内逐个获取全部N&#x2F;2+1个锁，结束时间点T2</p></li><li><p>实际锁能使用的处理时长变为：TTL - （T2 - T0）- T1</p><p>该方案通过多节点来<strong>防止Redis的单点故障</strong>，效果一般，也无法防止：</p></li></ol><ul><li><p><strong>主从切换导致的两个客户端同时持有锁</strong></p><p>大部分情况下<strong>持续时间极短</strong>，而且使用<strong>Redlock在切换的瞬间</strong>获取到节点的锁，也存在问题。已经是极低概率的时间，无法避免。<strong>Redis分布式锁适合幂等性事务</strong>，如果一定要<strong>保证安全</strong>，应该<strong>使用Zookeeper或者DB</strong>，但是，<strong>性能会急剧下降</strong>。</p></li></ul><p><strong>与zookeeper分布式锁对比</strong></p><ul><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li><li>zk 分布式锁，注册个监听器即可，不需要不断主动尝试获取锁，ZK获取锁会按照加锁的顺序，所以是公平锁，性能和mysql差不多，和redis差别大</li></ul><p><strong>Redission生产环境的分布式锁</strong></p><p>​Redisson是基于NIO的Netty框架上的一个Java驻内存数据网格(In-Memory Data Grid)分布式锁开源组件。 </p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glurlfrrp4j30qk0g876c.jpg" alt="image-20201221000119586" style="zoom:67%;" /><p>但当业务必须要数据的强一致性，即不允许重复获得锁，比如金融场景(重复下单，重复转账)，<strong>请不要使用redis分布式锁</strong>。可以使用CP模型实现，比如:<strong>zookeeper和etcd。</strong></p><table><thead><tr><th></th><th>Redis</th><th>zookeeper</th><th>etcd</th></tr></thead><tbody><tr><td>一致性算法</td><td>无</td><td>paxos(ZAB)</td><td>raft</td></tr><tr><td>CAP</td><td>AP</td><td>CP</td><td>CP</td></tr><tr><td>高可用</td><td>主从集群</td><td>n+1</td><td>n+1</td></tr><tr><td>实现</td><td>setNX</td><td>createNode</td><td>restfulAPI</td></tr></tbody></table><h4 id="6、redis心跳检测"><a href="#6、redis心跳检测" class="headerlink" title="6、redis心跳检测"></a>6、redis心跳检测</h4><p>在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送ACK命令:</p><p>​1、检测主从的连接状态 检测主从服务器的网络连接状态</p><p>​lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有 故障。</p><p>​2、辅助实现min-slaves,Redis可以通过配置防止主服务器在不安全的情况下执行写命令</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">min-slaves-to-write</span> <span class="number">3</span> <span class="string">(min-replicas-to-write</span> <span class="number">3</span> <span class="string">)</span></span><br><span class="line"></span><br><span class="line"><span class="string">min-slaves-max-lag</span> <span class="number">10</span> <span class="string">(min-replicas-max-lag</span> <span class="number">10</span><span class="string">)</span></span><br></pre></td></tr></table></figure><p>​上面的配置表示:从服务器的数量少于3个，或者三个从服务器的延迟(lag)值都大于或等于10 秒时，主服务器将拒绝执行写命令。</p><p>​3、检测命令丢失，增加重传机制</p><p>​如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发 送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量， 然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p><h3 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h3><h4 id="1、Redis优化"><a href="#1、Redis优化" class="headerlink" title="1、Redis优化"></a>1、Redis优化</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorm5m7b4gj30uy0hjwfp.jpg" alt="img"></p><p><strong>读写方式</strong><br>    简单来说就是不用<strong>keys</strong>等，用<strong>range、contains</strong>之类。比如，用户粉丝数，大 V 的粉丝更是高达几千万甚至过亿，因此，获取粉丝列表只能部分获取。另外在判断某用户是否关注了另外一个用户时，也只需要关注列表上进行检查判断，然后返回 True&#x2F;False 或 0&#x2F;1 的方式更为高效。</p><p><strong>KV size</strong><br>    如果单个业务的 KV size 过大，需要分拆成多个 KV 来缓存。拆分时应<strong>考虑访问频率</strong></p><p><strong>key 的数量</strong><br>    如果数据量巨大，则在缓存中尽可能只保留频繁访问的热数据，对于冷数据直接访问 DB。</p><p><strong>读写峰值</strong><br>    如果小于 10万 级别，简单分拆到独立 Cache 池即可<br>    如果达到 100万 级的QPS，则需要对 Cache 进行分层处理，可以同时使用 Local-Cache 配合远程 cache，甚至远程缓存内部继续分层叠加分池进行处理。<strong>（多级缓存）</strong></p><p><strong>命中率</strong><br>    缓存的命中率对整个服务体系的性能影响甚大。对于核心高并发访问的业务，需要预留足够的容量，确保核心业务缓存维持较高的命中率。比如微博中的 Feed Vector Cache（<strong>热点资讯</strong>），常年的命中率高达 99.5% 以上。为了持续保持缓存的命中率，缓存体系需要持续监控，及时进行故障处理或故障转移。同时在部分缓存节点异常、命中率下降时，故障转移方案，需要考虑是采用一致性 Hash 分布的访问漂移策略，还是采用数据多层备份策略。</p><p><strong>过期策略</strong></p><p>​可以设置较短的过期时间，让冷 key 自动过期；也可以让 key 带上时间戳，同时设置较长的过期时间，比如很多业务系统内部有这样一些 key：key_20190801。</p><p><strong>缓存穿透时间</strong><br>    平均缓存穿透加载时间在某些业务场景下也很重要，对于一些缓存穿透后，加载时间特别长或者需要复杂计算的数据，而且访问量还比较大的业务数据，要配置更多容量，维持更高的命中率，从而减少穿透到 DB 的概率，来确保整个系统的访问性能。</p><p><strong>缓存可运维性</strong><br>    对于缓存的可运维性考虑，则需要考虑缓存体系的集群管理，如何进行一键扩缩容，如何进行缓存组件的升级和变更，如何快速发现并定位问题，如何持续监控报警，最好有一个完善的运维平台，将各种运维工具进行集成。</p><p><strong>缓存安全性</strong><br>    对于缓存的安全性考虑，一方面可以限制来源 IP，只允许内网访问，同时加密鉴权访问。</p><h4 id="2、Redis热升级"><a href="#2、Redis热升级" class="headerlink" title="2、Redis热升级"></a>2、Redis热升级</h4><blockquote><p>在 Redis 需要升级版本或修复 bug 时，如果直接重启变更，由于需要数据恢复，这个过程需要近 10 分钟的时间，时间过长，会严重影响系统的可用性。面对这种问题，可以对 Redis 扩展热升级功能，从而在毫秒级完成升级操作，完全不影响业务访问。</p></blockquote><p>热升级方案如下，首先构建一个 Redis 壳程序，将 redisServer 的所有属性（包括redisDb、client等）保存为全局变量。然后将 Redis 的处理逻辑代码全部封装到动态连接库 so 文件中。Redis 第一次启动，从磁盘加载恢复数据，在后续升级时，通过指令，壳程序重新加载 Redis 新的 redis-4.so 到 redis-5.so 文件，即可完成功能升级，毫秒级完成 Redis 的版本升级。而且整个过程中，所有 Client 连接仍然保留，在升级成功后，原有 Client 可以继续进行读写操作，整个过程对业务完全透明。</p><h1 id="六、Kafka篇"><a href="#六、Kafka篇" class="headerlink" title="六、Kafka篇"></a>六、Kafka篇</h1><h3 id="Why-kafka"><a href="#Why-kafka" class="headerlink" title="Why kafka"></a>Why kafka</h3><p>消息队列的作用：<strong>异步、削峰填谷、解耦</strong></p><p><strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 <strong>RabbitMQ</strong> （开源、社区活跃）是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 <strong>RocketMQ</strong>（Java二次开发） 是很好的选择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 <strong>Kafka</strong> 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfiyienm0j30zu0hago7.jpg" alt="image-20210107225921930" style="zoom:50%;" /><p><strong>RabbitMQ</strong></p><p>RabbitMQ开始是用在电信业务的可靠通信的，也是少有的几款<strong>支持AMQP</strong>协议的产品之一。</p><p><strong>优点：</strong></p><ul><li>轻量级，快速，部署使用方便</li><li>支持灵活的路由配置。RabbitMQ中，在生产者和队列之间有一个交换器模块。根据配置的路由规则，生产者发送的消息可以发送到不同的队列中。路由规则很灵活，还可以自己实现。</li><li>RabbitMQ的客户端支持大多数的编程语言，支持<strong>AMQP</strong>协议。</li></ul><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfjicxzb2j30u80hx0uw.jpg" alt="image-20210107231826261" style="zoom:40%;" /><p><strong>缺点：</strong></p><ul><li>如果有大量消息堆积在队列中，性能会急剧下降</li><li>每秒处理几万到几十万的消息。如果应用要求高的性能，不要选择RabbitMQ。 </li><li>RabbitMQ是Erlang开发的，功能扩展和二次开发代价很高。</li></ul><p><strong>RocketMQ</strong></p><p>借鉴了Kafka的设计并做了很多改进，<strong>几乎具备了消息队列应该具备的所有特性和功能</strong>。</p><ul><li>RocketMQ主要用于有序，事务，流计算，消息推送，日志流处理，binlog分发等场景。</li><li>经过了历次的双11考验，性能，稳定性可靠性没的说。</li><li>java开发，阅读源代码、扩展、二次开发很方便。</li><li>对电商领域的响应延迟做了很多优化。</li><li>每秒处理几十万的消息，同时响应在毫秒级。如果应用很关注响应时间，可以使用RocketMQ。</li><li>性能比RabbitMQ高一个数量级，。</li><li>支持死信队列，DLX 是一个非常有用的特性。它可以处理<strong>异常情况下，消息不能够被消费者正确消费而被置入死信队列中</strong>的情况，后续分析程序可以通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以<strong>改善和优化系统</strong>。</li></ul><p><strong>缺点</strong>：</p><p>​跟周边系统的整合和兼容不是很好。</p><p><strong>Kafka</strong></p><p><strong>高可用</strong>，几乎所有相关的开源软件都支持，满足大多数的应用场景，尤其是<strong>大数据和流计算</strong>领域，</p><ul><li>Kafka高效，可伸缩，消息持久化。支持分区、副本和容错。</li><li>对批处理和异步处理做了大量的设计，因此Kafka可以得到非常高的性能。</li><li>每秒处理几十万异步消息消息，如果开启了压缩，最终可以达到每秒处理2000w消息的级别。</li><li>但是由于是异步的和批处理的，延迟也会高，不适合电商场景。</li></ul><h3 id="What-Kafka"><a href="#What-Kafka" class="headerlink" title="What Kafka"></a>What Kafka</h3><ul><li>Producer API：允许应用程序将记录流发布到一个或多个Kafka主题。</li><li>Consumer API：允许应用程序订阅一个或多个主题并处理为其生成的记录流。</li><li>Streams API：允许应用程序充当流处理器，将输入流转换为输出流。</li></ul><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gme95cirjfj31000kb41j.jpg" alt="image-20210106203420526" style="zoom: 40%;" /><p><strong>消息Message</strong></p><p>​Kafka的数据单元称为消息。可以把消息看成是数据库里的一个“数据行”或一条“记录”。</p><p><strong>批次</strong></p><p>​为了提高效率，消息被分批写入Kafka。提高吞吐量却加大了响应时间</p><p><strong>主题Topic</strong></p><p>​通过主题进行分类，类似数据库中的表，</p><p><strong>分区Partition</strong></p><p>​Topic可以被分成若干分区分布于kafka集群中，方便扩容</p><p>​单个分区内是有序的，partition设置为一才能保证全局有序</p><p><strong>副本Replicas</strong></p><p>​每个主题被分为若干个分区，每个分区有多个副本。</p><p><strong>生产者Producer</strong></p><p>​生产者在默认情况下把<strong>消息均衡地分布</strong>到主题的所有分区上：</p><ul><li>直接指定消息的分区</li><li>根据消息的key散列取模得出分区</li><li>轮询指定分区。</li></ul><p><strong>消费者Comsumer</strong></p><p>​消费者通过<strong>偏移量</strong>来区分已经读过的消息，从而消费消息。把每个分区最后读取的消息偏移量保存在Zookeeper 或Kafka上，如果消费者关闭或重启，它的<strong>读取状态不会丢失</strong>。</p><p><strong>消费组ComsumerGroup</strong></p><p>​消费组保证<strong>每个分区只能被一个消费者</strong>使用，避免重复消费。如果群组内一个<strong>消费者失效</strong>，消费组里的其他消费者可以<strong>接管失效消费者的工作再平衡</strong>，重新分区</p><p><strong>节点Broker</strong></p><p>​连接生产者和消费者，<strong>单个</strong>broker<strong>可以轻松处理</strong>数千个分区<strong>以及</strong>每秒百万级的消息量。</p><ul><li>broker接收来自生产者的消息，为消息设置偏移量，并提交<strong>消息到磁盘保存</strong>。</li><li>broker为消费者提供服务，响应读取分区的请求，<strong>返回已经提交到磁盘上的消息</strong>。</li></ul><p><strong>集群</strong></p><p>​每隔分区都有一个<strong>首领</strong>，当分区被分配给多个broker时，会通过首领进行<strong>分区复制</strong>。</p><p><strong>生产者Offset</strong></p><p>​消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。</p><p><strong>消费者Offset</strong></p><p>​不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响</p><p><strong>LogSegment</strong></p><ul><li>一个分区由多个LogSegment组成，</li><li>一个LogSegment由<code>.log .index .timeindex</code>组成</li><li><code>.log</code>追加是顺序写入的，文件名是以文件中第一条message的offset来命名的</li><li><code>.Index</code>进行日志删除的时候和数据查找的时候可以快速定位。</li><li><code>.timeStamp</code>则根据<strong>时间戳查找对应的偏移量</strong>。</li></ul><h3 id="How-Kafka"><a href="#How-Kafka" class="headerlink" title="How Kafka"></a>How Kafka</h3><p><strong>优点</strong></p><ul><li><strong>高吞吐量</strong>：单机每秒处理几十上百万的消息量。即使存储了TB及消息，也保持稳定的性能。<ul><li><strong>零拷贝</strong> 减少内核态到用户态的拷贝，磁盘通过sendfile实现<strong>DMA</strong> 拷贝Socket buffer</li><li><strong>顺序读写</strong> 充分利用磁盘顺序读写的超高性能</li><li><strong>页缓存mmap</strong>，将磁盘文件<strong>映射</strong>到内存, 用户通过修改内存就能修改磁盘文件。</li></ul></li><li><strong>高性能</strong>：单节点支持上千个客户端，并保证零停机和零数据丢失。</li><li><strong>持久化</strong>：将消息持久化到磁盘。通过将数据持久化到硬盘以及replication防止数据丢失。</li><li><strong>分布式系统</strong>，易扩展。所有的组件均为分布式的，无需停机即可扩展机器。</li><li><strong>可靠性</strong> - Kafka是分布式，分区，复制和容错的。</li><li><strong>客户端状态维护</strong>：消息被处理的状态是在Consumer端维护，当失败时能自动平衡。</li></ul><p><strong>应用场景</strong></p><ul><li><strong>日志收集：</strong>用Kafka可以收集各种服务的Log，通过大数据平台进行处理；</li><li><strong>消息系统：</strong>解耦生产者和消费者、缓存消息等；</li><li><strong>用户活动跟踪：</strong>Kafka经常被用来记录Web用户或者App用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到Kafka的Topic中，然后消费者通过订阅这些Topic来做<strong>运营数据</strong>的实时的监控分析，也可保存到数据库；</li></ul><h3 id="生产消费基本流程"><a href="#生产消费基本流程" class="headerlink" title="生产消费基本流程"></a><strong>生产消费基本流程</strong></h3><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmeb1cw09gj313m0kgwgb.jpg" alt="image-20210106213944461" style="zoom:40%;" /><ol><li><p>Producer创建时，会创建一个Sender线程并设置为守护线程。</p></li><li><p>生产的消息先经过拦截器-&gt;序列化器-&gt;分区器，然后将消息缓存在缓冲区。</p></li><li><p>批次发送的条件为：缓冲区数据大小达到<strong>batch.size</strong>或者<strong>linger.ms</strong>达到上限。</p></li><li><p>批次发送后，发往指定分区，然后落盘到broker；</p><ul><li><p><strong>acks&#x3D;0</strong>只要将消息放到缓冲区，就认为消息已经发送完成。</p></li><li><p><strong>acks&#x3D;1</strong>表示消息<strong>只需要写到主分区</strong>即可。在该情形下，如果主分区收到消息确认之后就宕机了，而副本分区还没来得及同步该消息，则该消息丢失。</p></li><li><p><strong>acks&#x3D;all （默认）</strong>首领分区会等待<strong>所有的ISR副本分区确认记录</strong>。该处理保证了只要有一个ISR副本分区存活，消息就不会丢失。</p></li></ul></li><li><p>如果生产者配置了<strong>retrires参数大于0并且未收到确认</strong>，那么客户端会对该消息进行重试。</p></li><li><p>落盘到broker成功，返回生产元数据给生产者。</p></li></ol><p><strong>Leader选举</strong></p><ul><li><p>Kafka会在Zookeeper上针对每个Topic维护一个称为ISR（in-sync replica）的集合</p></li><li><p>当集合中副本都跟Leader中的副本同步了之后，kafka才会认为消息已提交</p></li><li><p>只有这些跟Leader保持同步的Follower才应该被选作新的Leader</p></li><li><p>假设某个topic有N+1个副本，kafka可以容忍N个服务器不可用，冗余度较低</p><p>如果ISR中的副本都丢失了，则：</p><ul><li>可以等待ISR中的副本任何一个恢复，接着对外提供服务，需要时间等待</li><li>从OSR中选出一个副本做Leader副本，此时会造成数据丢失</li></ul></li></ul><p><strong>副本消息同步</strong></p><p>​首先，Follower 发送 FETCH 请求给 Leader。接着，Leader 会读取底层日志文件中的消 息数据，再更新它内存中的 Follower 副本的 LEO 值，更新为 FETCH 请求中的 fetchOffset 值。最后，尝试更新分区高水位值。Follower 接收到 FETCH 响应之后，会把消息写入到底层日志，接着更新 LEO 和 HW 值。</p><p><strong>相关概念</strong>：<strong>LEO</strong>和<strong>HW</strong>。</p><ul><li>LEO：即日志末端位移(log end offset)，记录了该副本日志中下一条消息的位移值。如果LEO&#x3D;10，那么表示该副本保存了10条消息，位移值范围是[0, 9]</li><li>HW：水位值HW（high watermark）即已备份位移。对于同一个副本对象而言，其HW值不会大于LEO值。小于等于HW值的所有消息都被认为是“已备份”的（replicated）</li></ul><p><strong>Rebalance</strong></p><ul><li>组成员数量发生变化</li><li>订阅主题数量发生变化</li><li>订阅主题的分区数发生变化</li></ul><p>leader选举完成后，当以上三种情况发生时，Leader根据配置的<strong>RangeAssignor</strong>开始分配消费方案，即哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案封装进<strong>SyncGroup</strong>请求中发给coordinator，非leader也会发SyncGroup请求，只是内容为空。coordinator接收到分配方案之后会把方案塞进SyncGroup的response中发给各个consumer。这样组内的所有成员就都知道自己应该消费哪些分区了。</p><p><strong>分区分配算法RangeAssignor</strong></p><ul><li><p>原理是按照消费者总数和分区总数进行整除运算平均分配给所有的消费者。</p></li><li><p>订阅Topic的消费者按照名称的字典序排序，分均分配，剩下的字典序从前往后分配</p></li></ul><p><strong>增删改查</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka --create --topic topic_x </span><br><span class="line">--partitions 1 --replication-factor 1</span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka --delete --topic topic_x</span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka --alter --topic topic_x</span><br><span class="line">--config max.message.bytes=1048576</span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka --describe --topic topic_x</span><br></pre></td></tr></table></figure><p><strong>如何查看偏移量为23的消息？</strong></p><p>通过查询跳跃表<code>ConcurrentSkipListMap</code>，定位到在00000000000000000000.index ，通过二分法在偏移量索引文件中找到不大于 23 的<strong>最大索引项</strong>，即offset 20 那栏，然后从日志分段文件中的物理位置为320 开始顺序查找偏移量为 23 的消息。</p><img src="https://img-blog.csdnimg.cn/20191230225447849.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjMzNzA2,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><p><strong>切分文件</strong></p><ul><li><strong>大小分片</strong> 当前日志分段文件的大小超过了 broker 端参数 <code>log.segment.bytes</code> 配置的值</li><li><strong>时间分片</strong> 当前日志分段中消息的最大时间戳与系统的时间戳的差值大于<code>log.roll.ms</code>配置的值</li><li><strong>索引分片</strong> 偏移量或时间戳索引文件大小达到broker端 <code>log.index.size.max.bytes</code>配置的值</li><li><strong>偏移分片</strong> 追加的消息的偏移量与当前日志分段的偏移量之间的差值大于 Integer.MAX_VALUE</li></ul><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><strong>幂等性</strong></p><p>保证在消息重发的时候，消费者不会重复处理。即使在<strong>消费者收到重复消息的时候，重复处理</strong>，也</p><p>要<strong>保证最终结果的一致性</strong>。所谓幂等性，数学概念就是： f(f(x)) &#x3D; f(x) </p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmefdeas1vj315i0bgmya.jpg" alt="image-20210107000942286"></p><p><strong>如何实现？</strong></p><p>​添加唯一ID，类似于数据库的主键，用于唯一标记一个消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProducerID：#在每个新的Producer初始化时，会被分配一个唯一的PID</span><br><span class="line">SequenceNumber：#对于每个PID发送数据的每个Topic都对应一个从0开始单调递增的SN值</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmefjpeet8j317e0cgmyp.jpg" alt="image-20210107001546404" style="zoom:80%;" /><p><strong>如何选举</strong></p><ol><li>使用 Zookeeper 的<strong>分布式锁选举控制器</strong>，并在节点加入集群或退出集群时通知控制器。</li><li>控制器负责在节点加入或离开集群时进行分区Leader选举。</li><li>控制器使用epoch<code>忽略小的纪元</code>来避免<strong>脑裂</strong>：两个节点同时认为自己是当前的控制器。</li></ol><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><ul><li>创建Topic的时候可以指定 –replication-factor 3 ，表示不超过broker的副本数</li><li>只有Leader是负责读写的节点，Follower定期地到Leader上Pull数据。</li><li>ISR是Leader负责维护的与其保持同步的Replica列表，即当前活跃的副本列表。如果一个Follow落后太多，Leader会将它从ISR中移除。选举时优先从ISR中挑选Follower。 </li><li>设置 acks&#x3D;all 。Leader收到了ISR中所有Replica的ACK，才向Producer发送ACK。</li></ul><h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><h4 id="线上问题rebalance"><a href="#线上问题rebalance" class="headerlink" title="线上问题rebalance"></a><strong>线上问题rebalance</strong></h4><blockquote><p>因集群架构变动导致的消费组内重平衡，如果kafka集内节点较多，比如数百个，那重平衡可能会耗时导致<strong>数分钟到数小时</strong>，此时kafka基本处于不可用状态，对kafka的TPS影响极大</p></blockquote><p>产生的原因：</p><ul><li><p>组成员数量发生变化</p></li><li><p>订阅主题数量发生变化</p></li><li><p>订阅主题的分区数发生变化</p><p><strong>组成员崩溃和组成员主动离开是两个不同的场景。</strong>因为在崩溃时成员并不会主动地告知coordinator此事，coordinator有可能需要一个完整的session.timeout周期(心跳周期)才能检测到这种崩溃，这必然会造成consumer的滞后。可以说离开组是主动地发起rebalance；而崩溃则是被动地发起rebalance。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooe9o07fvj30p00btju1.jpg" alt="img"></p></li></ul><p>解决方案：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">加大超时时间</span> <span class="string">session.timout.ms=6s</span></span><br><span class="line"><span class="attr">加大心跳频率</span> <span class="string">heartbeat.interval.ms=2s</span></span><br><span class="line"><span class="attr">增长推送间隔</span> <span class="string">max.poll.interval.ms=t+1 minutes</span></span><br></pre></td></tr></table></figure><p><a href="">这些年，为了进阿里背过的面试题</a></p><h4 id="ZooKeeper-的作用"><a href="#ZooKeeper-的作用" class="headerlink" title="ZooKeeper 的作用"></a>ZooKeeper 的作用</h4><p>目前，Kafka 使用 ZooKeeper 存放集群元数据、成员管理、Controller 选举，以及其他一些管理类任务。之后，等 KIP-500 提案完成后，Kafka 将完全不再依赖于 ZooKeeper。</p><ul><li><strong>存放元数据</strong>是指主题分区的所有数据都保存在 ZooKeeper 中，其他“人”都要与它保持对齐。</li><li><strong>成员管理</strong>是指 Broker 节点的注册、注销以及属性变更等 。</li><li><strong>Controller 选举</strong>是指选举集群 Controller，包括但不限于主题删除、参数配置等。</li></ul><p>一言以蔽之:<strong>KIP-500 ，是使用社区自研的基于 Raft 的共识算法，实现 Controller 自选举</strong>。</p><p>同样是存储元数据，这几年<strong>基于Raft算法的etcd</strong>认可度越来越高</p><p>​越来越多的系统开始用它保存关键数据。比如，<strong>秒杀系统经常用它保存各节点信息</strong>，以便控制消费 MQ 的服务数量。还有些<strong>业务系统的配置数据</strong>，也会通过 etcd 实时<strong>同步给业务系统的各节点</strong>，比如，秒杀管理后台会使用 etcd 将<strong>秒杀活动的配置数据实时同步给秒杀 API 服务各节点</strong>。</p><h4 id="Replica副本的作用"><a href="#Replica副本的作用" class="headerlink" title="Replica副本的作用"></a>Replica副本的作用</h4><p><strong>Kafka 只有 Leader 副本才能 对外提供读写服务，响应 Clients 端的请求。Follower 副本只是采用拉(PULL)的方 式，被动地同步 Leader 副本中的数据，并且在 Leader 副本所在的 Broker 宕机后，随时准备应聘 Leader 副本。</strong></p><ul><li><strong>自 Kafka 2.4 版本开始</strong>，社区可以通过配置参数，允许 Follower 副本有限度地提供读服务。</li><li>之前确保一致性的主要手段是高水位机制， 但高水位值无法保证 Leader 连续变更场景下的数据一致性，因此，社区引入了 <strong>Leader Epoch</strong> 机制，来修复高水位值的弊端。</li></ul><h4 id="为什么不支持读写分离"><a href="#为什么不支持读写分离" class="headerlink" title="为什么不支持读写分离?"></a>为什么不支持读写分离?</h4><ul><li><p><strong>自 Kafka 2.4 之后</strong>，Kafka 提供了有限度的读写分离。</p></li><li><p><strong>场景不适用</strong>。读写分离适用于那种读负载很大，而写操作相对不频繁的场景。</p></li><li><p><strong>同步机制</strong>。Kafka 采用 PULL 方式实现 Follower 的同步，同时复制延迟较大。</p></li></ul><h4 id="如何防止重复消费"><a href="#如何防止重复消费" class="headerlink" title="如何防止重复消费"></a>如何防止重复消费</h4><ul><li>代码层面每次消费需提交offset</li><li>通过Mysql的<strong>唯一键约束</strong>，结合Redis查看<strong>id是否被消费</strong>，存Redis可以直接使用set方法</li><li>量大且允许误判的情况下，使用布隆过滤器也可以</li></ul><h4 id="如何保证数据不会丢失"><a href="#如何保证数据不会丢失" class="headerlink" title="如何保证数据不会丢失"></a><strong>如何保证数据不会丢失</strong></h4><ul><li><strong>生产者</strong>生产消息可以通过comfirm配置<strong>ack&#x3D;all</strong>解决</li><li><strong>Broker</strong>同步过程中leader宕机可以通过配置<strong>ISR副本+重试</strong>解决</li><li><strong>消费者</strong>丢失可以<strong>关闭自动提交</strong>offset功能，系统处理完成时提交offset</li></ul><h4 id="如何保证顺序消费"><a href="#如何保证顺序消费" class="headerlink" title="如何保证顺序消费"></a><strong>如何保证顺序消费</strong></h4><ul><li>单 topic，单partition，单 consumer，单线程消费，吞吐量低，不推荐</li><li><strong>如只需保证单key有序</strong>，为每个key申请单独内存 queue，每个线程分别消费一个内存 queue 即可，这样就能保证单key（例如用户id、活动id）顺序性。</li></ul><h4 id="【线上】如何解决积压消费"><a href="#【线上】如何解决积压消费" class="headerlink" title="【线上】如何解决积压消费"></a>【线上】如何解决积压消费</h4><ul><li><strong>修复consumer</strong>，使其具备消费能力，并且扩容N台</li><li>写一个<strong>分发的程序</strong>，将Topic均匀分发到临时Topic中</li><li>同时<strong>起N台consumer</strong>，消费不同的<strong>临时Topic</strong></li></ul><h4 id="如何避免消息积压"><a href="#如何避免消息积压" class="headerlink" title="如何避免消息积压"></a>如何避免消息积压</h4><ul><li>提高消费并行度</li><li>批量消费</li><li>减少组件IO的交互次数</li><li>优先级消费</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxOffset - curOffset &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO 消息堆积情况的优先处理逻辑</span></span><br><span class="line">  <span class="comment">// 未处理的消息可以选择丢弃或者打日志</span></span><br><span class="line">  <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO 正常消费过程</span></span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br></pre></td></tr></table></figure><h4 id="如何设计消息队列"><a href="#如何设计消息队列" class="headerlink" title="如何设计消息队列"></a>如何设计消息队列</h4><p>需要支持快速水平扩容，broker+partition，partition放不同的机器上，增加机器时将数据根据topic做迁移，分布式需要考虑一致性、可用性、分区容错性</p><ul><li><strong>一致性：</strong>生产者的消息确认、消费者的幂等性、Broker的数据同步</li><li><strong>可用性：</strong>数据如何保证不丢不重、数据如何持久化、持久化时如何读写</li><li><strong>分区容错：</strong>采用何种选举机制、如何进行多副本同步</li><li><strong>海量数据：</strong>如何解决消息积压、海量Topic性能下降</li></ul><p>性能上，可以借鉴<strong>时间轮、零拷贝、IO多路复用、顺序读写、压缩批处理</strong></p><h1 id="七、Spring篇"><a href="#七、Spring篇" class="headerlink" title="七、Spring篇"></a>七、Spring篇</h1><h3 id="设计思想-Beans"><a href="#设计思想-Beans" class="headerlink" title="设计思想&amp;Beans"></a>设计思想&amp;Beans</h3><h4 id="1、IOC-控制反转"><a href="#1、IOC-控制反转" class="headerlink" title="1、IOC 控制反转"></a><strong>1、IOC 控制反转</strong></h4><p>​IoC（Inverse of Control:控制反转）是⼀种设计思想，就是将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 </p><p>​IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可，完全不⽤考虑对象是如何被创建出来的。</p><p><strong>DI 依赖注入</strong></p><p>​DI:（Dependancy Injection：依赖注入)站在容器的角度，将对象创建依赖的其他对象注入到对象中。</p><h4 id="2、AOP-动态代理"><a href="#2、AOP-动态代理" class="headerlink" title="2、AOP 动态代理"></a><strong>2、AOP 动态代理</strong></h4><p>​AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>​Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤基于asm框架字节流的Cglib动态代理 ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理。</p><h4 id="3、Bean生命周期"><a href="#3、Bean生命周期" class="headerlink" title="3、Bean生命周期"></a><strong>3、Bean生命周期</strong></h4><p><strong>单例对象：</strong> singleton                    </p><p>总结：单例对象的生命周期和容器相同        </p><p><strong>多例对象：</strong> prototype           </p><p>出生：使用对象时spring框架为我们创建            </p><p>活着：对象只要是在使用过程中就一直活着            </p><p>死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收</p><img src="https://s0.lgstatic.com/i/image3/M01/89/0C/Cgq2xl6WvHqAdmt4AABGAn2eSiI631.png" alt="img" style="zoom:67%;" /><p>IOC容器初始化加载Bean流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123; <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">  <span class="comment">// 第一步:刷新前的预处理 </span></span><br><span class="line">  prepareRefresh();</span><br><span class="line">  <span class="comment">//第二步: 获取BeanFactory并注册到 BeanDefitionRegistry</span></span><br><span class="line">  <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">  <span class="comment">// 第三步:加载BeanFactory的预准备工作(BeanFactory进行一些设置，比如context的类加载器等)</span></span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 第四步:完成BeanFactory准备工作后的前置处理工作 </span></span><br><span class="line">    postProcessBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 第五步:实例化BeanFactoryPostProcessor接口的Bean </span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">    <span class="comment">// 第六步:注册BeanPostProcessor后置处理器，在创建bean的后执行 </span></span><br><span class="line">    registerBeanPostProcessors(beanFactory);</span><br><span class="line">    <span class="comment">// 第七步:初始化MessageSource组件(做国际化功能;消息绑定，消息解析); </span></span><br><span class="line">    initMessageSource();</span><br><span class="line">    <span class="comment">// 第八步:注册初始化事件派发器 </span></span><br><span class="line">    initApplicationEventMulticaster();</span><br><span class="line">    <span class="comment">// 第九步:子类重写这个方法，在容器刷新的时候可以自定义逻辑 </span></span><br><span class="line">    onRefresh();</span><br><span class="line">    <span class="comment">// 第十步:注册应用的监听器。就是注册实现了ApplicationListener接口的监听器</span></span><br><span class="line">    registerListeners();</span><br><span class="line">    <span class="comment">//第十一步:初始化所有剩下的非懒加载的单例bean 初始化创建非懒加载方式的单例Bean实例(未设置属性)</span></span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    <span class="comment">//第十二步: 完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，完成创建</span></span><br><span class="line">    finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line">  ……</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>总结：</p><p><strong>四个阶段</strong></p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p><strong>多个扩展点</strong></p><ul><li>影响多个Bean<ul><li>BeanPostProcessor</li><li>InstantiationAwareBeanPostProcessor</li></ul></li><li>影响单个Bean<ul><li>Aware</li></ul></li></ul><p><strong>完整流程</strong>  </p><ol><li>实例化一个Bean－－也就是我们常说的<strong>new</strong>；</li><li>按照Spring上下文对实例化的Bean进行配置－－<strong>也就是IOC注入</strong>；</li><li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，也就是根据就是Spring配置文件中<strong>Bean的id和name进行传递</strong></li><li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现setBeanFactory(BeanFactory)也就是Spring配置文件配置的<strong>Spring工厂自身进行传递</strong>；</li><li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，和4传递的信息一样但是因为ApplicationContext是BeanFactory的子接口，所以<strong>更加灵活</strong></li><li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization()方法，BeanPostProcessor经常被用作是Bean内容的更改，由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于<strong>内存或缓存技</strong>术</li><li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li><li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization()，<strong>打印日志或者三级缓存技术里面的bean升级</strong></li><li>以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</li><li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，或者根据spring配置的destroy-method属性，调用实现的destroy()方法</li></ol><h4 id="4、Bean作用域"><a href="#4、Bean作用域" class="headerlink" title="4、Bean作用域"></a><strong>4</strong>、Bean作用域</h4><table><thead><tr><th>名称</th><th>作用域</th></tr></thead><tbody><tr><td><strong>singleton</strong></td><td><strong>单例对象，默认值的作用域</strong></td></tr><tr><td><strong>prototype</strong></td><td><strong>每次获取都会创建⼀个新的 bean 实例</strong></td></tr><tr><td>request</td><td>每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</td></tr><tr><td>session</td><td>在一次 HTTP session 中，容器将返回同一个实例</td></tr><tr><td>global-session</td><td>将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session</td></tr></tbody></table><p>默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题</p><p><strong>保障线程安全方法：</strong></p><ol><li><p>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</p></li><li><p>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中</p></li></ol><p> <strong>ThreadLocal</strong>：</p><p>  ​每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</p><p>  ​将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后<strong>在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象</strong>，避免了将这个对象作为参数传递的麻烦。</p><h4 id="5、循环依赖"><a href="#5、循环依赖" class="headerlink" title="5、循环依赖"></a>5、循环依赖</h4><p>​循环依赖其实就是循环引用，也就是两个或者两个以上的 Bean 互相持有对方，最终形成闭环。比如A 依赖于B，B又依赖于A</p><p>Spring中循环依赖场景有: </p><ul><li><p>prototype 原型 bean循环依赖</p></li><li><p>构造器的循环依赖（构造器注入）</p></li><li><p>Field 属性的循环依赖（set注入）</p><p>其中，构造器的循环依赖问题无法解决，在解决属性循环依赖时，可以使用懒加载，spring采用的是提前暴露对象的方法。</p></li></ul><p><strong>懒加载@Lazy解决循环依赖问题</strong></p><p>​Spring 启动的时候会把所有bean信息(包括XML和注解)解析转化成Spring能够识别的BeanDefinition并存到Hashmap里供下面的初始化时用，然后对每个 BeanDefinition 进行处理。普通 Bean 的初始化是在容器启动初始化阶段执行的，而被lazy-init&#x3D;true修饰的 bean 则是在从容器里第一次进行<strong>context.getBean() 时进行触发</strong>。</p><p>​     </p><p><strong>三级缓存解决循环依赖问题</strong></p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glv7ivru2lj31980qcn13.jpg" alt="循环依赖问题" style="zoom: 33%;" /><ol><li><p>Spring容器初始化ClassA通过构造器初始化对象后提前暴露到Spring容器中的singletonFactorys（三级缓存中）。</p></li><li><p>ClassA调用setClassB方法，Spring首先尝试从容器中获取ClassB，此时ClassB不存在Spring 容器中。</p></li><li><p>Spring容器初始化ClassB，ClasssB首先将自己暴露在三级缓存中，然后从Spring容器一级、二级、三级缓存中一次中获取ClassA 。</p></li><li><p>获取到ClassA后将自己实例化放入单例池中，实例 ClassA通过Spring容器获取到ClassB，完成了自己对象初始化操作。</p></li><li><p>这样ClassA和ClassB都完成了对象初始化操作，从而解决了循环依赖问题。</p></li></ol><h3 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h3><h4 id="1、-SpringBoot"><a href="#1、-SpringBoot" class="headerlink" title="1、@SpringBoot"></a>1、@SpringBoot</h4><p>​<strong>声明bean的注解</strong></p><p>​<strong>@Component</strong> 通⽤的注解，可标注任意类为  Spring 组件</p><p>​<strong>@Service</strong> 在业务逻辑层使用（service层）</p><p>​<strong>@Repository</strong> 在数据访问层使用（dao层）</p><p>​<strong>@Controller</strong> 在展现层使用，控制器的声明（controller层）</p><p>​<strong>注入bean的注解</strong></p><p>​<strong>@Autowired</strong>：默认按照类型来装配注入，**@Qualifier**：可以改成名称</p><p>​<strong>@Resource</strong>：默认按照名称来装配注入，JDK的注解，新版本已经弃用</p><p><strong>@Autowired注解原理</strong> </p><p>​ @Autowired的使用简化了我们的开发，</p><p>​实现 AutowiredAnnotationBeanPostProcessor 类，该类实现了 Spring 框架的一些扩展接口。<br>​实现 BeanFactoryAware 接口使其内部持有了 BeanFactory（可轻松的获取需要依赖的的 Bean）。<br>​实现 MergedBeanDefinitionPostProcessor 接口，实例化Bean 前获取到 里面的 @Autowired 信息并缓存下来；<br>​实现 postProcessPropertyValues 接口， 实例化Bean 后从缓存取出注解信息，通过反射将依赖对象设置到 Bean 属性里面。</p><p><strong>@SpringBootApplication</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(JpaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong>注解等同于下面三个注解：</p><ul><li><strong>@SpringBootConfiguration：</strong> 底层是<strong>Configuration</strong>注解，说白了就是支持<strong>JavaConfig</strong>的方式来进行配置</li><li><strong>@EnableAutoConfiguration：</strong>开启<strong>自动配置</strong>功能</li><li><strong>@ComponentScan：</strong>就是<strong>扫描</strong>注解，默认是扫描<strong>当前类下</strong>的package</li></ul><p>其中<code>@EnableAutoConfiguration</code>是关键(启用自动配置)，内部实际上就去加载<code>META-INF/spring.factories</code>文件的信息，然后筛选出以<code>EnableAutoConfiguration</code>为key的数据，加载到IOC容器中，实现自动配置功能！</p><p>它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。</p><p> <strong>@EnableAutoConfiguration作用：</strong></p><p>它主要利用了一个</p><p>EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration </span><br></pre></td></tr></table></figure><h4 id="2、-SpringMVC"><a href="#2、-SpringMVC" class="headerlink" title="2、@SpringMVC"></a><strong>2、@SpringMVC</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> 声明该类为SpringMVC中的Controller</span><br><span class="line"><span class="meta">@RequestMapping</span> 用于映射Web请求</span><br><span class="line"><span class="meta">@ResponseBody</span> 支持将返回值放在response内，而不是一个页面，通常用户返回json数据</span><br><span class="line"><span class="meta">@RequestBody</span> 允许request的参数在request体中，而不是在直接连接在地址后面。</span><br><span class="line"><span class="meta">@PathVariable</span> 用于接收路径参数</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello/&#123;name&#125;&quot;)</span>申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</span><br></pre></td></tr></table></figure><p><strong>SpringMVC原理</strong> </p><img src="https://img-blog.csdn.net/20181022224058617?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F3YWtlX2xxaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom: 50%;" /><ol><li>客户端（浏览器）发送请求，直接请求到  DispatcherServlet 。</li><li>DispatcherServlet 根据请求信息调⽤  HandlerMapping ，解析请求对应的  Handler 。</li><li>解析到对应的  Handler （也就是  Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li><li>HandlerAdapter 会根据  Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回⼀个  ModelAndView 对象， Model 是返回的数据对象</li><li>ViewResolver 会根据逻辑  View 查找实际的  View 。</li><li>DispaterServlet 把返回的  Model 传给  View （视图渲染）。</li><li>把  View 返回给请求者（浏览器）</li></ol><h4 id="3、-SpringMybatis"><a href="#3、-SpringMybatis" class="headerlink" title="3、@SpringMybatis"></a>3、@SpringMybatis</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span> ： 插入sql ,和xml insert sql语法完全一样</span><br><span class="line"><span class="meta">@Select</span> ： 查询sql, 和xml select sql语法完全一样</span><br><span class="line"><span class="meta">@Update</span> ： 更新sql, 和xml update sql语法完全一样</span><br><span class="line"><span class="meta">@Delete</span> ： 删除sql, 和xml delete sql语法完全一样</span><br><span class="line"><span class="meta">@Param</span> ： 入参</span><br><span class="line"><span class="meta">@Results</span> ： 设置结果集合<span class="meta">@Result</span> ： 结果</span><br><span class="line"><span class="meta">@ResultMap</span> ： 引用结果集合</span><br><span class="line"><span class="meta">@SelectKey</span> ： 获取最新插入id </span><br></pre></td></tr></table></figure><p><strong>mybatis如何防止sql注入？</strong></p><p>​简单的说就是#{}是经过预编译的，是安全的，**$<strong>{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。在编写mybatis的映射语句时，尽量采用</strong>“#{xxx}”<strong>这样的格式。如果需要实现动态传入表名、列名，还需要做如下修改：添加属性</strong>statementType&#x3D;”STATEMENT”<strong>，同时sql里的属有变量取值都改成</strong>${xxxx}**</p><p><strong>Mybatis和Hibernate的区别</strong> </p><p><strong>Hibernate 框架：</strong> </p><p>​    <strong>Hibernate</strong>是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。</p><p><strong>Mybatis框架：</strong></p><p>​    <strong>Mybatis</strong>是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。</p><p><strong>区别：</strong></p><p>  <strong>开发方面</strong></p><p>​    在项目开发过程当中，就速度而言：</p><p>​      hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；</p><p>​      Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；</p><p>​    但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。</p><p>  <strong>sql优化方面</strong></p><p>​    Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；</p><p>​    Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；</p><p>  <strong>对象管理比对</strong></p><p>​    Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</p><p>​    Mybatis 需要自行管理映射关系；</p><h4 id="4、-Transactional"><a href="#4、-Transactional" class="headerlink" title="4、@Transactional"></a>4、@Transactional</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span> </span><br><span class="line"><span class="meta">@Transactional</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><p>​①事务函数中不要处理耗时任务，会导致长期占有数据库连接。</p><p>​②事务函数中不要处理无关业务，防止产生异常导致事务回滚。</p><p><strong>事务传播属性</strong></p><p><strong>1) REQUIRED（默认属性）</strong> 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 </p><ol start="2"><li><p>MANDATORY  支持当前事务，如果当前没有事务，就抛出异常。 </p></li><li><p>NEVER  以非事务方式执行，如果当前存在事务，则抛出异常。 </p></li><li><p>NOT_SUPPORTED  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </p></li><li><p>REQUIRES_NEW  新建事务，如果当前存在事务，把当前事务挂起。 </p></li><li><p>SUPPORTS  支持当前事务，如果当前没有事务，就以非事务方式执行。</p></li></ol><p><strong>7) NESTED</strong> （<strong>局部回滚</strong>） 支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 <strong>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</strong></p><h3 id="Spring源码阅读"><a href="#Spring源码阅读" class="headerlink" title="Spring源码阅读"></a>Spring源码阅读</h3><h4 id="1、Spring中的设计模式"><a href="#1、Spring中的设计模式" class="headerlink" title="1、Spring中的设计模式"></a><strong>1、Spring中的设计模式</strong></h4><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd">spring中的设计模式</a></p><p><strong>单例设计模式 :</strong> Spring 中的 Bean 默认都是单例的。</p><p><strong>⼯⼚设计模式 :</strong> Spring使⽤⼯⼚模式通过  BeanFactory 、 ApplicationContext 创建bean 对象。</p><p><strong>代理设计模式 :</strong> Spring AOP 功能的实现。</p><p><strong>观察者模式：</strong> Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</p><p><strong>适配器模式：</strong>Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</p><h1 id="八、SpringCloud篇"><a href="#八、SpringCloud篇" class="headerlink" title="八、SpringCloud篇"></a>八、SpringCloud篇</h1><h4 id="Why-SpringCloud"><a href="#Why-SpringCloud" class="headerlink" title="Why SpringCloud"></a>Why SpringCloud</h4><blockquote><p>​Spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如<strong>服务发现注册</strong>、<strong>配置中心</strong>、<strong>消息总线</strong>、<strong>负载均衡</strong>、<strong>断路器</strong>、<strong>数据监控</strong>等，都可以用 spring boot 的开发风格做到一键启动和部署。</p></blockquote><table><thead><tr><th>SpringCloud（微服务解决方案）</th><th>Dubbo（分布式服务治理框架）</th></tr></thead><tbody><tr><td>Rest API （轻量、灵活、swagger）</td><td>RPC远程调用（高效、耦合）</td></tr><tr><td>Eureka、Nacos</td><td>Zookeeper</td></tr><tr><td>使用方便</td><td>性能好</td></tr><tr><td>即将推出SpringCloud2.0</td><td>断档5年后17年重启</td></tr></tbody></table><p>​SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,<strong>旨在快速搭建单个微服务</strong>，SpringCloud是依赖于SpringBoot的,而SpringBoot并不是依赖与SpringCloud,甚至还可以和Dubbo进行优秀的整合开发</p><p>​MartinFlower 提出的微服务之间是通过RestFulApi进行通信，具体实现</p><ul><li>RestTemplate：基于HTTP协议</li><li>Feign：封装了ribbon和Hystrix 、RestTemplate 简化了客户端开发工作量</li><li>RPC：基于TCP协议，序列化和传输效率提升明显</li><li>MQ：异步解耦微服务之间的调用</li></ul><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmawejgpgwj30ht0bnt9d.jpg" alt="img" style="zoom:67%;" /><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><blockquote><p>Spring Boot 通过<strong>简单的步骤</strong>就可以创建一个 Spring 应用。</p><p>Spring Boot 为 Spring 整合第三方框架提供了<strong>开箱即用功能</strong>。</p><p>Spring Boot 的核心思想是<strong>约定大于配置</strong>。</p></blockquote><p><strong>Spring Boot 解决的问题</strong></p><ul><li><p>搭建后端框架时需要手动添加 Maven 配置，涉及很多 XML 配置文件，增加了搭建难度和时间成本。</p></li><li><p>将项目编译成 war 包，部署到 Tomcat 中，项目部署依赖 Tomcat，这样非常不方便。</p></li><li><p>应用监控做的比较简单，通常都是通过一个没有任何逻辑的接口来判断应用的存活状态。</p></li></ul><p><strong>Spring Boot 优点</strong></p><p><strong>自动装配：</strong>Spring Boot 会根据某些规则对所有配置的 Bean 进行初始化。可以减少了很多重复性的工作。</p><p>​比如使用 MongoDB 时，只需加入 MongoDB 的 Starter 包，然后配置  的连接信息，就可以直接使用 MongoTemplate 自动装配来操作数据库了。简化了 Maven Jar 包的依赖，降低了烦琐配置的出错几率。</p><p><strong>内嵌容器：</strong>Spring Boot 应用程序可以不用部署到外部容器中，比如 Tomcat。</p><p>​应用程序可以直接通过 Maven 命令编译成可执行的 jar 包，通过 java-jar 命令启动即可，非常方便。</p><p><strong>应用监控：</strong>Spring Boot 中自带监控功能 Actuator，可以实现对程序内部运行情况进行监控，</p><p>​比如 Bean 加载情况、环境变量、日志信息、线程信息等。当然也可以自定义跟业务相关的监控，通过Actuator 的端点信息进行暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-starter-web          <span class="comment">//用于快速构建基于 Spring MVC 的 Web 项目。</span></span><br><span class="line">spring-boot-starter-data-redis   <span class="comment">//用于快速整合并操作 Redis。</span></span><br><span class="line">spring-boot-starter-data-mongodb <span class="comment">//用于对 MongoDB 的集成。</span></span><br><span class="line">spring-boot-starter-data-jpa     <span class="comment">//用于操作 MySQL。</span></span><br></pre></td></tr></table></figure><p><strong>自定义一个Starter</strong></p><ol><li><p>创建 Starter 项目，定义 Starter 需要的配置（Properties）类，比如数据库的连接信息；</p></li><li><p>编写自动配置类，自动配置类就是获取配置，根据配置来自动装配 Bean；</p></li><li><p>编写 spring.factories 文件加载自动配置类，Spring 启动的时候会扫描 spring.factories 文件，；</p></li><li><p>编写配置提示文件 spring-configuration-metadata.json（不是必须的），在添加配置的时候，我们想要知道具体的配置项是什么作用，可以通过编写提示文件来提示；</p></li><li><p>在项目中引入自定义 Starter 的 Maven 依赖，增加配置值后即可使用。</p></li></ol><p><strong>Spring Boot Admin</strong>（将 actuator 提供的数据进行可视化）</p><ul><li><p>显示应用程序的监控状态、查看 JVM 和线程信息</p></li><li><p>应用程序上下线监控  </p></li><li><p>可视化的查看日志、动态切换日志级别</p></li><li><p>HTTP 请求信息跟踪等实用功能</p></li></ul><h4 id="GateWay-Zuul"><a href="#GateWay-Zuul" class="headerlink" title="GateWay &#x2F; Zuul"></a>GateWay &#x2F; Zuul</h4><blockquote><p>GateWay⽬标是取代Netflflix Zuul，它基于Spring5.0+SpringBoot2.0+WebFlux等技术开发，提供<strong>统⼀的路由</strong>⽅式（反向代理）并且基于 <strong>Filter</strong>(定义过滤器对请求过滤，完成⼀些功能) 链的⽅式提供了⽹关基本的功能，例如：鉴权、流量控制、熔断、路径重写、⽇志监控。</p></blockquote><p><strong>组成：</strong></p><ul><li><p><strong>路由route：</strong> ⽹关最基础的⼯作单元。路由由⼀个ID、⼀个⽬标URL、⼀系列的断⾔（匹配条件判断）和Filter过滤器组成。如果断⾔为true，则匹配该路由。</p></li><li><p><strong>断⾔predicates：</strong>参考了Java8中的断⾔Predicate，匹配Http请求中的所有内容（类似于nginx中的location匹配⼀样），如果断⾔与请求相匹配则路由。</p></li><li><p><strong>过滤器filter：</strong>标准的Spring webFilter，使⽤过滤器在请求之前或者之后执⾏业务逻辑。</p><p>请求前<code>pre</code>类型过滤器：做<strong>参数校验</strong>、<strong>权限校验</strong>、<strong>流量监控</strong>、<strong>⽇志输出</strong>、<strong>协议转换</strong>等，</p><p>请求前<code>post</code>类型的过滤器：做<strong>响应内容</strong>、<strong>响应头</strong>的修改、<strong>⽇志的输出</strong>、<strong>流量监控</strong>等。</p></li></ul><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmc49l9babj31do0n7n13.jpg" alt="image-20210105001419761" style="zoom: 50%;" /><p><strong>GateWayFilter</strong> 应⽤到单个路由路由上 、<strong>GlobalFilter</strong> 应⽤到所有的路由上</p><h4 id="Eureka-Zookeeper"><a href="#Eureka-Zookeeper" class="headerlink" title="Eureka &#x2F; Zookeeper"></a>Eureka &#x2F; Zookeeper</h4><blockquote><p>服务注册中⼼本质上是为了解耦服务提供者和服务消费者，为了⽀持弹性扩缩容特性，⼀个微服务的提供者的数量和分布往往是动态变化的。</p></blockquote><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmawwm3k7bj30o80ecq3u.jpg" alt="image-20210103231405882" style="zoom: 50%;" /><table><thead><tr><th>区别</th><th>Zookeeper</th><th>Eureka</th><th>Nacos</th></tr></thead><tbody><tr><td>CAP</td><td>CP</td><td>AP</td><td>CP&#x2F;AP切换</td></tr><tr><td>可用性</td><td>选举期间不可用</td><td>自我保护机制，数据不是最新的</td><td></td></tr><tr><td>组成</td><td>Leader和Follower</td><td>节点平等</td><td></td></tr><tr><td>优势</td><td>分布式协调</td><td>注册与发现</td><td>注册中心和配置中心</td></tr><tr><td>底层</td><td>进程</td><td>服务</td><td>Jar包</td></tr></tbody></table><p><strong>Eureka</strong>通过<strong>⼼跳检测</strong>、<strong>健康检查</strong>和<strong>客户端缓存</strong>等机制，提⾼系统的灵活性、可伸缩性和可⽤性。</p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaxc493qyj30ji0a6mxx.jpg" alt="image-20210103232900353" style="zoom:67%;" /><ol><li>us-east-1c、us-east-1d，us-east-1e代表不同的机房，<strong>每⼀个Eureka Server都是⼀个集群</strong>。</li><li>Service作为服务提供者向Eureka中注册服务，Eureka接受到注册事件会在<strong>集群和分区中进⾏数据同步</strong>，Client作为消费端（服务消费者）可以从Eureka中获取到服务注册信息，进⾏服务调⽤。</li><li>微服务启动后，会周期性地向Eureka<strong>发送⼼跳</strong>（默认周期为30秒）以续约⾃⼰的信息</li><li>Eureka在⼀定时间内<strong>（默认90秒）没有接收</strong>到某个微服务节点的⼼跳，Eureka将会注销该微服务节点</li><li>Eureka Client<strong>会缓存Eureka Server中的信息</strong>。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使⽤缓存中的信息找到服务提供者</li></ol><p><strong>Eureka缓存</strong></p><blockquote><p>新服务上线后，服务消费者<strong>不能立即访问</strong>到刚上线的新服务，需要过⼀段时间后才能访问？或是将服务下线后，服务还是会被调⽤到，⼀段时候后<strong>才彻底停⽌服务</strong>，访问前期会导致频繁报错！</p></blockquote><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaxmk97q0j30vw0j6gmu.jpg" alt="image-20210103233902439" style="zoom:50%;" /><p>​服务注册到注册中⼼后，服务实例信息是<strong>存储在Registry表</strong>中的，也就是内存中。但Eureka为了提⾼响应速度，在内部做了优化，加⼊了两层的缓存结构，将Client需要的实例信息，直接缓存起来，获取的时候直接从缓存中拿数据然后响应给 Client。 </p><ul><li><p>第⼀层缓存是<strong>readOnlyCacheMap</strong>，采⽤<strong>ConcurrentHashMap</strong>来存储数据的，主要负责定时与readWriteCacheMap进⾏数据同步，默认同步时间为 <strong>30</strong> 秒⼀次。</p></li><li><p>第⼆层缓存是<strong>readWriteCacheMap</strong>，采⽤<strong>Guava</strong>来实现缓存。缓存过期时间默认为<strong>180</strong>秒，当服务<strong>下线、过期、注册、状态变更</strong>等操作都会清除此缓存中的数据。</p></li><li><p>如果两级缓存都无法查询，会<strong>触发缓存的加载</strong>，从存储层拉取数据到缓存中，然后再返回给 Client。</p><p>Eureka之所以设计⼆级缓存机制，也是为了<strong>提⾼ Eureka Server 的响应速度</strong>，缺点是缓存会导致 Client<strong>获取不到最新的服务实例信息</strong>，然后导致⽆法快速发现新的服务和已下线的服务。</p></li></ul><p><strong>解决方案</strong></p><ul><li>我们可以<strong>缩短读缓存的更新时间</strong>让服务发现变得更加及时，或者<strong>直接将只读缓存关闭</strong>，同时可以缩短客户端如ribbon服务的定时刷新间隔，多级缓存也导致C层⾯（数据⼀致性）很薄弱。</li><li>Eureka Server 中会有<strong>定时任务去检测失效</strong>的服务，将服务实例信息从注册表中移除，也可以将这个失效检测的<strong>时间缩短</strong>，这样服务下线后就能够及时从注册表中清除。</li></ul><p><strong>自我保护机制开启条件</strong></p><ul><li>期望最小每分钟能够续租的次数（实例* 频率 * 比例&#x3D;&#x3D;10* 2 *0.85）</li><li>期望的服务实例数量（10）</li></ul><p><strong>健康检查</strong></p><ul><li><p>Eureka Client 会定时发送心跳给 Eureka Server 来证明自己处于健康的状态</p></li><li><p>集成SBA以后可以把所有健康状态信息一并返回给eureka</p></li></ul><h4 id="Feign-Ribbon"><a href="#Feign-Ribbon" class="headerlink" title="Feign &#x2F; Ribbon"></a>Feign &#x2F; Ribbon</h4><ul><li>Feign 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡，</li><li>Feign 可以与 Hystrix 组合使用，支持熔断回退</li><li>Feign 可以与ProtoBuf实现快速的RPC调用</li></ul><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmbxsh2rfnj30uo0fgmxz.jpg" alt="img" style="zoom:80%;" /><ul><li><p><strong>InvocationHandlerFactory 代理</strong></p><p>采用 JDK 的动态代理方式生成代理对象，当我们调用这个接口，实际上是要去调用远程的 HTTP API</p></li><li><p><strong>Contract 契约组件</strong></p><p>比如请求类型是 GET 还是 POST，请求的 URI 是什么</p></li><li><p><strong>Encoder 编码组件 \ Decoder 解码组件</strong></p><p>通过该组件我们可以将请求信息采用指定的编码方式进行编解码后传输</p></li><li><p><strong>Logger 日志记录</strong></p><p>负责 Feign 中记录日志的，可以指定 Logger 的级别以及自定义日志的输出</p></li><li><p><strong>Client 请求执行组件</strong></p><p>负责 HTTP 请求执行的组件，Feign 中默认的 Client 是通过 JDK 的 HttpURLConnection 来发起请求的，在每次发送请求的时候，都会创建新的 HttpURLConnection 链接，Feign 的性能会很差，可以通过扩展该接口，使用 Apache HttpClient 等基于连接池的高性能 HTTP 客户端。</p></li><li><p><strong>Retryer 重试组件</strong></p><p>负责重试的组件，Feign 内置了重试器，当 HTTP 请求出现 IO 异常时，Feign 会限定一个最大重试次数来进行重试操作。</p></li><li><p><strong>RequestInterceptor 请求拦截器</strong></p><p>可以为 Feign 添加多个拦截器，在请求执行前设置一些扩展的参数信息。</p></li></ul><p><strong>Feign最佳使用技巧</strong></p><ul><li><p>继承特性</p></li><li><p>拦截器</p><p>比如添加指定的请求头信息，这个可以用在服务间传递某些信息的时候。</p></li><li><p>GET 请求多参数传递</p></li><li><p>日志配置</p><p>FULL 会输出全部完整的请求信息。</p></li><li><p>异常解码器</p><p>异常解码器中可以获取异常信息，而不是简单的一个code，然后转换成对应的异常对象返回。</p></li><li><p>源码查看是如何继承Hystrix</p><p>HystrixFeign.builder 中可以看到继承了 Feign 的 Builder，增加了 Hystrix的SetterFactory， build 方法里，对 invocationHandlerFactory 进行了重写， create 的时候<strong>返回HystrixInvocationHandler</strong>， 在 invoke 的时候<strong>会将请求包装成 HystrixCommand</strong> 去执行，这里就自然的集成了 Hystrix</p></li></ul><p><strong>Ribbon</strong></p><img src="http://s0.lgstatic.com/i/image2/M01/93/96/CgotOV2Nux-AO2PcAAEcl4M1Zi4629.png" alt="img" style="zoom: 50%;" /><p><strong>使用方式</strong></p><ul><li><p><strong>原生 API</strong>，Ribbon 是 Netflix 开源的，没有使用 Spring Cloud，需要使用 Ribbon 的原生 API。</p></li><li><p><strong>Ribbon + RestTemplate</strong>，整合Spring Cloud 后，可以基于 RestTemplate 提供负载均衡的服务</p></li><li><p><strong>Ribbon + Feign</strong></p><img src="http://s0.lgstatic.com/i/image2/M01/93/76/CgoB5l2NuyCALoefAAAdV1DlSHY088.png" alt="img" style="zoom: 67%;" /></li></ul><p><strong>负载均衡算法</strong></p><ul><li><p>RoundRobinRule 是<strong>轮询的算法</strong>，A和B轮流选择。</p></li><li><p>RandomRule 是<strong>随机算法</strong>，这个就比较简单了，在服务列表中随机选取。</p></li><li><p>BestAvailableRule 选择一个最<strong>小的并发请求 server</strong></p></li></ul><p><strong>自定义负载均衡算法</strong></p><ul><li>实现 Irule 接口</li><li>继承 AbstractLoadBalancerRule 类</li></ul><p><strong>自定义负载均衡使用场景</strong>（核心）</p><ul><li><p><strong>灰度发布</strong></p><p>灰度发布是能够平滑过渡的一种发布方式，在发布过程中，先发布一部分应用，让指定的用户使用刚发布的应用，等到测试没有问题后，再将其他的全部应用发布。如果新发布的有问题，只需要将这部分恢复即可，不用恢复所有的应用。</p></li><li><p><strong>多版本隔离</strong></p><p>多版本隔离跟灰度发布类似，为了兼容或者过度，某些应用会有多个版本，这个时候如何保证 1.0 版本的客户端不会调用到 1.1 版本的服务，就是我们需要考虑的问题。</p></li><li><p><strong>故障隔离</strong></p><p>当线上某个实例发生故障后，为了不影响用户，我们一般都会先留存证据，比如：线程信息、JVM 信息等，然后将这个实例重启或直接停止。然后线下根据一些信息分析故障原因，如果我能做到故障隔离，就可以直接将出问题的实例隔离，不让正常的用户请求访问到这个出问题的实例，只让指定的用户访问，这样就可以单独用特定的用户来对这个出问题的实例进行测试、故障分析等。</p></li></ul><h4 id="Hystrix-Sentinel"><a href="#Hystrix-Sentinel" class="headerlink" title="Hystrix &#x2F; Sentinel"></a>Hystrix &#x2F; Sentinel</h4><p><strong>服务雪崩场景</strong></p><p>自己即是服务消费者，同时也是服务提供者，同步调用等待结果导致资源耗尽</p><p><strong>解决方案</strong></p><p>服务方：扩容、限流，排查代码问题，增加硬件监控</p><p>消费方：使用Hystrix资源隔离，熔断降级，快速失败</p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmby7y9ykzj30wr0ehac5.jpg" alt="img" style="zoom:150%;" /><p><strong>Hystrix断路保护器的作用</strong></p><ul><li><strong>封装请求</strong>会将用户的操作进行统一封装，统一封装的目的在于进行统一控制。</li><li><strong>资源隔离限流</strong>会将对应的资源按照指定的类型进行隔离，比如<strong>线程池</strong>和<strong>信号量</strong>。<ul><li>计数器限流，例如5秒内技术1000请求，超数后限流，未超数重新计数</li><li>滑动窗口限流，解决计数器不够精确的问题，把一个窗口拆分多滚动窗口</li><li>令牌桶限流，类似景区售票，售票的速度是固定的，拿到令牌才能去处理请求</li><li>漏桶限流，生产者消费者模型，实现了恒定速度处理请求，能够绝对防止突发流量</li></ul></li><li><strong>失败回退</strong>其实是一个备用的方案，就是说当请求失败后，有没有备用方案来满足这个请求的需求。</li><li><strong>断路器</strong>这个是<strong>最核心</strong>的，，如果断路器处于打开的状态，那么所有请求都将失败，执行回退逻辑。如果断路器处于关闭状态，那么请求将会被正常执行。有些场景我们需要手动<strong>打开断路器强制降级</strong>。</li><li><strong>指标监控</strong>会对请求的生<strong>命周期进行监控</strong>，请求成功、失败、超时、拒绝等状态，都会被监控起来。</li></ul><p><strong>Hystrix使用上遇到的坑</strong></p><ul><li><p>配置可以对接<strong>配置中心</strong>进行动态调整</p><p>Hystrix 的配置项非常多，如果不对接配置中心，所有的配置只能在代码里修改，在集群部署的难以应对紧急情况，我们项目只设置一个 CommandKey，其他的都在配置中心进行指定，紧急情况如需隔离部分请求时，只需在配置中心进行修改以后，强制更新即可。</p></li><li><p>回退逻辑中可以<strong>手动埋点</strong>或者通过<strong>输出日志</strong>进行告警</p><p>当请求失败或者超时，会执行回退逻辑，如果有大量的回退，则证明某些服务出问题了，这个时候我们可以在回退的逻辑中进行埋点操作，上报数据给监控系统，也可以输出回退的日志，统一由日志收集的程序去进行处理，这些方式都可以将问题暴露出去，然后通过实时数据分析进行告警操作</p></li><li><p>用 <strong>ThreadLocal</strong>配合<strong>线程池隔离</strong>模式需当心</p><p>当我们用了线程池隔离模式的时候，被隔离的方法会包装成一个 Command 丢入到独立的线程池中进行执行，这个时候就是从 A 线程切换到了 B 线程，ThreadLocal 的数据就会丢失</p></li><li><p><strong>Gateway中</strong>多用信号量隔离</p><p>网关是所有请求的入口，路由的服务数量会很多，几十个到上百个都有可能，如果用线程池隔离，那么需要创建上百个独立的线程池，开销太大，用信号量隔离开销就小很多，还能起到限流的作用。</p></li></ul><p>[^常见问题]: Hystrix的超时时间要⼤于Ribbon的超时时间，因为Hystrix将请求包装了起来，特别需要注意的是，如果Ribbon开启了重试机制，⽐如重试3 次，Ribbon 的超时为 1 秒，那么Hystrix 的超时时间应该⼤于 3 秒，否则就会出现 Ribbon 还在重试中，⽽ Hystrix 已经超时的现象。</p><p><strong>Sentinel</strong> </p><blockquote><p>Sentinel是⼀个⾯向云原⽣微服务的流量控制、熔断降级组件。</p><p>替代Hystrix，针对问题：服务雪崩、服务降级、服务熔断、服务限流</p></blockquote><p>Hystrix区别：</p><ul><li>独⽴可部署Dashboard（基于 Spring Boot 开发）控制台组件</li><li>不依赖任何框架&#x2F;库，减少代码开发，通过UI界⾯配置即可完成细粒度控制</li></ul><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmbza4zixbj30kl09sq4p.jpg" alt="image-20210104212151598" style="zoom:80%;" /><p><strong>丰富的应⽤场景</strong>：Sentinel 承接了阿⾥巴巴近 10 年的双⼗⼀⼤促流量的核⼼场景，例如秒杀、消息削峰填⾕、集群流量控制、实时熔断下游不可⽤应⽤等。</p><p><strong>完备的实时监控</strong>：可以看到500 台以下规模的集群的汇总也可以看到单机的秒级数据。</p><p><strong>⼴泛的开源⽣态：</strong>与 SpringCloud、Dubbo的整合。您只需要引⼊相应的依赖并进⾏简单的配置即可快速地接⼊ Sentinel。</p><p><strong>区别：</strong></p><ul><li>Sentinel不会像Hystrix那样放过⼀个请求尝试⾃我修复，就是明明确确按照时间窗⼝来，熔断触发后，时间窗⼝内拒绝请求，时间窗⼝后就恢复。</li><li>Sentinel Dashboard中添加的规则数据存储在内存，微服务停掉规则数据就消失，在⽣产环境下不合适。可以将Sentinel规则数据持久化到Nacos配置中⼼，让微服务从Nacos获取。</li></ul><table><thead><tr><th>#</th><th>Sentinel</th><th>Hystrix</th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离</td><td>线程池隔离&#x2F;信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于响应时间或失败比率</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>不支持</td></tr><tr><td>流量整形</td><td>支持慢启动、匀速器模式</td><td>不支持</td></tr><tr><td>系统负载保护</td><td>支持</td><td>不支持</td></tr><tr><td>控制台</td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><h4 id="Config-Nacos"><a href="#Config-Nacos" class="headerlink" title="Config &#x2F; Nacos"></a>Config &#x2F; Nacos</h4><blockquote><p>Nacos是阿⾥巴巴开源的⼀个针对微服务架构中<strong>服务发现</strong>、<strong>配置管理</strong>和<strong>服务管理平台</strong>。</p><p>Nacos就是<strong>注册中⼼+配置中⼼</strong>的组合（Nacos&#x3D;Eureka+Confifig+Bus）</p></blockquote><p><strong>Nacos</strong>功能特性</p><ul><li>服务发现与健康检查</li><li>动态配置管理</li><li>动态DNS服务</li><li>服务和元数据管理</li></ul><p><strong>保护阈值：</strong></p><p>当服务A健康实例数&#x2F;总实例数 &lt; 保护阈值 的时候，说明健康实例真的不多了，这个时候保护阈值会被触发（状态true），nacos将会把该服务所有的实例信息（健康的+不健康的）全部提供给消费者，消费者可能访问到不健康的实例，请求失败，但这样也⽐造成雪崩要好，牺牲了⼀些请求，保证了整个系统的⼀个可⽤。</p><p><strong>Nacos</strong> 数据模型（领域模型）</p><ul><li><strong>Namespace</strong> 代表不同的环境，如开发dev、测试test、⽣产环境prod</li><li><strong>Group</strong> 代表某项⽬，⽐如爪哇云项⽬</li><li><strong>Service</strong> 某个项⽬中具体xxx服务</li><li><strong>DataId</strong> 某个项⽬中具体的xxx配置⽂件</li></ul><p>可以通过 Spring Cloud 原⽣注解 <code>@RefreshScope</code> 实现配置⾃动更新</p><h4 id="Bus-Stream"><a href="#Bus-Stream" class="headerlink" title="Bus &#x2F; Stream"></a>Bus &#x2F; Stream</h4><blockquote><p>Spring Cloud Stream 消息驱动组件帮助我们更快速，更⽅便的去构建<strong>消息驱动</strong>微服务的</p><p>本质：屏蔽掉了底层不同<strong>MQ</strong>消息中间件之间的差异，统⼀了<strong>MQ</strong>的编程模型，降低了学习、开发、维护<strong>MQ</strong>的成本，⽬前⽀持Rabbit、Kafka两种消息</p></blockquote><h4 id="Sleuth-Zipkin"><a href="#Sleuth-Zipkin" class="headerlink" title="Sleuth &#x2F; Zipkin"></a><strong>Sleuth &#x2F; Zipkin</strong></h4><p><strong>全链路追踪</strong></p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmc3avezqrj30xb0lw76z.jpg" alt="image-20210104234058218" style="zoom:67%;" /><p><strong>Trace ID</strong>：当请求发送到分布式系统的⼊⼝端点时，Sleuth为该请求创建⼀个唯⼀的跟踪标识Trace ID，在分布式系统内部流转的时候，框架始终保持该唯⼀标识，直到返回给请求⽅</p><p><strong>Span ID</strong>：为了统计各处理单元的时间延迟，当请求到达各个服务组件时，也是通过⼀个唯⼀标识SpanID来标记它的开始，具体过程以及结束。</p><p>Spring Cloud Sleuth （追踪服务框架）可以追踪服务之间的调⽤，Sleuth可以记录⼀个服务请求经过哪些服务、服务处理时⻓等，根据这些，我们能够理清各微服务间的调⽤关系及进⾏问题追踪分析。</p><p><strong>耗时分析</strong>：通过 Sleuth 了解采样请求的耗时，分析服务性能问题（哪些服务调⽤⽐较耗时）</p><p><strong>链路优化</strong>：发现频繁调⽤的服务，针对性优化等</p><p><strong>聚合展示</strong>：数据信息发送给 Zipkin 进⾏聚合，利⽤ Zipkin 存储并展示数据。</p><h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a><strong>安全认证</strong></h3><ul><li><p>Session</p><p>认证中最常用的一种方式，也是最简单的。存在<strong>多节点session丢失</strong>的情况，可通过<strong>nginx粘性Cookie</strong>和Redis集中式Session存储解决</p></li><li><p>HTTP Basic Authentication </p><p>服务端针对请求头中base64加密的Authorization 和用户名和密码进行<strong>校验</strong>。</p></li><li><p>Token</p><p>Session 只是一个 key，<strong>会话信息存储在后端</strong>。而 Token 中会存储用户的信息，然后通过加密算法进行加密，只有服务端才能解密，<strong>服务端拿到 Token 后进行解密获取用户信息</strong>。</p></li><li><p>JWT认证</p></li></ul><blockquote><p>JWT（JSON Web Token）用户提供用户名和密码给认证服务器，服务器验证用户提交信息的合法性；如果验证成功，会产生并返回一个 Token，用户可以使用这个 Token 访问服务器上受保护的资源。</p></blockquote><img src="http://s0.lgstatic.com/i/image2/M01/AB/87/CgotOV3WUG2ARl98AAD_xcd-ElM857.png" alt="img" style="zoom:70%;" /><ol><li>认证服务提供认证的 API，校验用户信息，返回认证结果</li><li>通过JWTUtils中的RSA算法，生成JWT token，token里封装用户id和有效期</li><li>服务间参数通过请求头进行传递，服务内部通过 ThreadLocal 进行上下文传递。</li><li>Hystrix导致ThreadLocal失效的问题可以通过，重写 Hystrix 的 Callable 方法，传递需要的数据。</li></ol><p><strong>Token最佳实践</strong></p><ul><li><p>设置<strong>较短（合理）的过期时间</strong>。</p></li><li><p>注销的 Token <strong>及时清除</strong>（放入 Redis 中做一层过滤）。</p><p>虽然不能修改 Token 的信息，但是能在验证层面做一层过滤来进行处理。</p></li><li><p>监控 Token 的<strong>使用频率</strong>。</p><p>为了防止数据被别人爬取，最常见的就是监控使用频率，程序写出来的爬虫程序访问频率是有迹可循的 </p></li><li><p>核心功能敏感操作可以使用<strong>动态验证</strong>（验证码）。</p><p>比如提现的功能，要求在提现时再次进行验证码的验证，防止不是本人操作。</p></li><li><p><strong>网络环境、浏览器</strong>信息等识别。</p><p>银行 APP 对环境有很高的要求，使用时如果断网，APP 会自动退出，重新登录，因为网络环境跟之前使用的不一样了，还有一些浏览器的信息之类的判断，这些都是可以用来保证后端 API 的安全。</p></li><li><p><strong>加密密钥</strong>支持动态修改。</p><p>如果 Token 的加密密钥泄露了，也就意味着别人可以伪造你的 Token，可以将密钥存储在配置中心，以支持动态修改刷新，需要注意的是建议在流量低峰的时候去做更换的操作，否则 Token 全部失效，所有在线的请求都会重新申请 Token，并发量会比较大。</p></li></ul><h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p><strong>痛点：</strong></p><ul><li><p>服务数量多，业务变动频繁，一周一发布</p></li><li><p>灰度发布能降低发布失败风险，<strong>减少影响范围</strong></p><p>通过灰度发布，先让一部分用户体验新的服务，或者只让测试人员进行测试，等功能正常后再全部发布，这样能降低发布失败带来的影响范围。 </p></li><li><p>当发布出现故障时，可以<strong>快速回滚</strong>，不影响用户</p><p>灰度后如果发现这个节点有问题，那么只需回滚这个节点即可，当然不回滚也没关系，通过灰度策略隔离，也不会影响正常用户</p></li></ul><p>可以通过Ribbon的负载均衡策略进行灰度发布，可以使用更可靠的Discovery</p><p><strong>Discovery</strong></p><blockquote><p>基于Discovery 服务注册发现、Ribbon 负载均衡、Feign 和 RestTemplate 调用等组件的企业级微服务开源解决方案，包括灰度发布、灰度路由、服务隔离等功能</p></blockquote><img src="https://s0.lgstatic.com/i/image3/M01/54/41/CgpOIF3nXSaAB9bRAAE8rktrUyY037.png" alt="img" style="zoom:50%;" /><ol><li><p>首先将需要发布的服务从转发过程中移除，等流量剔除之后再发布。</p></li><li><p>部分机器中的版本进行升级，用户默认还是请求老的服务，通过版本来支持测试请求。</p></li><li><p>测试完成之后，让新的版本接收正常流量，然后部署下一个节点，以此类推。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grayVersions = &#123;<span class="string">&quot;discovery-article-service&quot;</span>:[<span class="string">&quot;1.01&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><h3 id="多版本隔离"><a href="#多版本隔离" class="headerlink" title="多版本隔离"></a>多版本隔离</h3><img src="https://s0.lgstatic.com/i/image3/M01/54/41/Cgq2xl3nXSeAZMTOAAE2sCaIhPE668.png" alt="img" style="zoom:50%;" /><p><strong>本地复用测试服务</strong>-Eureka Zone亮点</p><p>​<strong>region</strong> 地理上的分区，比如北京、上海等</p><p>​<strong>zone</strong> 可以简单理解为 region 内的具体机房</p><p>​在调用的过程中会优先选择相同的 zone 发起调用，当找不到相同名称的 zone 时会选择其他的 zone 进行调用，我们可以利用这个特性来解决本地需要启动多个服务的问题。</p><p>[^]: 当你访问修改的服务 A 时，这个服务依赖了 B、C 两个服务，B 和 C 本地没有启动，B 和 C 找不到相同的 zone 就会选择其他的 zone 进行调用，也就是会调用到测试环境部署的 B 和 C 服务，这样一来就解决了本地部署多个服务的问题。</p><h4 id="各组件调优"><a href="#各组件调优" class="headerlink" title="各组件调优"></a><strong>各组件调优</strong></h4><p>当你对网关进行压测时，会发现并发量一直上不去，错误率也很高。因为你用的是默认配置，这个时候我们就需要去调整配置以达到最优的效果。</p><p>首先我们可以对容器进行调优，最常见的就是<strong>内置的 Tomcat</strong> 容器了，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accept-count <span class="comment">//请求队列排队数</span></span><br><span class="line">server.tomcat.max-threads <span class="comment">//最大线程数</span></span><br><span class="line">server.tomcat.max-connections <span class="comment">//最大连接数</span></span><br></pre></td></tr></table></figure><p><strong>Hystrix</strong> 的信号量（semaphore）隔离模式，并发量上不去很大的原因都在这里，信号量默认值是 100，也就是最大并发只有 100，超过 100 就得等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量</span></span><br><span class="line">zuul.semaphore.max-semaphores <span class="comment">//信号量：最大并发数</span></span><br><span class="line"><span class="comment">//线程池</span></span><br><span class="line">hystrix.threadpool.<span class="keyword">default</span>.coreSize <span class="comment">//最大线程数</span></span><br><span class="line">hystrix.threadpool.<span class="keyword">default</span>.maximumSize <span class="comment">//队列的大</span></span><br><span class="line">hystrix.threadpool.<span class="keyword">default</span>.maxQueueSize <span class="comment">//等参数</span></span><br></pre></td></tr></table></figure><p>配置<strong>Gateway</strong>并发信息，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gateway.host.max-per-route-connections <span class="comment">//每个路由的连接数 </span></span><br><span class="line">gateway.host.max-total-connections <span class="comment">//总连接数</span></span><br></pre></td></tr></table></figure><p>调整<strong>Ribbon</strong> 的并发配置，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ribbon.MaxConnectionsPerHost <span class="comment">//单服务并发数</span></span><br><span class="line">ribbon.MaxTotalConnections   <span class="comment">//总并发数</span></span><br></pre></td></tr></table></figure><p>修改<strong>Feign</strong>默认的HttpURLConnection 替换成 httpclient 来提高性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">feign.httpclient.max-connections-per-route<span class="comment">//每个路由的连接数</span></span><br><span class="line">feign.httpclient.max-connections <span class="comment">//总连接数</span></span><br></pre></td></tr></table></figure><p>Gateway+配置中心实现动态路由</p><p>Feign+配置中心实现动态日志</p><h1 id="九、分布式篇"><a href="#九、分布式篇" class="headerlink" title="九、分布式篇"></a><strong>九、分布式篇</strong></h1><blockquote><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p></blockquote><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a><strong>发展历程</strong></h3><ul><li><p>入口级负载均衡</p><ul><li>网关负载均衡</li><li>客户端负载均衡</li></ul></li><li><p>单应用架构</p><ul><li>应用服务和数据服务分离</li><li>应用服务集群</li><li>应用服务中心化SAAS</li></ul></li><li><p>数据库主备读写分离</p><ul><li>全文搜索引擎加快数据统计</li><li>缓存集群缓解数据库读压力</li><li>分布式消息中间件缓解数据库写压力</li><li>数据库水平拆分适应微服务</li><li>数据库垂直拆分解决慢查询</li></ul></li><li><p>划分上下文拆分微服务</p><ul><li>服务注册发现（Eureka、Nacos）</li><li>配置动态更新（Config、Apollo）</li><li>业务灰度发布（Gateway、Feign）</li><li>统一安全认证（Gateway、Auth）</li><li>服务降级限流（Hystrix、Sentinel）</li><li>接口检查监控（Actuator、Prometheus）</li><li>服务全链路追踪（Sleuth、Zipkin）</li></ul></li></ul><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li><strong>一致性</strong>（2PC、3PC、Paxos、Raft）<ul><li>强一致性：<strong>数据库一致性</strong>，牺牲了性能<ul><li><strong>ACID</strong>：原子性、一致性、隔离性、持久性</li></ul></li><li>弱一致性：<strong>数据库和缓存</strong>，<strong>延迟双删、重试</strong></li><li>单调读一致性：<strong>缓存一致性</strong>，ID或者IP哈希</li><li>最终一致性：<strong>边缘业务</strong>，消息队列</li></ul></li><li><strong>可用性</strong>（多级缓存、读写分离）<ul><li><strong>BASE</strong> 基本可用：限流导致响应速度慢、降级导致用户体验差<ul><li>Basically Availabe 基本可用  </li><li>Soft state 软状态</li><li>Eventual Consistency 最终一致性</li></ul></li></ul></li><li>分区容忍性（一致性Hash解决扩缩容问题）</li></ul><h3 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h3><h4 id="XA方案"><a href="#XA方案" class="headerlink" title="XA方案"></a>XA方案</h4><p><strong>2PC</strong>协议：两阶段提交协议，P是指<strong>准备</strong>阶段，C是指<strong>提交</strong>阶段</p><ul><li>准备阶段：询问是否可以开始，写Undo、Redo日志，收到响应</li><li>提交阶段：执行Redo日志进行<strong>Commit</strong>，执行Undo日志进行<strong>Rollback</strong></li></ul><p><strong>3PC</strong>协议：将提交阶段分为<strong>CanCommit</strong>、<strong>PreCommit</strong>、<strong>DoCommit</strong>三个阶段</p><p><strong>CanCommit</strong>：发送canCommit请求，并开始等待</p><p><strong>PreCommit</strong>：收到全部Yes，写Undo、Redo日志。超时或者No，则中断</p><p><strong>DoCommit</strong>：执行Redo日志进行<strong>Commit</strong>，执行Undo日志进行<strong>Rollback</strong> </p><p>区别是第二步，参与者<strong>自身增加了超时</strong>，如果<strong>失败可以及时释放资源</strong></p><h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a><strong>Paxos算法</strong></h4><blockquote><p>如何在一个发生异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致</p></blockquote><p>​参与者（例如Kafka）的一致性可以由协调者（例如Zookeeper）来保证，<strong>协调者的一致性就只能由Paxos保证了</strong></p><p>Paxos算法中的角色：</p><ul><li><strong>Client</strong>：客户端、例如，对分布式文件服务器中文件的写请求。</li><li><strong>Proposer</strong>：提案发起者，根据Accept返回选择最大N对应的V，发送[N+1,V]</li><li><strong>Acceptor</strong>：决策者，Accept以后会拒绝小于N的提案，并把自己的[N,V]返回给Proposer</li><li><strong>Learners</strong>：最终决策的学习者、学习者充当该协议的复制因素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法约束</span></span><br><span class="line">P1:一个Acceptor必须接受它收到的第一个提案。</span><br><span class="line"><span class="comment">//考虑到半数以上才作数，一个Accpter得接受多个相同v的提案</span></span><br><span class="line">P2a:如果某个v的提案被accept，那么被Acceptor接受编号更高的提案必须也是v</span><br><span class="line">P2b:如果某个v的提案被accept，那么从Proposal提出编号更高的提案必须也是v</span><br><span class="line"><span class="comment">//如何确保v的提案Accpter被选定后，Proposal都能提出编号更高的提案呢</span></span><br><span class="line">针对任意的[Mid,Vid]，有半数以上的Accepter集合S，满足以下二选一：</span><br><span class="line">  S中接受的提案都大于Mid</span><br><span class="line">  S中接受的提案若小于Mid，编号最大的那个值为Vid</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmlato63bnj319m0u0wmi.jpg" alt="image-20210112225118095"></p><p>面试题：如何保证Paxos算法活性</p><p>​假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的提案，导致最终陷入死循环，没有value被选定</p><ul><li><strong>通过选取主Proposer</strong>，规定只有主Proposer才能提出议案。只要主Proposer和过半的Acceptor能够正常网络通信，主Proposer提出一个编号更高的提案，该提案终将会被批准。</li><li>每个Proposer发送提交提案的时间设置为<strong>一段时间内随机</strong>，保证不会一直死循环</li></ul><h4 id="ZAB算法"><a href="#ZAB算法" class="headerlink" title="ZAB算法"></a><strong>ZAB算法</strong></h4><h4 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h4><blockquote><p>Raft 是一种为了管理复制日志的一致性算法</p></blockquote><p>Raft使用<strong>心跳机制</strong>来触发选举。当server启动时，初始状态都是<strong>follower</strong>。每一个server都有一个定时器，超时时间为election timeout（<strong>一般为150-300ms</strong>），如果某server<strong>没有超时的情况下收到</strong>来自领导者或者候选者的任何消息，<strong>定时器重启</strong>，如果超时，它就<strong>开始一次选举</strong>。</p><p><strong>Leader异常</strong>：异常期间Follower会超时选举，完成后Leader比较彼此步长</p><p><strong>Follower异常：</strong>恢复后直接同步至Leader当前状态</p><p><strong>多个Candidate：</strong>选举时失败，失败后超时继续选举</p><h4 id="数据库和Redis的一致性"><a href="#数据库和Redis的一致性" class="headerlink" title="数据库和Redis的一致性"></a>数据库和Redis的一致性</h4><p><strong>全量缓存保证高效读取</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u2g0qkvj31500la0uf.jpg" alt="image-20211205121457205" style="zoom: 50%;" /><p>所有数据都存储在缓存里，读服务在查询时不会再降级到数据库里，所有的请求都完全依赖缓存。此时，因降级到数据库导致的毛刺问题就解决了。但全量缓存并<strong>没有解决更新时的分布式事务</strong>问题，反而把问题放大了。因为全量缓存<strong>对数据更新要求更加严格</strong>，要求所有数据库<strong>已有数据和实时更新</strong>的数据必须完全同步至缓存，不能有遗漏。对于此问题，一种有效的方案是采用<strong>订阅数据库的 Binlog</strong> 实现数据同步</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u9jj094j31c60padiu.jpg" alt="image-20211205121611997" style="zoom:50%;" /><p>​现在很多开源工具（如<strong>阿里的 Canal</strong>等）可以模拟主从复制的协议。通过模拟协议读取主数据库的 Binlog 文件，从而获取主库的所有变更。对于这些变更，它们开放了各种接口供业务服务获取数据。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2ugzh9ohj31hc0g00ud.jpg" alt="image-20211205121730145" style="zoom:50%;" /><p>​将 Binlog 的中间件挂载至目标数据库上，就可以<strong>实时获取该数据库的所有变更数据</strong>。对这些变更数据解析后，便可<strong>直接写入缓存里</strong>。优点还有：</p><ul><li><p>大幅提升了读取的速度，降低了延迟</p></li><li><p>Binlog 的主从复制是基于 <strong>ACK</strong> 机制， 解决了分布式事务的问题</p><p>如果同步缓存失败了，被消费的 Binlog 不会被确认，下一次会重复消费，数据最终会写入缓存中</p></li></ul><p><strong>缺点</strong>不可避免：1、增加复杂度 2、消耗缓存资源 3、需要筛选和压缩数据 4、极端情况数据丢失</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u6ltwa4j314s0hs765.jpg" alt="image-20211205121850418" style="zoom:50%;" /><p>可以通过异步校准方案进行补齐，但是会损耗数据库性能。但是此方案会隐藏中间件使用错误的细节，线上环境前期更重要的是记录日志排查在做后续优化，不能本末倒置。</p><h3 id="可用性-1"><a href="#可用性-1" class="headerlink" title="可用性"></a>可用性</h3><h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a><strong>心跳检测</strong></h4><blockquote><p>以<strong>固定的频率</strong>向其他节点汇报当前节点状态的方式。收到心跳，说明网络和节点的状态是健康的。心跳汇报时，一般会携带一些附加的<strong>状态、元数据，以便管理</strong></p></blockquote><p><strong>周期检测心跳机制</strong>：超时未返回</p><p><strong>累计失效检测机制</strong>：重试超次数</p><h4 id="多机房实时热备"><a href="#多机房实时热备" class="headerlink" title="多机房实时热备"></a><strong>多机房实时热备</strong></h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2ufbmlkmj31fw0mutc1.jpg" alt="image-20211205122631299" style="zoom:50%;" /><p>两套缓存集群可以分别部署到不同城市的机房。读服务也相应地部署到不同城市或不同分区。在承接请求时，不同机房或分区的读服务只依赖同样属性的缓存集群。此方案有两个好处。</p><ol><li><strong>提升了性能。</strong>读服务不要分层，读服务要尽可能地和缓存数据源靠近。</li><li><strong>增加了可用。</strong>当单机房出现故障时，可以秒级将所有流量都切换至存活的机房或分区</li></ol><p>此方案虽然带来了性能和可用性的提升，但代价是资源成本的上升。</p><h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><blockquote><p>分布式系统对于错误包容的能力</p></blockquote><p>通过限流、降级、兜底、重试、负载均衡等方式增强系统的健壮性</p><h4 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><p><img src="https://i.loli.net/2021/01/14/fmYEJy9N7Zjp2Xd.png" alt="image-20210114154435003"></p><ol><li><strong>Leader</strong>把指令添加到日志中，发起 RPC 给其他的服务器，让他们复制这条信息</li><li><strong>Leader</strong>会不断的重试，直到所有的 Follower响应了ACK并复制了所有的日志条目</li><li>通知所有的<strong>Follower</strong>提交，同时Leader该表这条日志的状态，并返回给客户端</li></ol><h4 id="主备（Master-Slave）"><a href="#主备（Master-Slave）" class="headerlink" title="主备（Master-Slave）"></a><strong>主备（Master-Slave）</strong></h4><p>​主机宕机时，备机接管主机的一切工作，主机恢复正常后，以自动（<strong>热备</strong>）或手动（<strong>冷备</strong>）方式将服务切换到主机上运行，<strong>Mysql</strong>和<strong>Redis</strong>中常用。</p><p>​MySQL之间数据复制的基础是<strong>二进制日志文件</strong>（binary log fifile）。它的数据库中所有操作都会以<strong>“事件”</strong>的方式记录在二进制日志中，其他数据库作为slave通过一个<strong>I&#x2F;O线程与主服务器保持通信</strong>，并<strong>监控</strong>master的二进制日志文件的变化，如果发现master二进制日志文件<strong>发生变化</strong>，则会把变化复制到自己的<strong>中继日志</strong>中，然后slave的一个SQL线程会把相关的“事件”<strong>执行</strong>到自己的数据库中，以此实现从数据库和主数据库的<strong>一致性</strong>，也就实现了<strong>主从复制</strong></p><h4 id="互备（Active-Active）"><a href="#互备（Active-Active）" class="headerlink" title="互备（Active-Active）"></a><strong>互备（Active-Active）</strong></h4><p>​指两台主机<strong>同时运行</strong>各自的服务工作且<strong>相互监测</strong>情况。在数据库高可用部分，常见的互备是<strong>MM</strong>模式。MM模式即<strong>Multi-Master</strong>模式，指一个系统存在多个master，每个master都具有<strong>read-write</strong>能力，会根据<strong>时间戳</strong>或<strong>业务逻辑</strong>合并版本。</p><h4 id="集群（Cluster）模式"><a href="#集群（Cluster）模式" class="headerlink" title="集群（Cluster）模式"></a><strong>集群（Cluster）模式</strong></h4><p>​是指有多个节点在运行，同时可以通过主控节点<strong>分担服务</strong>请求。如Zookeeper。集群模式需要解决主控节点<strong>本身的高可用</strong>问题，一般采用主备模式。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="XA方案-1"><a href="#XA方案-1" class="headerlink" title="XA方案"></a>XA方案</h4><p><strong>两阶段提交</strong> | <strong>三阶段提交</strong></p><ul><li>准备阶段的资源锁定，存在性能问题，严重时会造成死锁问题</li><li>提交事务请求后，出现网络异常，部分数据收到并执行，会造成一致性问</li></ul><h4 id="TCC方案"><a href="#TCC方案" class="headerlink" title="TCC方案"></a>TCC方案</h4><p><strong>Try Confirm Cancel &#x2F; 短事务</strong></p><ul><li><p><strong>Try</strong> 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong></p></li><li><p><strong>Confirm</strong> 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong></p></li><li><p><strong>Cancel</strong> 阶段：如果任何一个服务的业务方法执行出错，那么就需要<strong>进行补偿</strong>&#x2F;回滚</p></li></ul><h4 id="Saga方案"><a href="#Saga方案" class="headerlink" title="Saga方案"></a><strong>Saga方案</strong></h4><p>事务性补偿 &#x2F; 长事务</p><ul><li>流程<strong>长</strong>、流程<strong>多</strong>、调用第三方业务</li></ul><h4 id="本地消息表（eBay）"><a href="#本地消息表（eBay）" class="headerlink" title="本地消息表（eBay）"></a><strong>本地消息表（eBay）</strong></h4><h4 id="MQ最终一致性"><a href="#MQ最终一致性" class="headerlink" title="MQ最终一致性"></a><strong>MQ最终一致性</strong></h4><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmr1k3dfbxj31h00pkjy8.jpg" alt="image-20210117220405706" style="zoom:50%;" /><p>比如阿里的 RocketMQ 就支持消息事务（核心：<strong>双端确认，重试幂等</strong>）</p><ol><li>A**(订单)** 系统先发送一个 <strong>prepared</strong> 消息到 mq，prepared 消息发送失败则取消操作不执行了</li><li>发送成功后，那么执行本地事务，执行成功和和失败发送<strong>确认和回滚</strong>消息到mq</li><li>如果发送了确认消息，那么此时 B**(仓储)** 系统会接收到确认消息，然后执行本地的事务</li><li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调的接口，确认事务执行状态</li><li>B 的事务失败后自动<strong>不断重试</strong>直到成功，达到一定次数后发送报警由人工来<strong>手工回滚</strong>和<strong>补偿</strong></li></ol><h4 id="最大努力通知方案（订单-积分）"><a href="#最大努力通知方案（订单-积分）" class="headerlink" title="最大努力通知方案（订单 -&gt; 积分）"></a>最大努力通知方案（订单 -&gt; 积分）</h4><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，接着调用系统 B 的接口；</li><li>要是系统 B 执行失败了，就定时尝试重新调用系统 B，<strong>反复 N 次</strong>，最后还是不行就<strong>放弃</strong></li></ol><p>你找一个严格<strong>资金</strong>要求绝对不能错的场景，你可以说你是用的 <strong>TCC 方案</strong>；</p><p>如果是一般的分布式事务场景，例如<strong>积分</strong>数据，可以用可靠消息<strong>最终一致性方案</strong></p><p>如果分布式场景<strong>允许不一致</strong>，可以使用最大努力通知方案</p><h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><h4 id="分布式Session实现方案"><a href="#分布式Session实现方案" class="headerlink" title="分布式Session实现方案"></a>分布式Session实现方案</h4><ul><li>基于JWT的Token，数据从cache或者数据库中获取</li><li>基于Tomcat的Redis，简单配置conf文件</li><li>基于Spring的Redis，支持SpringCloud和Springb</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="面试题" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="Java基础" scheme="https://blog.elfred.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://blog.elfred.top/posts/9a0369ec.html"/>
    <id>https://blog.elfred.top/posts/9a0369ec.html</id>
    <published>2022-05-16T14:50:00.000Z</published>
    <updated>2025-03-08T14:46:55.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>海量数据处理以及缓存穿透这两个场景让我认识了 布隆过滤器 ，我查阅了一些资料来了解它，但是很多现成资料并不满足我的需求，所以就决定自己总结一篇关于布隆过滤器的文章。希望通过这篇文章让更多人了解布隆过滤器，并且会实际去使用它！</p><p>下面我们将分为几个方面来介绍布隆过滤器：</p><ol><li>什么是布隆过滤器？</li><li>布隆过滤器的原理介绍。</li><li>布隆过滤器使用场景。</li><li>通过 Java 编程手动实现布隆过滤器。</li><li>利用 Google 开源的 Guava 中自带的布隆过滤器。</li><li>Redis 中的布隆过滤器。</li></ol><span id="more"></span><h2 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h2><p>首先，我们需要了解布隆过滤器的概念。</p><p>布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202205162212315.png" alt="布隆过滤器示意图"></p><p>位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit &#x2F; 8 &#x3D; 125000 Byte &#x3D; 125000&#x2F;1024 kb ≈ 122kb 的空间。</p><p>总结：<strong>一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</strong></p><h2 id="布隆过滤器的原理介绍"><a href="#布隆过滤器的原理介绍" class="headerlink" title="布隆过滤器的原理介绍"></a>布隆过滤器的原理介绍</h2><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>举个简单的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202205162212356.png" alt="布隆过滤器hash计算"></p><p>如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。</p><p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p><p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p><p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><h2 id="布隆过滤器使用场景"><a href="#布隆过滤器使用场景" class="headerlink" title="布隆过滤器使用场景"></a>布隆过滤器使用场景</h2><ol><li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li><li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li></ol><h2 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h2><h3 id="通过-Java-编程手动实现布隆过滤器"><a href="#通过-Java-编程手动实现布隆过滤器" class="headerlink" title="通过 Java 编程手动实现布隆过滤器"></a>通过 Java 编程手动实现布隆过滤器</h3><p>我们上面已经说了布隆过滤器的原理，知道了布隆过滤器的原理之后就可以自己手动实现一个了。</p><p>如果你想要手动实现一个的话，你需要：</p><ol><li>一个合适大小的位数组保存数据</li><li>几个不同的哈希函数</li><li>添加元素到位数组（布隆过滤器）的方法实现</li><li>判断给定元素是否存在于位数组（布隆过滤器）的方法实现。</li></ol><p>下面给出一个我觉得写的还算不错的代码（参考网上已有代码改进得到，对于所有类型对象皆适用）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBloomFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_SIZE</span> <span class="operator">=</span> <span class="number">2</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过这个数组可以创建 6 个不同的哈希函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] SEEDS = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">13</span>, <span class="number">46</span>, <span class="number">71</span>, <span class="number">91</span>, <span class="number">134</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组。数组中的元素只能是 0 或者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">BitSet</span> <span class="variable">bits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(DEFAULT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放包含 hash 函数的类的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SimpleHash[] func = <span class="keyword">new</span> <span class="title class_">SimpleHash</span>[SEEDS.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化多个不同的 Hash 函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SEEDS.length; i++) &#123;</span><br><span class="line">            func[i] = <span class="keyword">new</span> <span class="title class_">SimpleHash</span>(DEFAULT_SIZE, SEEDS[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            bits.set(f.hash(value), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断指定元素是否存在于位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            ret = ret &amp;&amp; bits.get(f.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类。用于 hash 操作！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleHash</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> seed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SimpleHash</span><span class="params">(<span class="type">int</span> cap, <span class="type">int</span> seed)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cap = cap;</span><br><span class="line">            <span class="built_in">this</span>.seed = seed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算 hash 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            <span class="type">int</span> h;</span><br><span class="line">            <span class="keyword">return</span> (value == <span class="literal">null</span>) ? <span class="number">0</span> : Math.abs(seed * (cap - <span class="number">1</span>) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="string">&quot;https://javaguide.cn/&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="string">&quot;https://github.com/Snailclimb&quot;</span>;</span><br><span class="line"><span class="type">MyBloomFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBloomFilter</span>();</span><br><span class="line">System.out.println(filter.contains(value1));</span><br><span class="line">System.out.println(filter.contains(value2));</span><br><span class="line">filter.add(value1);</span><br><span class="line">filter.add(value2);</span><br><span class="line">System.out.println(filter.contains(value1));</span><br><span class="line">System.out.println(filter.contains(value2));</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="number">13423</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="number">22131</span>;</span><br><span class="line"><span class="type">MyBloomFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBloomFilter</span>();</span><br><span class="line">System.out.println(filter.contains(value1));</span><br><span class="line">System.out.println(filter.contains(value2));</span><br><span class="line">filter.add(value1);</span><br><span class="line">filter.add(value2);</span><br><span class="line">System.out.println(filter.contains(value1));</span><br><span class="line">System.out.println(filter.contains(value2));</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="利用-Google-开源的-Guava-中自带的布隆过滤器"><a href="#利用-Google-开源的-Guava-中自带的布隆过滤器" class="headerlink" title="利用 Google 开源的 Guava 中自带的布隆过滤器"></a>利用 Google 开源的 Guava 中自带的布隆过滤器</h3><p>自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。</p><p>首先我们需要在项目中引入 Guava 的依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">28.0</span>-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>实际使用如下：</p><p>我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">    Funnels.integerFunnel(),</span><br><span class="line">    <span class="number">1500</span>,</span><br><span class="line">    <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 判断指定元素是否存在</span></span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">filter.put(<span class="number">1</span>);</span><br><span class="line">filter.put(<span class="number">2</span>);</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>在我们的示例中，当 <code>mightContain()</code> 方法返回 <em>true</em> 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 <em>false</em> 时，我们可以 100％确定该元素不存在于过滤器中。</p><p><strong>Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。</strong></p><h2 id="Redis-中的布隆过滤器"><a href="#Redis-中的布隆过滤器" class="headerlink" title="Redis 中的布隆过滤器"></a>Redis 中的布隆过滤器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis v4.0 之后有了 Module（模块&#x2F;插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。详情可以查看 Redis 官方对 Redis Modules 的介绍 ：<a href="https://redis.io/modules">https://redis.io/modules</a></p><p>另外，官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：<a href="https://github.com/RedisBloom/RedisBloom">https://github.com/RedisBloom/RedisBloom</a><br>其他还有：</p><ul><li>redis-lua-scaling-bloom-filter（lua 脚本实现）：<a href="https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter">https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter</a></li><li>pyreBloom（Python 中的快速 Redis 布隆过滤器） ：<a href="https://github.com/seomoz/pyreBloom">https://github.com/seomoz/pyreBloom</a></li><li>……</li></ul><p>RedisBloom 提供了多种语言的客户端支持，包括：Python、Java、JavaScript 和 PHP。</p><h3 id="使用-Docker-安装"><a href="#使用-Docker-安装" class="headerlink" title="使用 Docker 安装"></a>使用 Docker 安装</h3><p>如果我们需要体验 Redis 中的布隆过滤器非常简单，通过 Docker 就可以了！我们直接在 Google 搜索 <strong>docker redis bloomfilter</strong> 然后在排除广告的第一条搜素结果就找到了我们想要的答案（这是我平常解决问题的一种方式，分享一下），具体地址：<a href="https://hub.docker.com/r/redislabs/rebloom/">https://hub.docker.com/r/redislabs/rebloom/</a> （介绍的很详细 ）。</p><p><strong>具体操作如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span><br><span class="line">➜  ~ docker exec -it redis-redisbloom bash</span><br><span class="line">root@21396d02c252:/data# redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="常用命令一览"><a href="#常用命令一览" class="headerlink" title="常用命令一览"></a>常用命令一览</h3><blockquote><p>注意： key : 布隆过滤器的名称，item : 添加的元素。</p></blockquote><ol><li>**<code>BF.ADD</code>**：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：<code>BF.ADD &#123;key&#125; &#123;item&#125;</code>。</li><li><strong><code>BF.MADD</code></strong> : 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式<code>BF.ADD</code>与之相同，只不过它允许多个输入并返回多个值。格式：<code>BF.MADD &#123;key&#125; &#123;item&#125; [item ...]</code> 。</li><li><strong><code>BF.EXISTS</code></strong> : 确定元素是否在布隆过滤器中存在。格式：<code>BF.EXISTS &#123;key&#125; &#123;item&#125;</code>。</li><li><strong><code>BF.MEXISTS</code></strong> ： 确定一个或者多个元素是否在布隆过滤器中存在格式：<code>BF.MEXISTS &#123;key&#125; &#123;item&#125; [item ...]</code>。</li></ol><p>另外， <code>BF. RESERVE</code> 命令需要单独介绍一下：</p><p>这个命令的格式如下：</p><p><code>BF. RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; [EXPANSION expansion]</code> 。</p><p>下面简单介绍一下每个参数的具体含义：</p><ol><li>key：布隆过滤器的名称</li><li>error_rate : 期望的误报率。该值必须介于 0 到 1 之间。例如，对于期望的误报率 0.1％（1000 中为 1），error_rate 应该设置为 0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的 CPU 使用率越高。</li><li>capacity: 过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。</li></ol><p>可选参数：</p><ul><li>expansion：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以<code>expansion</code>。默认扩展值为 2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。</li></ul><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter javaguide</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter javaguide</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter github</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h1&gt;&lt;p&gt;海量数据处理以及缓存穿透这两个场景让我认识了 布隆过滤器 ，我查阅了一些资料来了解它，但是很多现成资料并不满足我的需求，所以就决定自己总结一篇关于布隆过滤器的文章。希望通过这篇文章让更多人了解布隆过滤器，并且会实际去使用它！&lt;/p&gt;
&lt;p&gt;下面我们将分为几个方面来介绍布隆过滤器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是布隆过滤器？&lt;/li&gt;
&lt;li&gt;布隆过滤器的原理介绍。&lt;/li&gt;
&lt;li&gt;布隆过滤器使用场景。&lt;/li&gt;
&lt;li&gt;通过 Java 编程手动实现布隆过滤器。&lt;/li&gt;
&lt;li&gt;利用 Google 开源的 Guava 中自带的布隆过滤器。&lt;/li&gt;
&lt;li&gt;Redis 中的布隆过滤器。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>2022面经</title>
    <link href="https://blog.elfred.top/posts/708d4d58.html"/>
    <id>https://blog.elfred.top/posts/708d4d58.html</id>
    <published>2022-05-12T12:02:00.000Z</published>
    <updated>2025-03-08T14:46:55.121Z</updated>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="高仙一面"><a href="#高仙一面" class="headerlink" title="高仙一面"></a>高仙一面</h2><ul><li><p>对象一定是在堆上分配的吗？</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202205122013107.png" alt="在这里插入图片描述"></p></blockquote></li><li><p>G1和CMS垃圾回收器的区别？</p></li><li><p>线程有几种状态</p></li><li><p>加了synchronized的代码块一定会加锁吗？</p></li><li><p>Thread.sleep(0)有什么用？</p></li><li><p>分布式锁怎么实现？</p></li><li><p>不停机如何迁移数据？</p></li><li><p>如何保证数据库和缓存的一致性？</p></li></ul><h2 id="一知智能"><a href="#一知智能" class="headerlink" title="一知智能"></a>一知智能</h2><ul><li><p>MySQL的锁：排它锁、共享锁，适用场景</p><blockquote><p>排它锁、共享锁，什么时候</p></blockquote></li><li><p>MySQL行锁和表锁，update是行锁还是表锁</p></li><li><p>MySQL主从架构容灾机制，机器挂掉了是怎么处理，主从延迟了怎么处理</p></li><li><p>线上问题排查</p><blockquote><p>CPU、内存过高，死循环，内存泄漏等等</p></blockquote></li><li><p>Java锁的种类：悲观锁和乐观锁，以及使用场景</p></li><li><p>synchronized的原理</p></li><li><p>可重入锁的原理</p></li></ul><h2 id="探迹科技"><a href="#探迹科技" class="headerlink" title="探迹科技"></a>探迹科技</h2><ul><li><p>创建线程池的方式</p></li><li><p>Jdk9、11新特性</p><blockquote><p>JDK9默认G1垃圾回收器；新引入ZGC</p></blockquote></li><li><p>Java内存模型</p></li><li><p>MQ如何设计能保证消息不丢失</p><blockquote><p>从发送端（buffer）、服务端（acks机制、ISR机制）、消费端（关闭自动提交）</p></blockquote></li><li><p>集群选举算法</p><blockquote><p>RAFT协议、PAXOS协议、Zookeeper的FastLeaderElection算法</p></blockquote></li><li><p>Redis选主用的什么算法？</p><blockquote><p>Raft算法</p></blockquote></li><li><p>订单表如何分库分表</p></li><li><p>限流算法有哪些</p><blockquote><p>固定滑动窗口、动态滑动窗口、漏桶限流、令牌桶限流</p></blockquote></li></ul><h2 id="探迹二面"><a href="#探迹二面" class="headerlink" title="探迹二面"></a>探迹二面</h2><ul><li>DDD和传统开发的区别</li><li>场景题：用户下单，下单成功会扣除余额和红包，如果失败了，如何保证数据一致性</li><li>对称加密和非对称加密的区别</li></ul><h2 id="茄子科技"><a href="#茄子科技" class="headerlink" title="茄子科技"></a>茄子科技</h2><ul><li><p>服务可用性</p></li><li><p>redis使用什么集群，多少台机器；集群模式原理（CRC16）</p></li><li><p>500台机器有什么问题</p><blockquote><p>实例之间通讯会有很大的开销，因为集群中每个节点都保存所有哈希槽与节点对应关系（Slot 映射到节点的表），以及自身的状态信息。</p><p>gossip协议广播方式，节点越多，广播风暴对于网络以及服务器压力也就越大。</p><p>虽然可以设置广播消息同步的超时时间，但是节点增多、超时时间变长之后，数据一致性的消息同步延时也会更大，出现元数据不一致的可能性也会增加。</p><p>redis 官方给的 Redis Cluster 的规模上限是 1000 个实例。</p><p>批量操作（例如mget等）成本变大</p></blockquote></li><li><p>redis集群批量操作（如mget）会有什么问题？</p><blockquote><p>遍历slot-node关系，依次执行，比较浪费性能<br><a href="https://segmentfault.com/a/1190000040550883">浅谈Redis集群下mget的性能问题 - SegmentFault 思否</a></p></blockquote></li><li><p>redis client和集群通讯过程</p><blockquote><p>crc16(key)  -&gt; crc64</p></blockquote></li><li><p>redis使用的哈希算法</p><blockquote><p>hash slot</p></blockquote></li><li><p>redis内存满了写入时会怎么样，默认淘汰策略是啥</p></li><li><p>redis宕机对服务有什么影响，如何解决</p><blockquote><p>本地缓存+限流(hystrix)，防止数据库被打爆</p></blockquote></li><li><p>本地缓存和redis的一致性如何保证</p><blockquote><p>etcd广播</p></blockquote></li><li><p>redis如何通讯的，cluster模式</p></li><li><p>zookeeper和etcd的区别</p></li><li><p>如何保证服务可用度99.99%</p></li><li><p>mysql mvcc原理</p></li><li><p>为什么高并发时候推荐使用小事务</p><blockquote><p>undolog占用；死锁</p></blockquote></li><li><p>spring事务失效</p><blockquote><p>aop失效、异步线程事务失效</p></blockquote></li></ul><h2 id="仁弥科技"><a href="#仁弥科技" class="headerlink" title="仁弥科技"></a>仁弥科技</h2><ul><li><p>分库分表问题，什么时候分库分表，怎么分</p></li><li><p>微服务数据一致性</p><blockquote><p>强一致性；最终一致性</p></blockquote></li><li><p>redis集群模式，缓存较多的话？cluster单个节点可以做主从吗</p></li><li><p>MySQL ACID是如何保证的</p></li><li><p>MySQL的锁</p><blockquote><p>共享锁、独占锁；表锁、行锁；间隙锁</p></blockquote></li><li><p>Dubbo SPI机制</p></li></ul><h2 id="心灵壹点零"><a href="#心灵壹点零" class="headerlink" title="心灵壹点零"></a>心灵壹点零</h2><ul><li><p>DDD的使用场景</p></li><li><p>DDD如何划分业务领域的</p></li><li><p>设计模式几大原则</p></li><li><p>访问者模式</p></li><li><p>JVM调优</p></li><li><p>大数据吞吐适合什么垃圾回收器？</p></li><li><p>JVM 1S能产生多少对象</p><blockquote><p>单核，1S能产生亿万级，垃圾回收器1s能回收80%</p></blockquote></li></ul><h2 id="天翼云"><a href="#天翼云" class="headerlink" title="天翼云"></a>天翼云</h2><ul><li><p>生成分布式id的几种方式</p></li><li><p>分布式场景如何保证数据安全（分布式锁，分布式锁如何防止过期、如何续期、如果续期失败怎么办）</p></li><li><p>Java本地锁，如何实现一个生产者和消费者模式，如果生产速度和消费者速度不对等怎么办</p></li><li><p>频繁创建大对象的场景如何优化</p><blockquote><p>内存复用，怎么才能直接管理内存，不让直接内存管理</p></blockquote></li><li><p>信号量是干嘛的，适用场景</p></li><li><p>CountDownLatch设置为1和悲观锁有啥区别</p></li><li><p>网络字节序列，大端，小端</p></li><li><p>TCP和IP是哪一层的</p></li><li><p>IP协议是干嘛的</p></li><li><p>生成n个1-n的随机数，如何生成效率最高</p></li></ul><h2 id="米哈游"><a href="#米哈游" class="headerlink" title="米哈游"></a>米哈游</h2><ul><li><p>Dubbo默认通信协议，还支持哪些通信协议</p></li><li><p>Dubbo默认序列化协议</p></li><li><p>Dubbo广播调用</p></li><li><p>注册中心有哪些，zk，eurka、nacos都有啥区别</p></li><li><p>分布式锁zk和redis的区别</p></li><li><p>zk分布式锁的原理</p></li><li><p>redis集群通信协议，节点之间如何通信</p></li><li><p>select、poll、epoll区别，为什么要有epoll</p></li><li><p>redlock算法</p></li><li><p>redis数据结构</p></li><li><p>mysql默认事务隔离级别</p></li><li><p>mysql间隙锁解决了什么问题</p></li><li><p>ICP是干嘛的</p></li><li><p>InnoDB聚簇索引和非聚簇索引区别</p></li><li><p>索引优化</p></li><li><p>mysql高可用部署方案</p></li><li><p>kafka架构</p></li><li><p>多消费者消费原理</p></li><li><p>partion默认几个</p><blockquote><p>kafka自动创建topic时设置默认的分区和副本数：</p><p>在<code>server.properties</code>中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动创建主题</span></span><br><span class="line"><span class="attr">auto.create.topics.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 默认主题的分区数</span></span><br><span class="line"><span class="attr">num.partitions</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 默认分区副本</span></span><br><span class="line"><span class="attr">default.replication.factor</span>=<span class="string">3</span></span><br></pre></td></tr></table></figure><p>注意：<br><code>default.replication.factor</code>：默认分区副本数不得超过kafka节点数（你想，副本数如果一个节点放2份，意义就没了）</p><p>每个节点都需要配置，然后重启即可。</p></blockquote></li><li><p>system gc和runtime gc区别</p></li><li><p>system gc时机（safepoint和安全区域）</p></li><li><p>cms作为老年代垃圾回收器，为什么会扫描新生代</p></li><li><p>新生代垃圾回收期有啥，有只扫描老年代的垃圾回收器吗</p></li></ul><h2 id="蔚来NIO"><a href="#蔚来NIO" class="headerlink" title="蔚来NIO"></a>蔚来NIO</h2><ul><li><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p></li><li><p>G1垃圾回收器的原理，如何回收垃圾，如何分region</p></li><li><p>synchronized锁的原理</p><blockquote><p>底层是使用monitor_enter以及monitor_exit字节码</p></blockquote></li><li><p>hashmap为什么要用红黑树</p></li><li><p>ConcurrentHashMap是如何扩容的，如果两个线程同时put，正好遇到扩容临界点，会同时触发吗？</p></li><li><p>CompletableFuture异步原理，future.get自旋的话会不会太消耗性能</p><blockquote></blockquote></li><li><p>ThreaLocal是干嘛的，为什么用完一定要remove掉，不remove会有什么问题</p><blockquote><p>内存泄漏，线程池数据污染</p></blockquote></li><li><p>redis hash结构，如何扩容的（异步还是同步），如果数据量较大，是怎么保证主线程不堵塞的</p><blockquote><p>同步扩容，渐进式迁移</p></blockquote></li><li><p>zset跳表的原理</p></li><li><p>redis LRU淘汰策略是如何实现的</p></li><li><p>redis过期key是如何删除的（惰性删除和定时删除），定时删除如何实现的</p><blockquote><p>定时删除策略：Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。</p><ol><li>从过期字典中随机 20 个 key；</li><li>删除这 20 个 key 中已经过期的 key；</li><li>如果过期的 key 比率超过 1&#x2F;4，那就重复步骤 1；</li></ol><p>同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时<br>间的上限，默认不会超过 25ms。</p></blockquote></li><li><p>redis cluster：一个key是如何找到在哪台机器上的；批量操作的原理</p></li><li><p>redis CAP中AP是通过什么协议保证的</p></li><li><p>kafka CP是通过什么协议保证的</p></li><li><p>延迟消息的原理</p></li><li><p>数据库为什么推荐用自增id</p></li><li><p>innoDB行锁是怎么加锁的</p></li><li><p>秒杀系统设计</p></li><li><p>限流算法</p></li><li><p>sentinel限流策略</p></li><li><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p></li><li><p>nacos原理</p></li><li><p>http2.0新特性<a href="https://juejin.cn/post/6844903984524705800">https://juejin.cn/post/6844903984524705800</a></p><blockquote><p>http1.0和http1.1的主要区别如下：</p><ol><li>缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）</li><li>网络连接的优化：1.1支持断点续传</li><li>错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态</li><li>Host头处理：支持Host头域，不在以IP为请求方标志</li><li>长连接：减少了建立和关闭连接的消耗和延迟。</li></ol><p>http1.1和http2.0的主要区别：</p><ol><li>新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式</li><li>多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合<br>成正常的请求）</li><li>header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输<br>的hearder大小</li><li>服务端推送：同google的SPDUY（1.0的一种升级）一样</li></ol></blockquote></li><li><p>浏览器输入一个URL，具体发生了什么？</p><blockquote><p><strong>过程：</strong>DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束</p><table><thead><tr><th>过程</th><th>使用的协议</th></tr></thead><tbody><tr><td>1、浏览器查找域名DNS的IP地址<br />DNS查找过程（浏览器缓存、路由器缓存、DNS缓存）</td><td>DNS：获取域名对应的ip</td></tr><tr><td>2、根据ip建立TCP连接</td><td>TCP：与服务器建立连接</td></tr><tr><td>3、浏览器向服务器发送HTTP请求</td><td>HTTP：发送请求</td></tr><tr><td>4、服务器响应HTTP响应</td><td>HTTP</td></tr><tr><td>5、浏览器进行渲染</td><td></td></tr></tbody></table></blockquote></li><li><p>HTTPS原理</p><blockquote><p>1.首先客户端先给服务器发送一个请求<br>2.服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥<br>3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密<br>4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端<br>5.随后客户端和服务端就使用对称密钥进行信息传输</p></blockquote></li><li><p>非对称加密和对称加密的原理</p><blockquote><p><strong>对称加密算法：</strong><br>双方持有相同的密钥，且加密速度快，典型对称加密算法：DES、AES</p><p><strong>非对称加密算法：</strong><br>密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密<br>速度较慢，典型的非对称加密算法有：RSA、DSA</p></blockquote></li></ul><h2 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h2><ul><li><p>金额类的数据如何迁移</p></li><li><p>dubbo服务提供者的线程模型，I&#x2F;O线程是基于线程池的吗</p></li><li><p>dubbo注册中心不可用，如果本地请求到了不可用的机器，这时候如何保证可用性</p></li><li><p>dubbo服务注册和bean初始化的先后顺序？会不会出现bean没有加载完，服务已经暴露出去的情况</p></li><li><p>kafka同一个topic的数据是放在不同broker上的吗，是怎么选取partition的</p></li><li><p>kafka发送一条消息，如何通知消费者去消费的（消费者如何知道是否可以消费的）</p></li><li><p>kafka的offset是如何维护的（offset的topic），不同的topic是放在同一个offset topic的吗</p><blockquote><p>只有一个_consumer_offset主题，key是Consumer Group, topic, partition，Payload存了Offset, metadata, timestamp</p><p><a href="https://juejin.cn/post/6844904016212656141">https://juejin.cn/post/6844904016212656141</a></p></blockquote></li><li><p>kafka一个topic，5个partion，3个消费者，消费者如何分配</p></li><li><p>下面代码会发生资源竞争吗（试了：不会）</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">SyncTest</span> <span class="variable">syncTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncTest</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                syncTest.a();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                b();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>事务失效场景，下面代码应该是不生效的，<a href="https://blog.csdn.net/dl962454/article/details/118275335">https://blog.csdn.net/dl962454/article/details/118275335</a></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionService</span> &#123;</span><br><span class="line"><span class="comment">//注入dao层对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserDao iUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> num=iUserDao.updatePWDByUserName(<span class="string">&quot;hu&quot;</span>, <span class="string">&quot;3333&quot;</span>);</span><br><span class="line">        testB(<span class="string">&quot;ding&quot;</span>,<span class="string">&quot;3333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">testB</span><span class="params">(String username, String newPassword)</span>  &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> num=iUserDao.updatePWDByUserName(username, newPassword);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个类中的不同方法调用中，A方法调用B方法，A中无事务，B中有事务，此时事务不会生效。Spring采用动态代理（AOP）实现对bean的管理和切片，它为每个class都会生成一个代理对象。只有在代理对象之间调用时，可以触发切面逻辑。而同一个class中，方法A调用方法B，且方法A无事务，调用的是原对象的方法，而不是通过代理对象，因此Spring无法切换到这次调用，也就无法通过注解保证事务性了。</p></blockquote></li><li><p>gc.log里面都有啥内容</p></li><li><p>ygc会STW吗</p><blockquote><p>根据收集器来的吧，目前年轻代所有收集器都会发生stw，从最开始的serial收集器，到现在的cms收集器，虽然现在虚拟机厂商对收集器做了优化，但是stw还是无法完全避免，对目前来说cms的停顿时间是可以接受的，如果程序stw时间过程，还是需要从其他方面考虑，例如程序是否存在内存泄漏等；</p></blockquote></li><li><p>项目可以优化的地方</p></li></ul><h2 id="古茗"><a href="#古茗" class="headerlink" title="古茗"></a>古茗</h2><ul><li>caffine和guava区别</li><li>事务消息的原理</li><li>etcd和MQ广播有什么区别</li></ul><h2 id="花旗金融"><a href="#花旗金融" class="headerlink" title="花旗金融"></a>花旗金融</h2><ul><li><p>求x的n次方，不使用数学公式</p></li><li><p>取模操作性能最好的</p><blockquote><p>x &amp; (n-1) </p></blockquote></li><li><p>泛型基类，如何自动寻找实现类</p></li></ul><h2 id="智己汽车"><a href="#智己汽车" class="headerlink" title="智己汽车"></a>智己汽车</h2><ul><li><a href="https://leetcode-cn.com/problems/minimum-path-sum">64. 最小路径和</a></li><li>堆外内存泄漏如何排查</li><li>K8s排查oom kill</li><li>k8s pod无限重启如何排查</li><li>tcp time_wait 连接过多排查</li><li>redis bitmap使用场景、优势、原理</li></ul><h2 id="众安一面"><a href="#众安一面" class="headerlink" title="众安一面"></a>众安一面</h2><ul><li><p>本地缓存和redis一致性</p></li><li><p>docker虚拟机，springboot应用内存缓慢升高，流量正常，可能是什么原因导致的</p><blockquote><p>jvm内存溢出或者堆外内存溢出</p></blockquote></li><li><p>附近的人技术实现</p></li><li><p>kafka错误配置导致内存泄漏</p></li><li><p>给一亿用户发送优惠券，保证速度最快，如何读取如此大的用户量</p></li></ul><h2 id="阿维塔"><a href="#阿维塔" class="headerlink" title="阿维塔"></a>阿维塔</h2><ul><li><p>一个请求从前端到数据库的完整链路</p></li><li><p>dubbo的优缺点</p></li><li><p>如何设计一个注册中心</p></li><li><p>ThreadLocal原理</p></li><li><p>java如何停止一个线程</p><blockquote><p>interrupt</p></blockquote></li><li><p>线程在阻塞状态下如何停止</p><blockquote><p>线程外面interrupt + 线程内部判断Thread.isInterrupted()来处理</p></blockquote></li><li><p>ReentrantLock如何做到可重入的</p></li><li><p>List、Set等集合底层实现</p></li><li><p>二叉树的作用</p></li><li><p>SpringBoot默认作用域（单例），什么时候会用到多例</p></li><li><p>Spring filter和intercepter区别，以及常见应用</p><blockquote></blockquote></li><li><p>用数组实现一个栈，出栈后这个元素会被gc回收掉吗？为什么</p></li><li><p>mysql字段什么时候用char，什么时候用varchar，字符串字段如何加索引</p><blockquote></blockquote></li><li><p>redis zset</p></li><li><p>moogodb应用场景</p></li><li><p>开发中常用的设计模式，责任链一般是干嘛的</p></li><li><p>单元测试@before和@beforeClass区别</p></li><li><p>JVM如何设置参数尽可能创建更多的线程</p></li><li><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p></li><li><p>redis跳表原理，查找和修改是如何操作的，为什么用跳表，不用二叉树</p></li><li><p>生产redis越来越慢，如何排查</p></li><li><p>redis bigkey如何治理，中间件层面</p></li><li><p>redis cluster寻址过程</p></li><li><p>redis cluster为什么是65535个槽位</p></li><li><p>redis cluster如果hash冲突了怎么办</p></li><li><p>redis innodb引擎是如何解决幻读的</p><blockquote><p>快照读，mvcc undolog</p></blockquote></li><li><p>mysql行记录上有哪些隐藏字段</p><blockquote><ul><li>trx_id：每次事务对某条聚簇索引记录进行改动时候，都会把该事务的事务id赋值给trx_id列</li><li>roll_pointer：每次修改完，都会把旧版本写到undo_log里，这个隐藏列相当于一个指正，可以通过它来找到记录修改前的信息。</li></ul></blockquote></li><li><p>当前读如何实现（加锁），临键锁和间隙锁有什么区别</p></li><li><p>binlog好redolog都是干啥的</p></li><li><p>sync和lock有什么区别，哪个性能好</p></li><li><p>锁升级的过程</p></li><li><p>聊一下比较好的代码或者设计</p></li><li><p>遇到的线上问题</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>29讲</title>
    <link href="https://blog.elfred.top/posts/22fa690f.html"/>
    <id>https://blog.elfred.top/posts/22fa690f.html</id>
    <published>2021-08-23T01:30:00.000Z</published>
    <updated>2025-03-08T14:46:55.131Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="29-堆的应用：如何快速获取到Top-10最热门的搜索关键词？"><a href="#29-堆的应用：如何快速获取到Top-10最热门的搜索关键词？" class="headerlink" title="29 | 堆的应用：如何快速获取到Top 10最热门的搜索关键词？"></a>29 | 堆的应用：如何快速获取到Top 10最热门的搜索关键词？</h1><h2 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h2><h3 id="1-合并有序小文件"><a href="#1-合并有序小文件" class="headerlink" title="1. 合并有序小文件"></a>1. 合并有序小文件</h3><p>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p><p>整体思路有点像归并排序中的合并函数。我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p><p>假设，这个最小的字符串来自于 13.txt 这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</p><p>这里我们用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。有没有更加高效方法呢？</p><p>这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</p><p>我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是 O(logn)，n 表示堆中的数据个数，这里就是 100。是不是比原来数组存储的方式高效了很多呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;29-堆的应用：如何快速获取到Top-10最热门的搜索关键词？&quot;&gt;&lt;a href=&quot;#29-堆的应用：如何快速获取到Top-10最热门的搜索关键词？&quot; class=&quot;headerlink&quot; title=&quot;29 | 堆的应用：如何快速获取到Top 10最热</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>28讲</title>
    <link href="https://blog.elfred.top/posts/9a460e6a.html"/>
    <id>https://blog.elfred.top/posts/9a460e6a.html</id>
    <published>2021-08-23T00:30:00.000Z</published>
    <updated>2025-03-08T14:46:55.131Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="28-堆和堆排序：为什么说堆排序没有快速排序快？"><a href="#28-堆和堆排序：为什么说堆排序没有快速排序快？" class="headerlink" title="28 | 堆和堆排序：为什么说堆排序没有快速排序快？"></a>28 | 堆和堆排序：为什么说堆排序没有快速排序快？</h1><h2 id="如何理解“堆”？"><a href="#如何理解“堆”？" class="headerlink" title="如何理解“堆”？"></a>如何理解“堆”？</h2><p>前面我们提到，堆是一种特殊的树。我们现在就来看看，什么样的树才是堆。我罗列了两点要求，只要满足这两点，它就是一个堆。</p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><p>我分别解释一下这两点。</p><p>第一点，堆必须是一个完全二叉树。还记得我们之前讲的完全二叉树的定义吗？完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p><p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p><p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。</p><p>定义解释清楚了，你来看看，下面这几个二叉树是不是堆？</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230804058.jpeg" alt="img"></p><p>其中第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。</p><span id="more"></span><h2 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h2><p>要实现一个堆，我们先要知道，<strong>堆都支持哪些操作以及如何存储一个堆</strong>。</p><p>我之前讲过，完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p><p>我画了一个用数组存储堆的例子，你可以先看下。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230807648.jpeg" alt="img"></p><p>从图中我们可以看到，数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 2&#x2F;i 的节点。</p><p>知道了如何存储一个堆，那我们再来看看，堆上的操作有哪些呢？我罗列了几个非常核心的操作，分别是往堆中插入一个元素和删除堆顶元素。（如果没有特殊说明，我下面都是拿大顶堆来讲解）。</p><h3 id="1-往堆中插入一个元素"><a href="#1-往堆中插入一个元素" class="headerlink" title="1. 往堆中插入一个元素"></a>1. 往堆中插入一个元素</h3><p>往堆中插入一个元素后，我们需要继续满足堆的两个特性。</p><p>如果我们把新插入的元素放到堆的最后，你可以看我画的这个图，是不是不符合堆的特性了？于是，我们就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫做<strong>堆化</strong>（heapify）。</p><p>堆化实际上有两种，从下往上和从上往下。这里我先讲<strong>从下往上</strong>的堆化方法。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230812668.jpeg" alt="img"></p><p>堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。</p><p>我这里画了一张堆化的过程分解图。我们可以让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230812976.jpeg" alt="img"></p><p>我将上面讲的往堆中插入数据的过程，翻译成了代码，你可以结合着一块看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span>[] a; <span class="comment">// 数组，从下标1开始存储数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;  <span class="comment">// 堆可以存储的最大数据个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count; <span class="comment">// 堆中已经存储的数据个数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="title class_">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    n = capacity;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= n) <span class="keyword">return</span>; <span class="comment">// 堆满了</span></span><br><span class="line">    ++count;</span><br><span class="line">    a[count] = data;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count;</span><br><span class="line">    <span class="keyword">while</span> (i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">      swap(a, i, i/<span class="number">2</span>); <span class="comment">// swap()函数作用：交换下标为i和i/2的两个元素</span></span><br><span class="line">      i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-删除堆顶元素"><a href="#2-删除堆顶元素" class="headerlink" title="2. 删除堆顶元素"></a>2. 删除堆顶元素</h3><p>从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，我们可以发现，堆顶元素存储的就是堆中数据的最大值或者最小值。</p><p>假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p><p>这里我也画了一个分解图。不过这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230813648.jpeg" alt="img"></p><p>实际上，我们稍微改变一下思路，就可以解决这个问题。你看我画的下面这幅图。我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是<strong>从上往下的堆化方法</strong>。</p><p>因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230815478.jpeg" alt="img"></p><p>我把上面的删除过程同样也翻译成了代码，贴在这里，你可以结合着看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeMax</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 堆中没有数据</span></span><br><span class="line">  a[<span class="number">1</span>] = a[count];</span><br><span class="line">  --count;</span><br><span class="line">  heapify(a, count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxPos</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，一个包含 n 个节点的完全二叉树，树的高度不会超过 log2n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。</p><h2 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h2><p>前面我们讲过好几种排序算法，我们再来回忆一下，有时间复杂度是 O(n^2) 的冒泡排序、插入排序、选择排序，有时间复杂度是 O(nlogn) 的归并排序、快速排序，还有线性排序。</p><p>这里我们借助于堆这种数据结构实现的排序算法，就叫做堆排序。这种排序方法的时间复杂度非常稳定，是 O(nlogn)，并且它还是原地排序算法。如此优秀，它是怎么做到的呢？</p><p>我们可以把堆排序的过程大致分解成两个大的步骤，<strong>建堆</strong>和<strong>排序</strong>。</p><h3 id="1-建堆"><a href="#1-建堆" class="headerlink" title="1. 建堆"></a>1. 建堆</h3><p>我们首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。建堆的过程，有两种思路。</p><p>第一种是借助我们前面讲的，在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。</p><p>第二种实现思路，跟第一种截然相反，也是我这里要详细讲的。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</p><p>我举了一个例子，并且画了一个第二种实现思路的建堆分解步骤图，你可以看下。因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从最后一个非叶子节点开始，依次堆化就行了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230825569.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230825529.jpeg" alt="img"></p><p>对于程序员来说，看代码可能更好理解一些，所以，我将第二种实现思路翻译成了代码，你可以看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxPos</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能已经发现了，在这段代码中，我们对下标从 2n 开始到 1 的数据进行堆化，下标是 2&#x2F;n+1 到 n 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 2&#x2F;n+1 到 n 的节点都是叶子节点。</p><p>现在，我们来看，建堆操作的时间复杂度是多少呢？</p><p>每个节点堆化的时间复杂度是 O(logn)，那 2n+1 个节点堆化的总时间复杂度是不是就是 O(nlogn) 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是 O(n)。我带你推导一下。</p><p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。</p><p>我把每一层的节点个数和对应的高度画了出来，你可以看看。我们只需要将每个节点的高度求和，得出的就是建堆的时间复杂度。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230827411.jpeg" alt="img"></p><p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230827199.jpeg" alt="img"></p><p>这个公式的求解稍微有点技巧，不过我们高中应该都学过：把公式左右都乘以 2，就得到另一个公式 S2。我们将 S2 错位对齐，并且用 S2 减去 S1，可以得到 S。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230827977.jpeg" alt="img"></p><p>S 的中间部分是一个等比数列，所以最后可以用等比数列的求和公式来计算，最终的结果就是下面图中画的这个样子。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230827939.jpeg" alt="img"></p><p>因为 h&#x3D;log2n，代入公式 S，就能得到 S&#x3D;O(n)，所以，建堆的时间复杂度就是 O(n)。</p><h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h3><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</p><p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230829755.jpeg" alt="img"></p><p>堆排序的过程，我也翻译成了代码。结合着代码看，你理解起来应该会更加容易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们再来分析一下堆排序的时间复杂度、空间复杂度以及稳定性。</p><p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。</p><p>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p><p>今天的内容到此就讲完了。我这里要稍微解释一下，在前面的讲解以及代码中，我都假设，堆中的数据是从数组下标为 1 的位置开始存储。那如果从 0 开始存储，实际上处理思路是没有任何变化的，唯一变化的，可能就是，代码实现的时候，计算子节点和父节点的下标的公式改变了。</p><p>如果节点的下标是 i，那左子节点的下标就是 2∗i+1，右子节点的下标就是 2∗i+2，父节点的下标就是 (i-1)&#x2F;2。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>现在我们来看开篇的问题，在实际开发中，为什么快速排序要比堆排序性能好？</p><p>我觉得主要有两方面的原因。</p><p><strong>第一点，堆排序数据访问的方式没有快速排序友好</strong>。</p><p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，这样对 CPU 缓存是不友好的。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230832920.jpeg" alt="img"></p><p><strong>第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序</strong>。</p><p>我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。</p><p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230833773.jpeg" alt="img"></p><p>对于第二点，你可以自己做个试验看下。我们用一个记录交换次数的变量，在代码中，每次交换的时候，我们就对这个变量加一，排序完成之后，这个变量的值就是总的数据交换次数。这样你就能很直观地理解我刚刚说的，堆排序比快速排序交换次数多。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们讲了堆这种数据结构。堆是一种完全二叉树。它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。</p><p>堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，我们把新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 O(logn)。</p><p>除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 2&#x2F;n 到 1 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol><li><p>在讲堆排序建堆的时候，我说到，对于完全二叉树来说，下标从 n&#x2F;2+1 到 n 的都是叶子节点，这个结论是怎么推导出来的呢？</p><blockquote><p>使用数组存储表示完全二叉树时，从数组下标为1开始存储数据，数组下标为i的节点，左子节点为2i, 右子节点为2i + 1. 这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。</p><p>为什么，对于完全二叉树来说，下标从n&#x2F;2 + 1 到 n的节点都是叶子节点？ 使用反证法证明即可：</p><p>如果下标为n&#x2F;2 + 1的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：2(n&#x2F;2 + 1) &#x3D; n + 2，大家明显可以看出，这个数字已经大于n + 1，超出了实现完全二叉树所用数组的大小（数组下标从1开始记录数据，对于n个节点来说，数组大小是n + 1），左子节点都已经超出了数组容量，更何况右子节点。以此类推，很容易得出：下标大于n&#x2F;2 + 1的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从n&#x2F;2 + 1 到 n的节点都是叶子节点。</p></blockquote></li><li><p>我们今天讲了堆的一种经典应用，堆排序。关于堆，你还能想到它的其他应用吗？</p><blockquote><p>堆的应用除了堆排以外，还有如下一些应用：</p><ol><li>从大数量级数据中筛选出top n 条数据； 比如：从几十亿条订单日志中筛选出金额靠前的1000条数据</li><li>在一些场景中，会根据不同优先级来处理网络请求，此时也可以用到优先队列(用堆实现的数据结构)；比如：网络框架Volley就用了Java中PriorityBlockingQueue，当然它是线程安全的</li><li>可以用堆来实现多路归并，从而实现有序，leetcode上也有相关的一题：Merge K Sorted Lists</li></ol></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;28-堆和堆排序：为什么说堆排序没有快速排序快？&quot;&gt;&lt;a href=&quot;#28-堆和堆排序：为什么说堆排序没有快速排序快？&quot; class=&quot;headerlink&quot; title=&quot;28 | 堆和堆排序：为什么说堆排序没有快速排序快？&quot;&gt;&lt;/a&gt;28 | 堆和堆排序：为什么说堆排序没有快速排序快？&lt;/h1&gt;&lt;h2 id=&quot;如何理解“堆”？&quot;&gt;&lt;a href=&quot;#如何理解“堆”？&quot; class=&quot;headerlink&quot; title=&quot;如何理解“堆”？&quot;&gt;&lt;/a&gt;如何理解“堆”？&lt;/h2&gt;&lt;p&gt;前面我们提到，堆是一种特殊的树。我们现在就来看看，什么样的树才是堆。我罗列了两点要求，只要满足这两点，它就是一个堆。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆是一个完全二叉树；&lt;/li&gt;
&lt;li&gt;堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我分别解释一下这两点。&lt;/p&gt;
&lt;p&gt;第一点，堆必须是一个完全二叉树。还记得我们之前讲的完全二叉树的定义吗？完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。&lt;/p&gt;
&lt;p&gt;第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。&lt;/p&gt;
&lt;p&gt;对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。&lt;/p&gt;
&lt;p&gt;定义解释清楚了，你来看看，下面这几个二叉树是不是堆？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108230804058.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>13讲</title>
    <link href="https://blog.elfred.top/posts/ae7f3bb.html"/>
    <id>https://blog.elfred.top/posts/ae7f3bb.html</id>
    <published>2021-08-09T00:33:00.000Z</published>
    <updated>2025-03-08T14:46:55.134Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="13-线性排序：如何根据年龄给100万用户数据排序？"><a href="#13-线性排序：如何根据年龄给100万用户数据排序？" class="headerlink" title="13 | 线性排序：如何根据年龄给100万用户数据排序？"></a>13 | 线性排序：如何根据年龄给100万用户数据排序？</h1><h2 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h2><p>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210809083534.jpeg" alt="img"></p><p>桶排序的时间复杂度为什么是 O(n) 呢？我们一块儿来分析一下。</p><p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k&#x3D;n&#x2F;m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k&#x3D;n&#x2F;m，所以整个桶排序的时间复杂度就是 O(n*log(n&#x2F;m))。当桶的个数 m 接近数据个数 n 时，log(n&#x2F;m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><span id="more"></span><h3 id="桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？"><a href="#桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？" class="headerlink" title="桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？"></a>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</h3><p>答案当然是否定的。为了让你轻松理解桶排序的核心思想，我刚才做了很多假设。实际上，桶排序对要排序数据的要求是非常苛刻的。</p><p>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p><p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p><p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><p>比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</p><p>现在我来讲一下，如何借助桶排序的处理思想来解决这个问题。</p><p>我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。</p><p>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p><p>不过，你可能也发现了，订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB 订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。这又该怎么办呢？</p><p>针对这些划分之后还是比较大的文件，我们可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元….901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。</p><h2 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h2><p>我个人觉得，<strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？</p><p>考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p><p>计数排序的算法思想就是这么简单，跟桶排序非常类似，只是桶的大小粒度不一样。<strong>不过，为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</strong></p><p>想弄明白这个问题，我们就要来看计数排序算法的实现方法。我还拿考生那个例子来解释。为了方便说明，我对数据规模做了简化。假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8]中，它们分别是：2，5，3，0，2，3，0，3。</p><p>考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考生，而是对应的考生个数。像我刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6]的值。</p><p>从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108090919720.jpeg" alt="img"></p><p>那我们如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢？这个处理方法非常巧妙，很不容易想到。</p><p>思路是这样的：我们对 C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数 k 的考生个数。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108090919681.jpeg" alt="img"></p><p>有了前面的数据准备之后，现在我就要讲计数排序中最复杂、最难理解的一部分了，请集中精力跟着我的思路！</p><p>我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。</p><p>以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108090920435.jpeg" alt="img"></p><p>上面的过程有点复杂，我写成了代码，你可以对照着看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组c，下标大小[0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入c中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组r，存储排序之后的结果</span></span><br><span class="line">  <span class="type">int</span>[] r = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给a数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种利用另外一个数组来计数的实现方式是不是很巧妙呢？这也是为什么这种排序算法叫计数排序的原因。不过，你千万不要死记硬背上面的排序过程，重要的是理解和会用。</p><p>我总结一下，<strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p><p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。</p><h2 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h2><p>我们再来看这样一个排序问题。假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p><p>我们之前讲的快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 O(n) 的算法呢？现在我就来介绍一种新的排序算法，基数排序。</p><p>刚刚这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。</p><p>借助稳定排序算法，这里有一个巧妙的实现思路。还记得我们第 11 节中，在阐述排序算法的稳定性的时候举的订单的例子吗？我们这里也可以借助相同的处理思路，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。</p><p>手机号码稍微有点长，画图比较不容易看清楚，我用字符串排序的例子，画了一张基数排序的过程分解图，你可以看下。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202108090929945.jpeg" alt="img"></p><p>注意，这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。</p><p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p><p>实际上，有时候要排序的数据并不都是等长的，比如我们排序牛津字典中的 20 万个英文单词，最短的只有 1 个字母，最长的我特意去查了下，有 45 个字母，中文翻译是尘肺病。对于这种不等长的数据，基数排序还适用吗？</p><p>实际上，<strong>我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”</strong>，因为根据ASCII 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p><p>我来总结一下，<strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</strong></p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>今天的内容学完了。我们再回过头来看看开篇的思考题：如何根据年龄给 100 万用户排序？现在思考题是不是变得非常简单了呢？我来说一下我的解决思路。</p><p>实际上，根据年龄给 100 万用户排序，就类似按照成绩给 50 万考生排序。我们假设年龄的范围最小 1 岁，最大不超过 120 岁。我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天，我们学习了 3 种线性时间复杂度的排序算法，有桶排序、计数排序、基数排序。它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。</p><p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们今天讲的都是针对特殊数据的排序算法。实际上，还有很多看似是排序但又不需要使用排序算法就能处理的排序问题。</p><p>假设我们现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？</p><blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;13-线性排序：如何根据年龄给100万用户数据排序？&quot;&gt;&lt;a href=&quot;#13-线性排序：如何根据年龄给100万用户数据排序？&quot; class=&quot;headerlink&quot; title=&quot;13 | 线性排序：如何根据年龄给100万用户数据排序？&quot;&gt;&lt;/a&gt;13 | 线性排序：如何根据年龄给100万用户数据排序？&lt;/h1&gt;&lt;h2 id=&quot;桶排序（Bucket-sort）&quot;&gt;&lt;a href=&quot;#桶排序（Bucket-sort）&quot; class=&quot;headerlink&quot; title=&quot;桶排序（Bucket sort）&quot;&gt;&lt;/a&gt;桶排序（Bucket sort）&lt;/h2&gt;&lt;p&gt;首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210809083534.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;桶排序的时间复杂度为什么是 O(n) 呢？我们一块儿来分析一下。&lt;/p&gt;
&lt;p&gt;如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k&amp;#x3D;n&amp;#x2F;m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k&amp;#x3D;n&amp;#x2F;m，所以整个桶排序的时间复杂度就是 O(n*log(n&amp;#x2F;m))。当桶的个数 m 接近数据个数 n 时，log(n&amp;#x2F;m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>限流算法原理及实现</title>
    <link href="https://blog.elfred.top/posts/29743003.html"/>
    <id>https://blog.elfred.top/posts/29743003.html</id>
    <published>2021-06-20T08:11:00.000Z</published>
    <updated>2025-03-08T14:46:55.124Z</updated>
    
    <content type="html"><![CDATA[<hr><p>[TOC]</p><h2 id="限流的算法有哪些？"><a href="#限流的算法有哪些？" class="headerlink" title="限流的算法有哪些？"></a>限流的算法有哪些？</h2><p>本文介绍几种最常用的限流算法：</p><ul><li>固定窗口计数器；</li><li>滑动窗口计数器；</li><li>漏桶；</li><li>令牌桶。</li></ul><h3 id="固定窗口计数器算法"><a href="#固定窗口计数器算法" class="headerlink" title="固定窗口计数器算法"></a>固定窗口计数器算法</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210620222717.png" alt="固定窗口计数器算法"></p><p>固定窗口计数器算法概念如下：</p><ul><li><p>将时间划分为多个窗口；</p></li><li><p>在每个窗口内每有一次请求就将计数器加一；</p></li><li><p>如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置。</p></li></ul><p>固定窗口计数器是最为简单的算法，但这个算法有时会让通过请求量允许为限制的两倍。考虑如下情况：限制1秒内最多通过5个请求，在第一个窗口的最后半秒内通过了5个请求，第二个窗口的前半秒内又通过了5个请求。这样看来就是在1秒内通过了10个请求。 </p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210620222813.png" alt="图片"></p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大访问数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问时间差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Long time;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">reqCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化time</span></span><br><span class="line">        <span class="keyword">if</span> (time == <span class="literal">null</span>) &#123;</span><br><span class="line">            time = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; time + timeout) &#123;</span><br><span class="line">            <span class="comment">// 单位时间内</span></span><br><span class="line">            reqCount.addAndGet(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> reqCount.get() &lt;= limit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            time = now;</span><br><span class="line">            reqCount.set(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口计数器算法"><a href="#滑动窗口计数器算法" class="headerlink" title="滑动窗口计数器算法"></a>滑动窗口计数器算法</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210620222921.png" alt="滑动窗口计数器算法"></p><p>滑动窗口计数器算法概念如下：</p><ul><li>将时间划分为多个区间；</li><li>在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间；</li><li>每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间；</li><li>如果当前窗口内区间的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。</li></ul><p>滑动窗口计数器是通过将窗口再细分，并且按照时间”滑动”，这种算法避免了固定窗口计数器带来的双倍突发请求，但时间区间的精度越高，算法所需的空间容量就越大。</p><h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><h5 id="1-TreeMap版"><a href="#1-TreeMap版" class="headerlink" title="1.TreeMap版"></a>1.TreeMap版</h5><p>因为TreeMap没有线程安全版本，所以使用synchronized保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowRateLimiter</span> <span class="keyword">implements</span> <span class="title class_">MyRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每分钟限制请求数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> permitsPerMinute;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间窗口间隔秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> seconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数器, key为当前窗口的开始时间值毫秒，value为当前窗口的计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Integer&gt; counters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingWindowRateLimiter</span><span class="params">(<span class="type">long</span> permitsPerMinute, <span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permitsPerMinute = permitsPerMinute;</span><br><span class="line">        <span class="built_in">this</span>.seconds = seconds;</span><br><span class="line">        <span class="built_in">this</span>.counters = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间的所在的子窗口值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 获取当前窗口的请求总量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentWindowCount</span> <span class="operator">=</span> getCurrentWindowCount(currentTimeMillis);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前窗口计数：&quot;</span> + currentWindowCount);</span><br><span class="line">        <span class="keyword">if</span> (currentWindowCount &gt;= permitsPerMinute) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器 + 1</span></span><br><span class="line">        saveCurrentTime(currentTimeMillis);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计时器 +1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveCurrentTime</span><span class="params">(<span class="type">long</span> currentTimeMillis)</span> &#123;</span><br><span class="line">        counters.merge(currentTimeMillis, <span class="number">1</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前窗口中的所有请求数（并删除所有无效的子窗口计数器）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentTimesMills 当前子窗口时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前窗口中的计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getCurrentWindowCount</span><span class="params">(<span class="type">long</span> currentTimesMills)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算出窗口的开始位置时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> currentTimesMills - (seconds * <span class="number">1000L</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历当前存储的计算器，删除无效的子窗口计数器，并累加当前窗口中的所有计数器之和</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Long, Integer&gt;&gt; iterator = counters.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Long, Integer&gt; entry = iterator.next();</span><br><span class="line">            <span class="type">Long</span> <span class="variable">time</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (time &lt; startTime) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 将时间分片，seconds是时间窗口大小，max代表seconds时间最大访问上限</span></span><br><span class="line">        <span class="type">MyRateLimiter</span> <span class="variable">myRateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SlidingWindowRateLimiter</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestCnt</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">successCnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; requestCnt; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> myRateLimiter.tryAcquire();</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                successCnt.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resultStr</span> <span class="operator">=</span> result ? <span class="string">&quot;请求成功&quot;</span> : <span class="string">&quot;请求失败&quot;</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次请求结果：&quot;</span> + resultStr + <span class="string">&quot;，耗时：&quot;</span> + (now - start));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;全部请求结束，成功率：&quot;</span> + (successCnt.get() * <span class="number">100</span> / requestCnt) + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-ConcurrentLinkedQueue版"><a href="#2-ConcurrentLinkedQueue版" class="headerlink" title="2.ConcurrentLinkedQueue版"></a>2.ConcurrentLinkedQueue版</h5><p>因为ConcurrentLinkedQueue已经保证了线程安全，所以无需加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentSlidingWindowRateLimiter</span> <span class="keyword">implements</span> <span class="title class_">MyRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每分钟限制请求数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> permitsPerMinute;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间窗口间隔秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> seconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存时间戳的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Long&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcurrentSlidingWindowRateLimiter</span><span class="params">(<span class="type">long</span> permitsPerMinute, <span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permitsPerMinute = permitsPerMinute;</span><br><span class="line">        <span class="built_in">this</span>.seconds = seconds;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentWindowCount</span> <span class="operator">=</span> getCurrentWindowCount(currentTimeMillis);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前窗口计数：&quot;</span> + currentWindowCount);</span><br><span class="line">        <span class="keyword">if</span> (currentWindowCount &gt;= permitsPerMinute) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存当前时间到队列</span></span><br><span class="line">        saveCurrentTime(currentTimeMillis);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveCurrentTime</span><span class="params">(<span class="type">long</span> currentTimeMillis)</span> &#123;</span><br><span class="line">        queue.offer(currentTimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getCurrentWindowCount</span><span class="params">(<span class="type">long</span> currentTimesMills)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算出窗口的开始位置时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> currentTimesMills - (seconds * <span class="number">1000L</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历当前存储的队列，删除无效的元素，并累加当前窗口中的所有计数器之和</span></span><br><span class="line">        Iterator&lt;Long&gt; iterator = queue.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">time</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (time &lt; startTime) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 将时间分片，seconds是时间窗口大小，max代表seconds时间最大访问上限</span></span><br><span class="line">        <span class="type">MyRateLimiter</span> <span class="variable">myRateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentSlidingWindowRateLimiter</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestCnt</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">successCnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; requestCnt; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> myRateLimiter.tryAcquire();</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                successCnt.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resultStr</span> <span class="operator">=</span> result ? <span class="string">&quot;请求成功&quot;</span> : <span class="string">&quot;请求失败&quot;</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次请求结果：&quot;</span> + resultStr + <span class="string">&quot;，耗时：&quot;</span> + (now - start));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;全部请求结束，成功率：&quot;</span> + (successCnt.get() * <span class="number">100</span> / requestCnt) + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210620202857.png" alt="漏桶算法"></p><p>漏桶算法概念如下：</p><ul><li>将每个请求视作”水滴”放入”漏桶”进行存储；</li><li>“漏桶”以固定速率向外”漏”出请求来执行如果”漏桶”空了则停止”漏水”；</li><li>如果”漏桶”满了则多余的”水滴”会被直接丢弃。</li></ul><p>漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。</p><p>漏桶算法的缺陷也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应。</p><h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakBucketRateLimiter</span> <span class="keyword">implements</span> <span class="title class_">MyRateLimiter</span> &#123;</span><br><span class="line">    <span class="comment">// 桶的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> capacity;</span><br><span class="line">    <span class="comment">// 漏出速率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> permitsPerSecond;</span><br><span class="line">    <span class="comment">// 剩余水量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> leftWater;</span><br><span class="line">    <span class="comment">// 上次注入时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeakBucketRateLimiter</span><span class="params">(<span class="type">double</span> capacity, <span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.permitsPerSecond = permitsPerSecond;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 计算剩余流量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// leftWater有可已经是0，所以减完会变成负数，所以要和0取个最大值</span></span><br><span class="line">        leftWater = Math.max(<span class="number">0</span>, leftWater - ((now - timestamp) / <span class="number">1000d</span> * permitsPerSecond));</span><br><span class="line">        System.out.println(<span class="string">&quot;leftWater = &quot;</span> + leftWater);</span><br><span class="line">        timestamp = now;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未满，则放行；否则限流</span></span><br><span class="line">        <span class="keyword">if</span> (leftWater &lt; capacity) &#123;</span><br><span class="line">            leftWater++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testLeakBucketRateLimiter</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singleThread</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="type">LeakBucketRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeakBucketRateLimiter</span>(<span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 存储流量的队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 模拟请求  不确定速率注水</span></span><br><span class="line">        singleThread.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> rateLimiter.tryAcquire();</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    queue.offer(index);</span><br><span class="line">                    System.out.println(index + <span class="string">&quot;--------流量被放行----------&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(index + <span class="string">&quot;流量被限制&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 模拟处理请求 固定速率漏水</span></span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                System.out.println(queue.poll() + <span class="string">&quot;被处理&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证主线程不会退出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210620202929.png" alt="令牌桶算法"></p><p>令牌桶算法概念如下：</p><ul><li>令牌以固定速率生成；</li><li>生成的令牌放入令牌桶中存放，如果令牌桶满了则多余的令牌会直接丢弃，当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行；</li><li>如果桶空了，那么尝试取令牌的请求会被直接丢弃。</li></ul><p>令牌桶算法既能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求，因此是目前使用较为广泛的一种限流算法。</p><h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 待补充</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzkwOTIxNDQ3OA==&mid=2247532784&idx=1&sn=4105e55673af275ea26701cb6070ab48&source=41#wechat_redirect">分布式服务限流实战</a></li><li><a href="https://doocs.github.io/advanced-java/#/./docs/high-concurrency/huifer-how-to-limit-current">限流算法实现</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;限流的算法有哪些？&quot;&gt;&lt;a href=&quot;#限流的算法有哪些？&quot; class=&quot;headerlink&quot; title=&quot;限流的算法有哪些？&quot;&gt;&lt;/a&gt;限流的算法有哪些？&lt;/h2&gt;&lt;p&gt;本文介绍几种最常用的限流算法：&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="限流算法原理及实现" scheme="https://blog.elfred.top/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>11讲</title>
    <link href="https://blog.elfred.top/posts/a0ee3b30.html"/>
    <id>https://blog.elfred.top/posts/a0ee3b30.html</id>
    <published>2021-06-13T07:00:00.000Z</published>
    <updated>2025-03-08T14:46:55.129Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="11-排序（上）：为什么插入排序比冒泡排序更受欢迎？"><a href="#11-排序（上）：为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？"></a>11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？</h1><p>排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。我只讲众多排序算法中的一小撮，也是最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。我按照时间复杂度把它们分成了三类，分三节课来讲解。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613203106.jpeg" alt="img"></p><p>带着问题去学习，是最有效的学习方法。所以按照惯例，我还是先给你出一个思考题：<strong>插入排序和冒泡排序的时间复杂度相同，都是 O(n^2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</strong></p><span id="more"></span><h2 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h2><h3 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h3><p>对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：</p><h4 id="1-最好情况、最坏情况、平均情况时间复杂度"><a href="#1-最好情况、最坏情况、平均情况时间复杂度" class="headerlink" title="1.最好情况、最坏情况、平均情况时间复杂度"></a>1.最好情况、最坏情况、平均情况时间复杂度</h4><p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p><p>为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</p><h4 id="2-时间复杂度的系数、常数-、低阶"><a href="#2-时间复杂度的系数、常数-、低阶" class="headerlink" title="2.时间复杂度的系数、常数 、低阶"></a>2.时间复杂度的系数、常数 、低阶</h4><p>我们知道，时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p><h4 id="3-比较次数和交换（或移动）次数"><a href="#3-比较次数和交换（或移动）次数" class="headerlink" title="3.比较次数和交换（或移动）次数"></a>3.比较次数和交换（或移动）次数</h4><p>这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p><h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。我们今天讲的三种排序算法，都是原地排序算法。</p><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，<strong>稳定性</strong>。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><p>我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。</p><p>这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p><p>你可能要问了，两个 3 哪个在前，哪个在后有什么关系啊，稳不稳定又有什么关系呢？为什么要考察排序算法的稳定性呢？</p><p>很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。</p><p>比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？</p><p>最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。</p><p>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？</p><p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</strong>。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613203939.jpeg" alt="img"></p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><p>我用一个例子，带你看下冒泡排序的整个过程。我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613204009.jpeg" alt="img"></p><p>可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613204017.jpeg" alt="img"></p><p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613204025.jpeg" alt="img"></p><p>冒泡排序算法的原理比较容易理解，具体的代码我贴到下面，你可以结合着代码来看我前面讲的原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="literal">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。</p><h3 id="第一，冒泡排序是原地排序算法吗？"><a href="#第一，冒泡排序是原地排序算法吗？" class="headerlink" title="第一，冒泡排序是原地排序算法吗？"></a>第一，冒泡排序是原地排序算法吗？</h3><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p><h3 id="第二，冒泡排序是稳定的排序算法吗？"><a href="#第二，冒泡排序是稳定的排序算法吗？" class="headerlink" title="第二，冒泡排序是稳定的排序算法吗？"></a>第二，冒泡排序是稳定的排序算法吗？</h3><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p><h3 id="第三，冒泡排序的时间复杂度是多少？"><a href="#第三，冒泡排序的时间复杂度是多少？" class="headerlink" title="第三，冒泡排序的时间复杂度是多少？"></a>第三，冒泡排序的时间复杂度是多少？</h3><p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n^2)。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613204155.jpeg" alt="img"></p><p>最好、最坏情况下的时间复杂度很容易分析，那平均情况下的时间复杂是多少呢？我们前面讲过，平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。</p><p>对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我这里还有一种思路，通过“<strong>有序度</strong>”和“<strong>逆序度</strong>”这两个概念来进行分析。</p><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613205428.jpeg" alt="img"></p><p>同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 <em><em>n</em>(n-1)&#x2F;2</em>*，也就是 15。我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。</p><p>逆序度的定义正好跟有序度相反（默认从小到大为有序），我想你应该已经想到了。关于逆序度，我就不举例子讲了。你可以对照我讲的有序度的例子自己看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逆序元素对：a[i] &gt; a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure><p>关于这三个概念，我们还可以得到一个公式：<strong>逆序度 &#x3D; 满有序度 - 有序度</strong>。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。</p><p>我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n&#x3D;6，所以排序完成之后终态的满有序度为 n*(n-1)&#x2F;2&#x3D;15。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613205527.jpeg" alt="img"></p><p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为<em><em>逆序度，也就是n</em>(n-1)&#x2F;2–初始有序度</em>*。此例中就是 15–3&#x3D;12，要进行 12 次交换操作。</p><p>对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)&#x2F;2 次交换。最好情况下，初始状态的有序度是 n*(n-1)&#x2F;2，就不需要进行交换。我们可以取个中间值 n*(n-1)&#x2F;4，来表示初始有序度既不是很高也不是很低的平均情况。</p><p>换句话说，平均情况下，需要 n*(n-1)&#x2F;4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。 </p><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>我们先来看一个问题。一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613204351.jpeg" alt="img"></p><p>这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。</p><p>那<strong>插入排序具体是如何借助上面的思想来实现排序的呢</strong>？</p><p>首先，我们将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613204424.jpeg" alt="img"></p><p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移动</strong>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p><p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p><p>为什么说移动次数就等于逆序度呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是 n*(n-1)&#x2F;2&#x3D;15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10&#x3D;3+3+4。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613204456.jpeg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[i];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来看点稍微复杂的东西。我这里还是有三个问题要问你。</p><h3 id="第一，插入排序是原地排序算法吗？"><a href="#第一，插入排序是原地排序算法吗？" class="headerlink" title="第一，插入排序是原地排序算法吗？"></a>第一，插入排序是原地排序算法吗？</h3><p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。</p><h3 id="第二，插入排序是稳定的排序算法吗？"><a href="#第二，插入排序是稳定的排序算法吗？" class="headerlink" title="第二，插入排序是稳定的排序算法吗？"></a>第二，插入排序是稳定的排序算法吗？</h3><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><h3 id="第三，插入排序的时间复杂度是多少？"><a href="#第三，插入排序的时间复杂度是多少？" class="headerlink" title="第三，插入排序的时间复杂度是多少？"></a>第三，插入排序的时间复杂度是多少？</h3><p>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是<strong>从尾到头遍历已经有序的数据</strong>。</p><p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n^2)。</p><p>还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n^2)。</p><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613204633.jpeg" alt="img"></p><p>选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。你可以自己来分析看看。</p><p>那选择排序是稳定的排序算法吗？这个问题我着重来说一下。</p><p>答案是否定的，选择排序是一种不稳定的排序算法。从我前面画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p><p>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>基本的知识都讲完了，我们来看开篇的问题：冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p><p>我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p><p>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>要想分析、评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看。因此，这一节，我带你分析了三种时间复杂度是 O(n^2) 的排序算法，冒泡排序、插入排序、选择排序。你需要重点掌握的是它们的分析方法。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613204826.jpeg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;11-排序（上）：为什么插入排序比冒泡排序更受欢迎？&quot;&gt;&lt;a href=&quot;#11-排序（上）：为什么插入排序比冒泡排序更受欢迎？&quot; class=&quot;headerlink&quot; title=&quot;11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？&quot;&gt;&lt;/a&gt;11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？&lt;/h1&gt;&lt;p&gt;排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。我只讲众多排序算法中的一小撮，也是最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。我按照时间复杂度把它们分成了三类，分三节课来讲解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210613203106.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;带着问题去学习，是最有效的学习方法。所以按照惯例，我还是先给你出一个思考题：&lt;strong&gt;插入排序和冒泡排序的时间复杂度相同，都是 O(n^2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>Kafka面试题</title>
    <link href="https://blog.elfred.top/posts/32ecfb01.html"/>
    <id>https://blog.elfred.top/posts/32ecfb01.html</id>
    <published>2021-05-29T15:11:00.000Z</published>
    <updated>2025-03-08T14:46:55.121Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="kafka入门"><a href="#kafka入门" class="headerlink" title="kafka入门"></a>kafka入门</h2><h3 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210529223532.png" alt="image"></p><h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>topic可以简单认为是一个队列，每个队列做不同的事情，队列之间相对隔离；每个队列都有不同的名字，这样我们就知道往哪个队列丢数据，也知道从哪个队列拿数据了。我们可以有多个生产者**往同一个队列(topic)<strong>丢数据，多个消费者</strong>从同一个队列(topic)**拿数据</p><h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p>为了提高每个队列（topic）的<strong>吞吐量</strong>，kafka会把topic进行分区(<strong>Partition</strong>)。每个topic包含多个分区。</p><p>所以，生产者实际上是往一个topic名为<code>sonder</code>中的分区(<strong>Partition</strong>)丢数据，消费者实际上是从一个topic名为<code>sonder</code>的分区(<strong>Partition</strong>)取数据</p><h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><p>一台Kafka服务器叫做<strong>Broker</strong>，Kafka集群就是多台Kafka服务器：</p><p>一个topic会分为多个partition，实际上partition会<strong>分布</strong>在不同的broker中，举个例子：</p><p>生产者往一个topic里面丢数据，实际上数据会在partition中，partition会分布在不同的<strong>broker</strong>（服务器）上。</p><p>由此得知：<strong>Kafka是天然分布式的</strong>。</p><h3 id="消费者和消费者组"><a href="#消费者和消费者组" class="headerlink" title="消费者和消费者组"></a>消费者和消费者组</h3><p>既然数据是保存在partition中的，那么消费者实际上也是从partition中取数据。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210529221224.jpeg" alt="图片"></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210529221549.png" alt="img"></p><p>使用 Consumer high level API 时，同一 Topic 的一条消息只能被同一个 Consumer Group 内的一个 Consumer 消费，但多个 Consumer Group 可同时消费这一消息。</p><p>这是 Kafka 用来实现一个 Topic 消息的广播（发给所有的 Consumer）和单播（发给某一个 Consumer）的手段。一个 Topic 可以对应多个 Consumer Group。如果需要实现广播，只要每个 Consumer 有一个独立的 Group 就可以了。要实现单播只要所有的 Consumer 在同一个 Group 里。用 Consumer Group 还可以将 Consumer 进行自由的分组而不需要多次发送消息到不同的 Topic。</p><p>多个消费者组成一个消费者组，每个消费者组之间相互独立。<strong>同一个消费者组中的不同消费者不能同时消费同一个分区的数据</strong>。但不同的消费者组可以消费相同的分区的数据（广播消费）。</p><p>每个消费者组唯一对应一个topic，一个topic下面可能有多个消费者组，这样就实现了广播消费。</p><blockquote><p>注意：如果消费者不指定消费者组，那么将会使用默认的消费者组，每个topic都有一个默认消费者组。</p></blockquote><p>关于消费者数量，要注意几点：</p><ul><li>如果消费者组中的某个消费者挂了，那么其中一个消费者可能就要消费两个partition了</li><li>如果只有三个partition，而消费者组有4个消费者，那么一个消费者会空闲（一个分区不会被两个消费者同时消费）</li><li>如果多加入一个<strong>消费者组</strong>，无论是新增的消费者组还是原本的消费者组，都能消费topic的全部数据。（消费者组之间从逻辑上它们是<strong>独立</strong>的）</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="Kafka分区如果出现故障怎么办？"><a href="#Kafka分区如果出现故障怎么办？" class="headerlink" title="Kafka分区如果出现故障怎么办？"></a>Kafka分区如果出现故障怎么办？</h3><p>现在我们已经知道了往topic里边丢数据，实际上这些数据会分到不同的partition上，这些partition存在不同的broker上。分布式肯定会带来问题：“万一其中一台broker(Kafka服务器)出现网络抖动或者挂了，怎么办？”</p><p>Kafka是这样做的：我们数据存在不同的partition上，那kafka就把这些partition做<strong>备份</strong>（replica）。比如，现在我们有三个partition，分别存在三台broker上。每个partition都会备份，这些备份散落在<strong>不同</strong>的broker上。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210529215119.webp" alt="图片"></p><p>红色块的partition代表的是<strong>主</strong>分区，紫色的partition块代表的是<strong>备份</strong>分区。生产者往topic丢数据，是与<strong>主</strong>分区交互，消费者消费topic的数据，也是与主分区交互。</p><p><strong>备份分区仅仅用作于备份，不做读写。</strong>如果某个Broker挂了，那就会选举出其他Broker的partition来作为主分区，这就实现了<strong>高可用</strong>。</p><h3 id="ISR（in-sync-replica）机制"><a href="#ISR（in-sync-replica）机制" class="headerlink" title="ISR（in-sync-replica）机制"></a>ISR（in-sync-replica）机制</h3><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><h3 id="Kafka消息可靠性是如何保证的？"><a href="#Kafka消息可靠性是如何保证的？" class="headerlink" title="Kafka消息可靠性是如何保证的？"></a>Kafka消息可靠性是如何保证的？</h3><p><strong>Acks机制</strong>：</p><ul><li><strong>0</strong>：不进行消息接收是否成功的确认（默认值），会丢失数据。</li><li><strong>1</strong>：当Leader副本接收成功后，返回接收成功确认信息，主备切换可能会丢失数据。</li><li><strong>-1（all）</strong>：当Leader和Follower副本都接收成功后，返回接收成功的确认信息。</li></ul><h3 id="消息投递语义"><a href="#消息投递语义" class="headerlink" title="消息投递语义"></a>消息投递语义</h3><p><a href="https://www.cnblogs.com/luxiaoxun/p/13048474.html">https://www.cnblogs.com/luxiaoxun/p/13048474.html</a></p><p>消息投递语义有三种：</p><p><strong>At most once</strong>：最多一次，消息可能丢失，但不会重复</p><p><strong>At least once</strong>：最少一次，消息不会丢失，可能会重复</p><p><strong>Exactly once</strong>：有且只有一次，消息不会丢失或重复，只会消费一次（0.11版本实现，仅限于下游也是kafka）</p><h4 id="幂等：partition内部的exactly-once顺序语义"><a href="#幂等：partition内部的exactly-once顺序语义" class="headerlink" title="幂等：partition内部的exactly-once顺序语义"></a>幂等：partition内部的exactly-once顺序语义</h4><p>幂等操作，是指可以执行多次，而不会产生与仅执行一次不同结果的操作，Producer的send操作现在是幂等的。在任何导致producer重试的情况下，相同的消息，如果被producer发送多次，也只会被写入Kafka一次。要打开此功能，并让所有partition获得exactly-once delivery、无数据丢失和in-order语义，需要修改broker的配置：<strong>enable.idempotence &#x3D; true</strong>。</p><p>这个功能如何工作？它的工作方式类似于TCP：发送到Kafka的每批消息将包含一个序列号，该序列号用于重复数据的删除。与TCP不同，TCP只能在transient in-memory中提供保证。<strong>序列号将被持久化存储topic中，因此即使leader replica失败，接管的任何其他broker也将能感知到消息是否重复。</strong></p><p>这种机制的开销相当低：它只是在每批消息中添加了几个额外字段:</p><ul><li>PID，在Producer初始化时分配，作为每个Producer会话的唯一标识；</li><li>序列号（sequence number），Producer发送的每条消息（更准确地说是每一个消息批次，即ProducerBatch）都会带有此序列号，从0开始单调递增。Broker根据它来判断写入的消息是否可接受。</li></ul><h3 id="事务机制：跨partition的原子性写操作"><a href="#事务机制：跨partition的原子性写操作" class="headerlink" title="事务机制：跨partition的原子性写操作"></a>事务机制：跨partition的原子性写操作</h3><p><a href="https://www.cnblogs.com/luxiaoxun/p/13048474.html">https://www.cnblogs.com/luxiaoxun/p/13048474.html</a></p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="为什么用kafka不用本地队列"><a href="#为什么用kafka不用本地队列" class="headerlink" title="为什么用kafka不用本地队列"></a>为什么用kafka不用本地队列</h3><p>高吞吐</p><p>消息持久化</p><p>分布式易拓展</p><h3 id="kafka为什么这么快"><a href="#kafka为什么这么快" class="headerlink" title="kafka为什么这么快"></a>kafka为什么这么快</h3><p>Kafka速度的秘诀在于，它把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络IO损耗，通过mmap提高I&#x2F;O速度，写入数据的时候由于单个Partion是末尾添加所以速度最优；读取数据的时候配合sendfile直接暴力输出。</p><p>具体分写入和读取两个方面：</p><p><strong>写入</strong>：</p><ul><li>使用顺序写入</li><li>Memory Mapped Files</li></ul><p><strong>读取</strong>：</p><ul><li>基于sendfile实现Zero Copy</li><li>批量压缩</li></ul><h3 id="什么是零拷贝？"><a href="#什么是零拷贝？" class="headerlink" title="什么是零拷贝？"></a>什么是零拷贝？</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210529210252.webp" alt="图片"></p><p><a href="https://www.cnblogs.com/rickiyang/p/13265043.html">https://www.cnblogs.com/rickiyang/p/13265043.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;kafka入门&quot;&gt;&lt;a href=&quot;#kafka入门&quot; class=&quot;headerlink&quot; title=&quot;kafka入门&quot;&gt;&lt;/a&gt;kafka入门&lt;/h2&gt;&lt;h3 id=&quot;整体架构图&quot;&gt;&lt;a href=&quot;#整体架构图&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="kafka" scheme="https://blog.elfred.top/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>五月第二周</title>
    <link href="https://blog.elfred.top/posts/b2caa2b7.html"/>
    <id>https://blog.elfred.top/posts/b2caa2b7.html</id>
    <published>2021-05-23T05:55:00.000Z</published>
    <updated>2025-03-08T14:46:55.132Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.05.17-2021.05.23</p><h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h3><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h3><p>难度中等165</p><p>返回与给定的前序和后序遍历匹配的任何二叉树。</p><p> <code>pre</code> 和 <code>post</code> 遍历中的值是不同的正整数。</p><p> <strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]</span><br><span class="line">输出：[1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= pre.length == post.length &lt;= 30</code></li><li><code>pre[]</code> 和 <code>post[]</code> 都是 <code>1, 2, ..., pre.length</code> 的排列</li><li>每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.05.17-2021.05.23&lt;/p&gt;
&lt;h3 id=&quot;437-路径总和-III&quot;&gt;&lt;a href=&quot;#437-路径总和-III&quot; class=&quot;headerlink&quot; title=&quot;437. 路径总和 III&quot;&gt;&lt;/a&gt;&lt;</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>五月第一周</title>
    <link href="https://blog.elfred.top/posts/82dc4e6f.html"/>
    <id>https://blog.elfred.top/posts/82dc4e6f.html</id>
    <published>2021-05-23T05:06:00.000Z</published>
    <updated>2025-03-08T14:46:55.134Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.05.10-2021.05.16</p><h3 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>target = 22</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p>返回:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><p>注意：本题与主站 113 题相同：<a href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-04-03-特定深度节点链表"><a href="#面试题-04-03-特定深度节点链表" class="headerlink" title="面试题 04.03. 特定深度节点链表"></a><a href="https://leetcode-cn.com/problems/list-of-depth-lcci/">面试题 04.03. 特定深度节点链表</a></h3><p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 <code>D</code>，则会创建出 <code>D</code> 个链表）。返回一个包含所有深度的链表的数组。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,null,7,8]</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       /  \ </span><br><span class="line">      2    3</span><br><span class="line">     / \    \ </span><br><span class="line">    4   5    7</span><br><span class="line">   /</span><br><span class="line">  8</span><br><span class="line"></span><br><span class="line">输出：[[1],[2,3],[4,5,7],[8]]</span><br></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.05.10-2021.05.16&lt;/p&gt;
&lt;h3 id=&quot;剑指-Offer-34-二叉树中和为某一值的路径&quot;&gt;&lt;a href=&quot;#剑指-Offer-34-二叉树中和为某一值的路径&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://blog.elfred.top/posts/f7ede91d.html"/>
    <id>https://blog.elfred.top/posts/f7ede91d.html</id>
    <published>2021-05-19T00:23:00.000Z</published>
    <updated>2025-03-08T14:46:55.120Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="集合大小如何计算"><a href="#集合大小如何计算" class="headerlink" title="集合大小如何计算"></a>集合大小如何计算</h4><p><strong>1.7</strong></p><p>JDK7版本经过三次计算，发现每次统计时哈希都有结构性的变化，就会给每个Segment加锁；而当自己统计完之后，才会把锁释放掉。</p><p><strong>1.8</strong></p><p>借助baseCount和countCells属性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;h3 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMa</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>23讲 | 二叉树基础（上）</title>
    <link href="https://blog.elfred.top/posts/e0f293c6.html"/>
    <id>https://blog.elfred.top/posts/e0f293c6.html</id>
    <published>2021-05-15T14:00:00.000Z</published>
    <updated>2025-03-08T14:46:55.130Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="23-二叉树基础（上）：什么样的二叉树适合用数组来存储？"><a href="#23-二叉树基础（上）：什么样的二叉树适合用数组来存储？" class="headerlink" title="23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？"></a>23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？</h1><h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>我们首先来看，什么是“树”？再完备的定义，都没有图直观。所以我在图中画了几棵“树”。你来看看，这些“树”都有什么特征？</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515215731.jpeg" alt="img"></p><p>你有没有发现，“树”这种数据结构真的很像我们现实生活中的“树”，这里面每个元素我们叫做“节点”；用来连接相邻节点之间的关系，我们叫做“父子关系”。</p><p>比如下面这幅图，A 节点就是 B 节点的<strong>父节点</strong>，B 节点是 A 节点的<strong>子节点</strong>。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为<strong>兄弟节点。</strong>我们把没有父节点的节点叫做<strong>根节点</strong>，也就是图中的节点 E。我们把没有子节点的节点叫做<strong>叶子节点</strong>或者<strong>叶节点</strong>，比如图中的 G、H、I、J、K、L 都是叶子节点。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515215750.jpeg" alt="img"></p><p>除此之外，关于“树”，还有三个比较相似的概念：<strong>高度</strong>（Height）、<strong>深度</strong>（Depth）、<strong>层</strong>（Level）。它们的定义是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515215851.jpeg" alt="img"></p><p>这三个概念的定义比较容易混淆，描述起来也比较空洞。我举个例子说明一下，你一看应该就能明白。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515215915.jpeg" alt="img"></p><p>记这几个概念，我还有一个小窍门，就是类比“高度”“深度”“层”这几个名词在生活中的含义。</p><p>在我们的生活中，“高度”这个概念，其实就是从下往上度量，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。</p><p>“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。</p><p>“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点位于第 1 层。</p><h2 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h2><p>树结构多种多样，不过我们最常用还是二叉树。</p><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。我画的这几个都是二叉树。以此类推，你可以想象一下四叉树、八叉树长什么样子。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515213800.jpeg" alt="img"></p><p>这个图里面，有两个比较特殊的二叉树，分别是编号 2 和编号 3 这两个。</p><p>其中，编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树。</p><p>编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。</p><p>满二叉树很好理解，也很好识别，但是完全二叉树，有的人可能就分不清了。我画了几个完全二叉树和非完全二叉树的例子，你可以对比着看看。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515213820.jpeg" alt="img"></p><p>你可能会说，满二叉树的特征非常明显，我们把它单独拎出来讲，这个可以理解。但是完全二叉树的特征不怎么明显啊，单从长相上来看，完全二叉树并没有特别特殊的地方啊，更像是“芸芸众树”中的一种。</p><p>那我们为什么还要特意把它拎出来讲呢？为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树？如果靠右排列就不能叫完全二叉树了吗？这个定义的由来或者说目的在哪里？</p><p>要理解完全二叉树定义的由来，我们需要先了解，<strong>如何表示（或者存储）一棵二叉树</strong>？</p><p>想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p><p>我们先来看比较简单、直观的<strong>链式存储法</strong>。从图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515213921.jpeg" alt="img"></p><p>我们再来看，基于数组的<strong>顺序存储法</strong>。我们把根节点存储在下标 i &#x3D; 1 的位置，那左子节点存储在下标 2 * i &#x3D; 2 的位置，右子节点存储在 2 * i + 1 &#x3D; 3 的位置。以此类推，B 节点的左子节点存储在 2 * i &#x3D; 2 * 2 &#x3D; 4 的位置，右子节点存储在 2 * i + 1 &#x3D; 2 * 2 + 1 &#x3D; 5 的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515214026.jpeg" alt="img"></p><p>我来总结一下，如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i&#x2F;2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。</p><p>不过，我刚刚举的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。你可以看我举的下面这个例子。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515214223.jpeg" alt="img"></p><p>所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p><p>当我们讲到堆和堆排序的时候，你会发现，堆其实就是一种完全二叉树，最常用的存储方式就是数组。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>前面我讲了二叉树的基本定义和存储方法，现在我们来看二叉树中非常重要的操作，二叉树的遍历。这也是非常常见的面试题。</p><p>如何将所有节点都遍历打印出来呢？经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p><ul><li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li><li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li><li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210515220044.jpeg" alt="img"></p><p><strong>实际上，二叉树的前、中、后序遍历就是一个递归的过程</strong>。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p><p>写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = <span class="built_in">print</span> r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;<span class="built_in">print</span> r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;<span class="built_in">print</span> r</span><br></pre></td></tr></table></figure><p>有了递推公式，代码写起来就简单多了。这三种遍历方式的代码，我都写出来了，你可以看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node* root)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(Node* root)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(Node* root)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树的前、中、后序遍历的递归实现是不是很简单？你知道二叉树遍历的时间复杂度是多少吗？我们一起来看看。</p><p>从我前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol><li><p>给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？</p><blockquote><p>是卡特兰数，是C[n,2n] &#x2F; (n+1)种形状，c是组合数，节点的不同又是一个全排列，一共就是n!*C[n,2n] &#x2F; (n+1)个二叉树。可以通过数学归纳法推导得出。</p></blockquote></li><li><p>我们讲了三种二叉树的遍历方式，前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？(队列)</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;23-二叉树基础（上）：什么样的二叉树适合用数组来存储？&quot;&gt;&lt;a href=&quot;#23-二叉树基础（上）：什么样的二叉树适合用数组来存储？&quot; class=&quot;headerlink&quot; title=&quot;23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？&quot;</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>24讲 | 二叉树基础（下）</title>
    <link href="https://blog.elfred.top/posts/70f96e94.html"/>
    <id>https://blog.elfred.top/posts/70f96e94.html</id>
    <published>2021-05-15T14:00:00.000Z</published>
    <updated>2025-03-08T14:46:55.131Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="24-二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？"><a href="#24-二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？" class="headerlink" title="24 | 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？"></a>24 | 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？</h1><h2 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h2><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。它是怎么做到这些的呢？</p><p>这些都依赖于二叉查找树的特殊结构<strong>。二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong> 我画了几个二叉查找树的例子，你一看应该就清楚了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210516134604.jpeg" alt="img"></p><p>前面我们讲到，二叉查找树支持快速查找、插入、删除操作，现在我们就依次来看下，这三个操作是如何实现的。</p><h3 id="1-二叉查找树的查找操作"><a href="#1-二叉查找树的查找操作" class="headerlink" title="1. 二叉查找树的查找操作"></a>1. 二叉查找树的查找操作</h3><p>首先，我们看如何在二叉查找树中查找一个节点。我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210516134630.jpeg" alt="img"></p><p>这里我把查找的代码实现了一下，贴在下面了，结合代码，理解起来会更加容易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Node tree;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Node <span class="title function_">find</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &lt; p.data) p = p.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-二叉查找树的插入操作"><a href="#2-二叉查找树的插入操作" class="headerlink" title="2. 二叉查找树的插入操作"></a>2. 二叉查找树的插入操作</h3><p>二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210516134908.jpeg" alt="img"></p><p>同样，插入的代码我也实现了一下，贴在下面，你可以看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="literal">null</span>) &#123;</span><br><span class="line">    tree = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tree;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        p.right = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt; p.data</span></span><br><span class="line">      <span class="keyword">if</span> (p.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        p.left = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-二叉查找树的删除操作"><a href="#3-二叉查找树的删除操作" class="headerlink" title="3. 二叉查找树的删除操作"></a>3. 二叉查找树的删除操作</h3><p>二叉查找树的查找、插入操作都比较简单易懂，但是它的删除操作就比较复杂了 。针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。</p><p>第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。</p><p>第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。</p><p>第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210516135051.jpeg" alt="img"></p><p>老规矩，我还是把删除的代码贴在这里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">  <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">  <span class="type">Node</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">    <span class="keyword">else</span> p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="literal">null</span> &amp;&amp; p.right != <span class="literal">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">minP</span> <span class="operator">=</span> p.right;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">minPP</span> <span class="operator">=</span> p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="literal">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">    p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">    pp = minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">  Node child; <span class="comment">// p的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="literal">null</span>) child = p.left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="literal">null</span>) child = p.right;</span><br><span class="line">  <span class="keyword">else</span> child = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="literal">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">  <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;24-二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？&quot;&gt;&lt;a href=&quot;#24-二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？&quot; class=&quot;headerlink&quot; title=&quot;24 | 二叉树基础（下）：有了如此高效的</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title> 2021面经第二波</title>
    <link href="https://blog.elfred.top/posts/90dd64e0.html"/>
    <id>https://blog.elfred.top/posts/90dd64e0.html</id>
    <published>2021-05-09T12:21:00.000Z</published>
    <updated>2025-03-08T14:46:55.120Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="涂鸦智能"><a href="#涂鸦智能" class="headerlink" title="涂鸦智能"></a>涂鸦智能</h3><ul><li>redis为什么这么快</li><li>redis为什么是单线程</li><li>3000万数据的表，如何进行优化</li><li>分库分表、多维度查询</li></ul><h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><ul><li><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p></li><li><p>堆外内存</p></li><li><p>类加载机制</p></li><li><p>双亲委派机制，如何打破</p></li><li><p>不同的类加载器加载的类是不是同一个类</p><blockquote><p><a href="https://cloud.tencent.com/developer/news/627029">https://cloud.tencent.com/developer/news/627029</a></p><p>不同类加载器加载的类在 JVM 看来是两个不同的类，因为在 JVM 中一个类的唯一标识是类加载器+类名。通过这种方式我们就能够同时加载 C 的两个不同版本的类，即使它类名是一样的。注意，这里类加载器指的是类加载器的实例，并不是一定要定义两个不同类加载器</p></blockquote></li><li><p>线程池原理以及使用场景</p></li><li><p>synchronized和ReentrantLock的区别（是否是重入锁）</p></li><li><p>ReentrantLock非公平锁和公平锁如何做到的</p></li><li><p>synchronized锁升级原理</p></li><li><p>redis分布式锁如何使用</p></li><li><p>业务没执行完，分布式锁过期释放，如何解决</p></li><li><p>springcloud和dubbo的区别</p></li><li><p>rpc协议和http协议的区别</p></li><li><p>https的原理</p></li><li><p>序列化方式有哪几种，dubbo默认是哪种</p></li><li><p>mysql查询优化</p></li><li><p>mysql为什么用b+树</p></li></ul><h3 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h3><ul><li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></li><li>HashMap在jdk1.7扩容过程</li><li>HashMap什么情况下会链表成环</li><li>HashMap为什么线程不安全</li><li>反射原理以及使用场景</li><li>创建对象的几种形式</li><li>聚合根、实体在业务中的应用</li><li>redis集群、高可用、持久化</li><li>本地事务表如果TPS太高，如何优化</li></ul><h3 id="酷家乐"><a href="#酷家乐" class="headerlink" title="酷家乐"></a>酷家乐</h3><ul><li>最长回文子串</li><li>带<code>+ - * /（）</code>的基本计算器</li><li>binlog存储形式（row和statement）</li><li>mvcc具体是如何解决幻读的？</li><li>类加载过程</li></ul><h3 id="哈罗单车"><a href="#哈罗单车" class="headerlink" title="哈罗单车"></a>哈罗单车</h3><ul><li><p>两个不同版本的类，如果我都想去加载？如何去做（自定义两个类加载器去加载）</p></li><li><p>MySQL为什么不用平衡树？</p><blockquote><p>因为数据是存储在磁盘上的，进行查询操作的时，需要先将数据加载到内存中（磁盘IO操作）。而数据并不能一次性全部加载到内存中，只能逐一加载每个磁盘页（对应树的一个节点），并且磁盘IO操作很慢，平衡二叉树由于深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。为了减少磁盘的IO次数，就需要降低树的深度，那么就引出了B树和B+树：每个节点存储多个元素，采用多叉树结构。所以使用B+树而不是平衡二叉树。</p><p>B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</p><p>总结：平衡树没能充分利用磁盘预读（局部性原理）功能，而B+树每个节点是一个磁盘页，每个节点包含多个key，每次加载能把一页数据全部加载到内存，提高了缓存命中率。</p></blockquote></li><li><p>MySQL为什么使用B+树索引而不是B树索引？</p><blockquote><ol><li>B+树叶子节点使用双向链表连接，范围查询非常方便；而B树必须用中序遍历的方法按序扫库，效率低下</li><li>B+树非叶子节点不保存数据，同样的磁盘页大小容纳的关键字更多，一次性读入内存的关键字也就越多，相对来说说IO次数就降低了</li><li>B+树查询效率更稳定：因为B+树非叶子节点不保存数据，所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ol></blockquote></li></ul><h3 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h3><ul><li><p>cms和G1垃圾回收器的区别？为什么G1适合大内存，G1如何做到可预测的低停顿的？</p><blockquote><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数 - XX:MaxGCPauseMills指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名称的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p></blockquote></li><li><p>读写锁的实现细节</p></li><li><p>volatile保证了什么？如何保证的？内存屏障的指令有哪些？</p></li><li><p>SQL注入是啥，以及它的原理，如何避免？</p></li><li><p>MySQL如何解决幻读？（除了MVCC之外还能如何解决？）</p></li><li><p>kafka消息投递语义精准一次性（Exactly-once）是如何保证的？</p><blockquote><p> 这个特性是怎么实现的呢？在底层，它和TCP的工作原理有点像，每一批发送到Kafka的消息都将包含一个序列号，broker将使用这个序列号来删除重复的发送。和只能在瞬态内存中的连接中保证不重复的TCP不同，这个序列号被持久化到副本日志，所以，即使分区的leader挂了，其他的broker接管了leader，新leader仍可以判断重新发送的是否重复了。这种机制的开销非常低：每批消息只有几个额外的字段：</p><ul><li>PID，在Producer初始化时分配，作为每个Producer会话的唯一标识；</li><li>序列号（sequence number），Producer发送的每条消息（更准确地说是每一个消息批次，即ProducerBatch）都会带有此序列号，从0开始单调递增。Broker根据它来判断写入的消息是否可接受。</li></ul></blockquote></li></ul><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><ul><li><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></li><li>JVM内存区域</li><li>CMS垃圾回收器</li><li>垃圾回收算法</li><li>类加载过程</li><li>线程池原理，使用场景，参数如何配置，如何预创建线程</li><li>Spring AOP原理</li><li>redis使用场景</li><li>redis单线程为什么这么快</li><li>redis为什么能支撑10万QPS</li></ul><h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><ul><li><p>布隆过滤器如何降低误判率</p><blockquote><p>增加hash函数个数或者增大位数组容量</p></blockquote></li><li><p>jdk8为什么要取消方法区，设立元空间</p></li><li><p>元空间参数如何配置</p><blockquote><p><strong>-XX:MetaspaceSize</strong>：Metaspace 空间初始大小，如果不设置的话，默认是20.79M，这个初始大小是触发首次 Metaspace Full GC 的阈值，例如 -XX:MetaspaceSize&#x3D;256M</p><p><strong>-XX:MaxMetaspaceSize</strong>：Metaspace 最大值，默认不限制大小，但是线上环境建议设置，例如</p><p>-XX:MaxMetaspaceSize&#x3D;256M</p><p><strong>-XX:MinMetaspaceFreeRatio</strong>：最小空闲比，当 Metaspace 发生 GC 后，会计算 Metaspace 的空闲比，如果空闲比(空闲空间&#x2F;当前 Metaspace 大小)小于此值，就会触发 Metaspace 扩容。默认值是 40 ，也就是 40%，例如 -XX:MinMetaspaceFreeRatio&#x3D;40</p><p><strong>-XX:MaxMetaspaceFreeRatio</strong>:最大空闲比，当 Metaspace 发生 GC 后，会计算 Metaspace 的空闲比，如果空闲比(空闲空间&#x2F;当前 Metaspace 大小)大于此值，就会触发 Metaspace 释放空间。默认值是 70 ，也就是 70%，例如 -XX:MaxMetaspaceFreeRatio&#x3D;70</p><ul><li>建议将 MetaspaceSize 和 MaxMetaspaceSize 设置为同样大小，避免频繁扩容。</li></ul></blockquote></li><li><p>如何减少回表</p></li><li><p>oom如何排查</p><blockquote><p><a href="https://www.cnblogs.com/lujiango/p/9650927.html">https://www.cnblogs.com/lujiango/p/9650927.html</a></p><p>1.<strong>确认是不是内存本身就分配过小</strong></p><p><code>jmap -heap pid</code></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210610232554.png" alt="img"></p><p>如图，可以查看新生代，老年代堆内存的分配大小以及使用情况，看是否本身分配过小。</p><p>2.<strong>找到最耗内存的对象</strong></p><p><code>jmap -histo:live pid | more</code></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210610232744.png" alt="img"></p><p>如图，结果以表格的形式显示存活对象的信息，并按照所占内存大小排序：</p><p>实例数，所占内存大小，类名</p><p>如果发现某类对象占用内存很大，很可能是类对象创建太多，且一直未释放。例如：</p><p>（1）申请完资源后，未调用close释放资源</p><p>（2）消费者消费速度慢，生产者不断往队列中投递任务，导致队列中任务累积过多</p><p>3.<strong>确认释放是资源耗尽</strong></p><p>pstree：查看进程创建的线程数</p><p>netstat：网络连接数</p><p>还有另一种方法，通过</p><p>ll &#x2F;proc&#x2F;pid&#x2F;fd 查看占用句柄</p><p>ll &#x2F;proc&#x2F;pid&#x2F;task 查看线程数</p><p>例如，某一台显示服务器的sshd进程是1041，查看：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210610233254.png" alt="img"></p><p>sshd共占用了5个句柄。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210610233318.png" alt="img"></p><p>sshd只有一个主线程为1041，并没有多线程。</p></blockquote></li></ul><h3 id="阿里（商家）"><a href="#阿里（商家）" class="headerlink" title="阿里（商家）"></a>阿里（商家）</h3><ul><li>本地缓存一般适用于什么场景？如何保证缓存一致性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;涂鸦智能&quot;&gt;&lt;a href=&quot;#涂鸦智能&quot; class=&quot;headerlink&quot; title=&quot;涂鸦智能&quot;&gt;&lt;/a&gt;涂鸦智能&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;redis为什么这么快&lt;/li&gt;
&lt;li&gt;redis为什么是单线程&lt;/li&gt;
&lt;li&gt;3000万数据的</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>17讲</title>
    <link href="https://blog.elfred.top/posts/858564ec.html"/>
    <id>https://blog.elfred.top/posts/858564ec.html</id>
    <published>2021-05-08T23:57:00.000Z</published>
    <updated>2025-03-08T14:46:55.130Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="17-跳表：为什么Redis一定要用跳表来实现有序集合？"><a href="#17-跳表：为什么Redis一定要用跳表来实现有序集合？" class="headerlink" title="17 | 跳表：为什么Redis一定要用跳表来实现有序集合？"></a>17 | 跳表：为什么Redis一定要用跳表来实现有序集合？</h1><p>Redis 中的有序集合（Sorted Set）就是用跳表来实现的。如果你有一定基础，应该知道红黑树也可以实现快速地插入、删除和查找操作。那 Redis 为什么会选择用跳表来实现有序集合呢？ 为什么不用红黑树呢？学完今天的内容，你就知道答案了。</p><h2 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h2><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210509151948.jpeg" alt="img"></p><p>那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做索引或索引层。你可以看我画的图。图中的 down 表示 down 指针，指向下一级结点。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210509152007.jpeg" alt="img"></p><p>如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。</p><p>从这个例子里，我们看出，<strong>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</strong>。那如果我们再加一级索引呢？效率会不会提升更多呢？</p><p>跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在我们再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210509152037.jpeg" alt="img"></p><p>我举的例子数据量不大，所以即便加了两级索引，查找效率的提升也并不明显。为了让你能真切地感受索引提升查询效率。我画了一个包含 64 个结点的链表，按照前面讲的这种思路，建立了五级索引。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210509152117.jpeg" alt="img"></p><p>从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点，速度是不是提高了很多？所以，当链表的长度 n 比较大时，比如 1000、10000 的时候，在构建索引之后，查找效率的提升就会非常明显。</p><p>前面讲的<strong>这种链表加多级索引的结构，就是跳表</strong>。我通过例子给你展示了跳表是如何减少查询次数的，现在你应该比较清晰地知道，跳表确实是可以提高查询效率的。接下来，我会定量地分析一下，用跳表查询到底有多快。</p><h2 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h2><p>前面我讲过，算法的执行效率可以通过时间复杂度来度量，这里依旧可以用。我们知道，在一个单链表中查询某个数据的时间复杂度是 O(n)。那在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？</p><p>这个时间复杂度的分析方法比较难想到。我把问题分解一下，先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？</p><p>按照我们刚才讲的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n&#x2F;2，第二级索引的结点个数大约就是 n&#x2F;4，第三级索引的结点个数大约就是 n&#x2F;8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1&#x2F;2，那第 k级索引结点的个数就是 n&#x2F;(2k)。</strong></p><p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n&#x2F;(2h)&#x3D;2，从而求得 h&#x3D;log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p><p>那这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m&#x3D;3，为什么是 3 呢？我来解释一下。</p><p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210509152501.jpeg" alt="img"></p><p>通过上面的分析，我们得到 m&#x3D;3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找，是不是很神奇？不过，天下没有免费的午餐，这种查询效率的提升，前提是建立了很多级索引，也就是我们在第 6 节讲过的空间换时间的设计思路。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>今天的内容到此就讲完了。现在，我来讲解一下开篇的思考题：为什么 Redis 要用跳表来实现有序集合，而不是红黑树？</p><p>Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。不过散列表我们后面才会讲到，所以我们现在暂且忽略这部分。如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：</p><ul><li>插入一个数据；</li><li>删除一个数据；</li><li>查找一个数据；</li><li>按照区间查找数据（比如查找值在[100, 356]之间的数据）；</li><li>迭代输出有序序列。</li></ul><p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</p><p>对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</p><p>当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p><p>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们讲了跳表这种数据结构。跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速地插入、删除、查找操作，时间复杂度都是 O(logn)。</p><p>跳表的空间复杂度是 O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;17-跳表：为什么Redis一定要用跳表来实现有序集合？&quot;&gt;&lt;a href=&quot;#17-跳表：为什么Redis一定要用跳表来实现有序集合？&quot; class=&quot;headerlink&quot; title=&quot;17 | 跳表：为什么Redis一定要用跳表来实现有序集合？&quot;</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>16讲 | 二分查找（下）</title>
    <link href="https://blog.elfred.top/posts/dfdc8e63.html"/>
    <id>https://blog.elfred.top/posts/dfdc8e63.html</id>
    <published>2021-05-06T23:57:00.000Z</published>
    <updated>2025-03-08T14:46:55.131Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="16-二分查找（下）：如何快速定位IP对应的省份地址？"><a href="#16-二分查找（下）：如何快速定位IP对应的省份地址？" class="headerlink" title="16 | 二分查找（下）：如何快速定位IP对应的省份地址？"></a>16 | 二分查找（下）：如何快速定位IP对应的省份地址？</h1><h2 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h2><p>比如下面这样一个有序数组，其中，a[5]，a[6]，a[7]的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210507081300.jpeg" alt="img"></p><p>如果我们用上一节课讲的二分查找的代码实现，首先拿 8 与区间的中间值 a[4]比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7]正好等于 8，所以代码就返回了。</p><p>尽管 a[7]也等于 8，但它并不是我们想要找的第一个等于 8 的元素，因为第一个值等于 8 的元素是数组下标为 5 的元素。我们上一节讲的二分查找代码就无法处理这种情况了。所以，针对这个变形问题，我们可以稍微改造一下上一节的代码。</p><p>我换了一种实现方法，你看看是不是更容易理解呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我来稍微解释一下这段代码。a[mid]跟要查找的 value 的大小关系有三种情况：大于、小于、等于。对于 a[mid]&gt;value 的情况，我们需要更新 high&#x3D; mid-1；对于 a[mid]&lt;value 的情况，我们需要更新 low&#x3D;mid+1。这两点都很好理解。那当 a[mid]&#x3D;value 的时候应该如何处理呢？</p><p>如果我们查找的是任意一个值等于给定值的元素，当 a[mid]等于要查找的值时，a[mid]就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当 a[mid]等于要查找的值时，我们就需要确认一下这个 a[mid]是不是第一个值等于给定值的元素。</p><p>我们重点看第 11 行代码。如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid]的前一个元素 a[mid-1]不等于 value，那也说明 a[mid]就是我们要找的第一个值等于给定值的元素。</p><p>如果经过检查之后发现 a[mid]前面的一个元素 a[mid-1]也等于 value，那说明此时的 a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 high&#x3D;mid-1，因为要找的元素肯定出现在[low, mid-1]之间。</p><p>对比上面的两段代码，是不是下面那种更好理解？实际上，<strong>很多人都觉得变形的二分查找很难写，主要原因是太追求第一种那样完美、简洁的写法</strong>。而对于我们做工程开发的人来说，代码易读懂、没 Bug，其实更重要，所以我觉得第二种写法更好。</p><h2 id="变体二：查找最后一个值等于给定值的元素"><a href="#变体二：查找最后一个值等于给定值的元素" class="headerlink" title="变体二：查找最后一个值等于给定值的元素"></a>变体二：查找最后一个值等于给定值的元素</h2><p>前面的问题是查找第一个值等于给定值的元素，我现在把问题稍微改一下，查找最后一个值等于给定值的元素，又该如何做呢？</p><p>如果你掌握了前面的写法，那这个问题你应该很轻松就能解决。你可以先试着实现一下，然后跟我写的对比一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是重点看第 11 行代码。如果 a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid]的后一个元素 a[mid+1]不等于 value，那也说明 a[mid]就是我们要找的最后一个值等于给定值的元素。</p><p>如果我们经过检查之后，发现 a[mid]后面的一个元素 a[mid+1]也等于 value，那说明当前的这个 a[mid]并不是最后一个值等于给定值的元素。我们就更新 low&#x3D;mid+1，因为要找的元素肯定出现在[mid+1, high]之间。</p><h2 id="变体三：查找第一个大于等于给定值的元素"><a href="#变体三：查找第一个大于等于给定值的元素" class="headerlink" title="变体三：查找第一个大于等于给定值的元素"></a>变体三：查找第一个大于等于给定值的元素</h2><p>现在我们再来看另外一类变形问题。在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。</p><p>实际上，实现的思路跟前面的那两种变形问题的实现思路类似，代码写起来甚至更简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] &lt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 a[mid]小于要查找的值 value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新 low&#x3D;mid+1。</p><p>对于 a[mid]大于等于给定值 value 的情况，我们要先看下这个 a[mid]是不是我们要找的第一个值大于等于给定值的元素。如果 a[mid]前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid]就是我们要找的元素。这段逻辑对应的代码是第 7 行。</p><p>如果 a[mid-1]也大于等于要查找的值 value，那说明要查找的元素在[low, mid-1]之间，所以，我们将 high 更新为 mid-1。</p><h2 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h2><p>现在，我们来看最后一种二分查找的变形问题，查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6。是不是有点类似上面那一种？实际上，实现思路也是一样的。</p><p>有了前面的基础，你完全可以自己写出来了，所以我就不详细分析了。我把代码贴出来，你可以写完之后对比一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bsearch7</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] &gt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>好了，现在我们回头来看开篇的问题：如何快速定位出一个 IP 地址的归属地？</p><p>现在这个问题应该很简单了。如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</p><p>然后，这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。</p><p>当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</p><blockquote><p>假设 我们将区间对象有序的存入一个数组 arr [ (0-2),(3-5),(6-11) ,(12-15) ] ; 我们现在只关注IP区间对象的最小值 [ (0),(3),(6) ,(12) ] ; 那么，值 num 所在区间的下标k， 一定满足 arr[k]&lt;&#x3D; num 且 arr[k+1] &gt; num ； 换句话说 也就是 求最后一个小于或等于num的元素下标了。</p></blockquote><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>上一节我说过，凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？</p><p>实际上，上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如今天讲的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了。</p><p>变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生 Bug，这些容易出错的细节有：<strong>终止条件、区间上下界更新方法、返回值选择</strong>。所以今天的内容你最好能用自己实现一遍，对锻炼编码能力、逻辑思维、写出 Bug free 代码，会很有帮助。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们今天讲的都是非常规的二分查找问题，今天的思考题也是一个非常规的二分查找问题。如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</p><blockquote><p>有三种方法查找循环有序数组</p><p> 一、</p><ol><li>找到分界下标，分成两个有序数组</li><li>判断目标值在哪个有序数据范围内，做二分查找</li></ol><p> 二、</p><ol><li>找到最大值的下标 x;</li><li>所有元素下标 +x 偏移，超过数组范围值的取模;</li><li>利用偏移后的下标做二分查找；</li><li>如果找到目标下标，再作 -x 偏移，就是目标值实际下标。</li></ol><p> 两种情况最高时耗都在查找分界点上，所以时间复杂度是 O(N）。</p><p> 复杂度有点高，能否优化呢？</p><p> 三、<br>我们发现循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。</p><p> 如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组；<br> 如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；<br> 如果目标元素在有序数组范围中，使用二分查找；<br> 如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。</p><p> 时间复杂度为 O(logN)。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;16-二分查找（下）：如何快速定位IP对应的省份地址？&quot;&gt;&lt;a href=&quot;#16-二分查找（下）：如何快速定位IP对应的省份地址？&quot; class=&quot;headerlink&quot; title=&quot;16 | 二分查找（下）：如何快速定位IP对应的省份地址？&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>15讲 | 二分查找（上）</title>
    <link href="https://blog.elfred.top/posts/65beee21.html"/>
    <id>https://blog.elfred.top/posts/65beee21.html</id>
    <published>2021-05-05T23:57:00.000Z</published>
    <updated>2025-03-08T14:46:55.130Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="15-二分查找（上）：如何用最省内存的方式实现快速查找功能？"><a href="#15-二分查找（上）：如何用最省内存的方式实现快速查找功能？" class="headerlink" title="15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？"></a>15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？</h1><h2 id="无处不在的二分思想"><a href="#无处不在的二分思想" class="headerlink" title="无处不在的二分思想"></a>无处不在的二分思想</h2><p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0</strong>。</p><h2 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h2><p><strong>最简单的情况</strong>就是有序数组中<strong>不存在重复元素</strong>，我们在其中用二分查找值等于给定值的数据。我用 Java 代码实现了一个最简单的二分查找算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码我稍微解释一下，low、high、mid 都是指数组下标，其中 low 和 high 表示当前查找的区间范围，初始 low&#x3D;0， high&#x3D;n-1。mid 表示[low, high]的中间位置。我们通过对比 a[mid]与 value 的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为 0，就退出。如果你有一些编程基础，看懂这些应该不成问题。现在，我就着重强调一下<strong>容易出错的 3 个地方</strong>。</p><p><strong>1.循环退出条件</strong></p><p>注意是 low&lt;&#x3D;high，而不是 low&lt;high。</p><p><strong>2.mid 的取值</strong></p><p>实际上，mid&#x3D;(low+high)&#x2F;2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)&#x2F;2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为相比除法运算来说，计算机处理位运算要快得多。</p><p><strong>3.low 和 high 的更新</strong></p><p>low&#x3D;mid+1，high&#x3D;mid-1。注意这里的 +1 和 -1，如果直接写成 low&#x3D;mid 或者 high&#x3D;mid，就可能会发生死循环。比如，当 high&#x3D;3，low&#x3D;3 时，如果 a[3]不等于 value，就会导致一直循环不退出。</p><p>如果你留意我刚讲的这三点，我想一个简单的二分查找你已经可以实现了。<strong>实际上，二分查找除了用循环来实现，还可以用递归来实现</strong>，过程也非常简单。</p><p>我用 Java 语言实现了一下这个过程，正好你可以借此机会回顾一下写递归代码的技巧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bsearchInternally</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, low, mid-<span class="number">1</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h2><p>前面我们分析过，二分查找的时间复杂度是 O(logn)，查找数据的效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很大局限性的。那什么情况下适合用二分查找，什么情况下不适合呢？</p><p><strong>首先，二分查找依赖的是顺序表结构，简单点说就是数组</strong>。</p><p>那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。我们在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p><p>二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。</p><p><strong>其次，二分查找针对的是有序数据。</strong></p><p>二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。前面章节里我们讲到，排序的时间复杂度最低是 O(nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p><p>但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p><p>所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢？别急，等到二叉树那一节我会详细讲。</p><p><strong>再次，数据量太小不适合二分查找。</strong></p><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。</p><p>不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p><p><strong>最后，数据量太大也不适合二分查找。</strong></p><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><p>注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们学习了一种针对有序数据的高效查找算法，二分查找，它的时间复杂度是 O(logn)。</p><p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。</p><p>二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol><li><p>如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sqrt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sqrt</span> <span class="variable">sqrt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sqrt</span>();</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> sqrt.sqrt(a, <span class="number">0.000001</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;算法结果：&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;实际结果：&quot;</span> + Math.sqrt(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> precision)</span> &#123;</span><br><span class="line">        <span class="type">double</span> low, high, mid, tmp;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            low = <span class="number">1</span>;</span><br><span class="line">            high = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = a;</span><br><span class="line">            high = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2.000</span>;</span><br><span class="line">            tmp = mid * mid;</span><br><span class="line">            <span class="comment">// 如果当前求得的平方根在target+0.000001和target-0.000001之间，那么返回mid</span></span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; a + precision &amp;&amp; tmp &gt;= a - precision) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; a) &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我刚才说了，如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？如果你自己推导一下，你就会深刻地认识到，为何我们会选择用数组而不是链表来实现二分查找了。</p><blockquote><p>假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):<br>第一次查找中间点，需要移动指针n&#x2F;2次；<br>第二次，需要移动指针n&#x2F;4次；<br>第三次需要移动指针n&#x2F;8次；<br>……<br>以此类推，一直到1次为值</p><p>总共指针移动次数(查找次数) &#x3D; n&#x2F;2 + n&#x2F;4 + n&#x2F;8 + …+ 1，这显然是个等比数列，根据等比数列求和公式：Sum &#x3D; n - 1.</p><p>最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同</p><p>但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;15-二分查找（上）：如何用最省内存的方式实现快速查找功能？&quot;&gt;&lt;a href=&quot;#15-二分查找（上）：如何用最省内存的方式实现快速查找功能？&quot; class=&quot;headerlink&quot; title=&quot;15 | 二分查找（上）：如何用最省内存的方式实现快速</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>20讲</title>
    <link href="https://blog.elfred.top/posts/5ff22685.html"/>
    <id>https://blog.elfred.top/posts/5ff22685.html</id>
    <published>2021-05-05T05:20:00.000Z</published>
    <updated>2025-03-08T14:46:55.129Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="20-幻读是什么，幻读有什么问题？"><a href="#20-幻读是什么，幻读有什么问题？" class="headerlink" title="20 | 幻读是什么，幻读有什么问题？"></a>20 | 幻读是什么，幻读有什么问题？</h1><p>为了便于说明问题，这一篇文章，我们就先使用一个小一点儿的表。建表和初始化语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><h2 id="幻读是什么？"><a href="#幻读是什么？" class="headerlink" title="幻读是什么？"></a>幻读是什么？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;20-幻读是什么，幻读有什么问题？&quot;&gt;&lt;a href=&quot;#20-幻读是什么，幻读有什么问题？&quot; class=&quot;headerlink&quot; title=&quot;20 | 幻读是什么，幻读有什么问题？&quot;&gt;&lt;/a&gt;20 | 幻读是什么，幻读有什么问题？&lt;/h1&gt;&lt;p&gt;为</summary>
      
    
    
    
    
    <category term="MySQL实战45讲" scheme="https://blog.elfred.top/tags/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>02讲</title>
    <link href="https://blog.elfred.top/posts/8f3bbd6e.html"/>
    <id>https://blog.elfred.top/posts/8f3bbd6e.html</id>
    <published>2021-05-05T05:20:00.000Z</published>
    <updated>2025-03-08T14:46:55.124Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="21-为什么我只改一行的语句，锁这么多？"><a href="#21-为什么我只改一行的语句，锁这么多？" class="headerlink" title="21 | 为什么我只改一行的语句，锁这么多？"></a>21 | 为什么我只改一行的语句，锁这么多？</h1><h2 id="间隙锁和next-lock-key加锁原则"><a href="#间隙锁和next-lock-key加锁原则" class="headerlink" title="间隙锁和next-lock key加锁原则"></a>间隙锁和next-lock key加锁原则</h2><p>因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是可重复读隔离级别。</p><p><strong>我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p><ol><li>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</li><li>原则 2：查找过程中访问到的对象才会加锁。</li><li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li><li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li><li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;21-为什么我只改一行的语句，锁这么多？&quot;&gt;&lt;a href=&quot;#21-为什么我只改一行的语句，锁这么多？&quot; class=&quot;headerlink&quot; title=&quot;21 | 为什么我只改一行的语句，锁这么多？&quot;&gt;&lt;/a&gt;21 | 为什么我只改一行的语句，锁这</summary>
      
    
    
    
    
    <category term="MySQL实战45讲" scheme="https://blog.elfred.top/tags/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>12讲 | 归并排序 &amp; 快速排序，查找第K大元素</title>
    <link href="https://blog.elfred.top/posts/93213c3f.html"/>
    <id>https://blog.elfred.top/posts/93213c3f.html</id>
    <published>2021-05-04T09:20:00.000Z</published>
    <updated>2025-03-08T14:46:55.130Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="12-排序（下）：如何用快排思想在O-n-内查找第K大元素？"><a href="#12-排序（下）：如何用快排思想在O-n-内查找第K大元素？" class="headerlink" title="12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？"></a>12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？</h1><h2 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h2><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210504154821.jpeg" alt="img"></p><p>归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>，这两者并不冲突。分治算法的思想我后面会有专门的一节来讲，现在不展开讨论，我们今天的重点还是排序算法。</p><p>前面我通过举例让你对归并有了一个感性的认识，又告诉你，归并排序用的是分治思想，可以用递归来实现。我们现在就来看看<strong>如何用递归代码来实现归并排序</strong>。</p><p>我在第10 节讲的递归代码的编写技巧你还记得吗？写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure><p>我来解释一下这个递推公式。</p><p>merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)&#x2F;2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。</p><p>有了递推公式，转化成代码就简单多了。为了阅读方便，我这里只给出伪代码，你可以翻译成你熟悉的编程语言。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法, A是数组，n表示数组大小</span></span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="comment">// 递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> p &gt;= r  then <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取p到r之间的中间位置q</span></span><br><span class="line">  q = (p+r) / <span class="number">2</span></span><br><span class="line">  <span class="comment">// 分治递归</span></span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">  <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">  merge(A[p...r], A[p...q], A[q+<span class="number">1.</span>..r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能已经发现了，merge(A[p…r], A[p…q], A[q+1…r]) 这个函数的作用就是，将已经有序的 A[p…q]和 A[q+1….r]合并成一个有序的数组，并且放入 A[p….r]。那这个过程具体该如何做呢？</p><p>如图所示，我们申请一个临时数组 tmp，大小与 A[p…r]相同。我们用两个游标 i 和 j，分别指向 A[p…q]和 A[q+1…r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;&#x3D;A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。</p><p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r]中。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210504155216.jpeg" alt="img"></p><p>我们把 merge() 函数写成伪代码，就是下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">merge(A[p...r], A[p...q], A[q+<span class="number">1.</span>..r]) &#123;</span><br><span class="line">  <span class="keyword">var</span> i := p，j := q+<span class="number">1</span>，k := <span class="number">0</span> <span class="comment">// 初始化变量i, j, k</span></span><br><span class="line">  <span class="keyword">var</span> tmp := <span class="built_in">new</span> array[<span class="number">0.</span>..r-p] <span class="comment">// 申请一个大小跟A[p...r]一样的临时数组</span></span><br><span class="line">  while i&lt;=q AND j&lt;=r do &#123;</span><br><span class="line">    <span class="keyword">if</span> A[i] &lt;= A[j] &#123;</span><br><span class="line">      tmp[k++] = A[i++] <span class="comment">// i++等于i:=i+1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[k++] = A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">  <span class="keyword">var</span> start := i，end := q</span><br><span class="line">  <span class="keyword">if</span> j&lt;=r then start := j, end:=r</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">  while start &lt;= end do &#123;</span><br><span class="line">    tmp[k++] = A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将tmp中的数组拷贝回A[p...r]</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span> to r-p do &#123;</span><br><span class="line">    A[p+i] = tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h2><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p><p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210427195633.jpeg" alt="img"></p><p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p><p>如果我们用递推公式来将上面的过程写出来的话，就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure><p>我将递推公式转化成递归代码。跟归并排序一样，我还是用伪代码来实现，你可以翻译成你熟悉的任何语言。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序，A是数组，n表示数组的大小</span></span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) <span class="comment">// 获取分区点</span></span><br><span class="line">  quick_sort_c(A, p, q<span class="number">-1</span>)</span><br><span class="line">  quick_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序中有一个 merge() 合并函数，我们这里有一个 partition() 分区函数。partition() 分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r]分区，函数返回 pivot 的下标。</p><p>如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p….r]。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210427200346.jpeg" alt="img"></p><p>但是，如果按照这种思路实现的话，partition() 函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果我们希望快排是原地排序算法，那它的空间复杂度得是 O(1)，那 partition() 分区函数就不能占用太多额外的内存空间，我们就需要在 A[p…r]的原地完成分区操作。</p><p>原地分区函数的实现思路非常巧妙，我写成了伪代码，我们一起来看一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot := A[r]</span><br><span class="line">  i := p</span><br><span class="line">  <span class="keyword">for</span> j := p to r<span class="number">-1</span> do &#123;</span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i := i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>这里的处理有点类似选择排序。我们通过游标 i 把 A[p…r-1]分成两部分。A[p…i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i…r-1]是“未处理区间”。我们每次都从未处理的区间 A[i…r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。</p><p>数组的插入操作还记得吗？在数组某个位置插入元素，需要搬移数据，非常耗时。当时我们也讲了一种处理技巧，就是交换，在 O(1) 的时间复杂度内完成插入操作。这里我们也借助这个思想，只需要将 A[i]与 A[j]交换，就可以在 O(1) 时间复杂度内将 A[j]放到下标为 i 的位置。</p><p>文字不如图直观，所以我画了一张图来展示分区的整个过程。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210427201802.jpeg" alt="img"></p><p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p><p>到此，快速排序的原理你应该也掌握了。现在，我再来看另外一个问题：快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210427201947.jpeg" alt="img"></p><p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下的</strong>，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开篇的问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。</p><p>我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p><p>如果 p+1&#x3D;K，那 A[p]就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1]区间查找。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210504155824.jpeg" alt="img"></p><p>我们再来看，为什么上述解决思路的时间复杂度是 O(n)？</p><p>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n&#x2F;2 的数组执行分区操作，需要遍历 n&#x2F;2 个元素。依次类推，分区遍历元素的个数分别为、n&#x2F;2、n&#x2F;4、n&#x2F;8、n&#x2F;16.……直到区间缩小为 1。</p><p>如果我们把每次分区遍历的元素个数加起来，就是：n+n&#x2F;2+n&#x2F;4+n&#x2F;8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？</p><blockquote><p>归并思路： </p><p>1.每个文件从最小值记录开始维护一个游标，标志当前文件遍历的记录位置。 </p><p>2.维护一个10空间大小的小顶堆，将每个文件的游标记录压入，顶端的就是最小值。 </p><p>3.将堆顶数据取出，写入新的文件。 </p><p>4.将取出的记录对应的文件游标向前拨动，取出对应的记录（就是下一个记录），压入小顶堆。没有记录说明改文件遍历完毕。 </p><p>5.重复操作3。 （这里的小顶堆作用就是快速取出最小的那个值，考虑到堆结构的代码实现难度，这个地方用简单的有序列表，新的数据有序插入，取出最小的也很ok，10条记录随便搞，慢不到哪里，优化也快不到哪里，简单就好） </p><p>这个简单思路占用空间很小，就是10条数据的小顶堆。但题目给出的是，1G内存，有很大的优化空间，优化点在磁盘IO，优化方式就是批量读文件，批量写文件。 1.批量读，每个文件读取50M到内存，总计500M。上面的游标就对应到内存游标，只是游标到底之后，需要读取对应文件下一个50M数据 2.批量写，上面的写文件，优化为写内存，给予500M的内存空间，写满后再一次刷入新的文件。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;12-排序（下）：如何用快排思想在O-n-内查找第K大元素？&quot;&gt;&lt;a href=&quot;#12-排序（下）：如何用快排思想在O-n-内查找第K大元素？&quot; class=&quot;headerlink&quot; title=&quot;12 | 排序（下）：如何用快排思想在O(n)内查找第</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>第八周</title>
    <link href="https://blog.elfred.top/posts/7f2c1a48.html"/>
    <id>https://blog.elfred.top/posts/7f2c1a48.html</id>
    <published>2021-05-01T07:06:00.000Z</published>
    <updated>2025-03-08T14:46:55.134Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.04.26-2021.05.02</p><h3 id="面试题-16-25-LRU-缓存"><a href="#面试题-16-25-LRU-缓存" class="headerlink" title="面试题 16.25. LRU 缓存"></a><a href="https://leetcode-cn.com/problems/lru-cache-lcci/">面试题 16.25. LRU 缓存</a></h3><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p><p>它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p><p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // 返回  1</span><br><span class="line">cache.put(3, 3);    // 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       // 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    // 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       // 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       // 返回  3</span><br><span class="line">cache.get(4);       // 返回  4</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用hashmap使得查询间复杂度为O(1)，否则链表时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 该节点不存在</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 容量满了</span></span><br><span class="line">            <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> removeLast();</span><br><span class="line">                cache.remove(last.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            cache.put(key, node);</span><br><span class="line">            size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="comment">// 节点已存在</span></span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        remove(last);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        remove(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        next.prev = node;</span><br><span class="line"></span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> node.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉树: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210501154050.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p>注意：本题与主站 236 题相同：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.04.26-2021.05.02&lt;/p&gt;
&lt;h3 id=&quot;面试题-16-25-LRU-缓存&quot;&gt;&lt;a href=&quot;#面试题-16-25-LRU-缓存&quot; class=&quot;headerlink&quot; title=&quot;面试题 16.25. L</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见面试题</title>
    <link href="https://blog.elfred.top/posts/e27205e0.html"/>
    <id>https://blog.elfred.top/posts/e27205e0.html</id>
    <published>2021-04-27T08:42:00.000Z</published>
    <updated>2025-03-08T14:46:55.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库优化："><a href="#数据库优化：" class="headerlink" title="数据库优化："></a>数据库优化：</h2><h3 id="索引失效的场景："><a href="#索引失效的场景：" class="headerlink" title="索引失效的场景："></a>索引失效的场景：</h3><ol><li>like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。</li><li>or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效。</li><li>组合索引，不是使用第一列索引，索引失效。</li><li>数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。</li><li>在索引列上使用 IS NULL 或 IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引，可以用其他的办法处理，例如：数字类型，判断大于0，字符串类型设置一个默认值，判断是否等于默认值即可。</li><li>在索引字段上使用not，&lt;&gt;，!&#x3D;。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</li><li>对索引字段进行计算操作。</li><li>在索引字段上使用函数。</li><li>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</li></ol><p>索引失效分析工具：</p><p>可以使用explain命令加在要分析的sql语句前面，在执行结果中查看key这一列的值，如果为NULL，说明没有使用索引。</p><h3 id="索引使用注意事项"><a href="#索引使用注意事项" class="headerlink" title="索引使用注意事项"></a>索引使用注意事项</h3><ol><li>不要滥用索引<ul><li>索引提高查询速度，却会降低更新表的速度，因为更新表时，mysql不仅要更新数据，保存数据，还要更新索引，保存索引</li><li>索引会占用磁盘空间</li></ul></li><li>索引不会包含含有NULL值的列    ，复合索引只要有一列含有NULL值，那么这一列对于此符合索引就是无效的，因此我们在设计数据库设计时不要让字段的默认值为NULL。 </li><li>MySQL查询只是用一个索引，如果where字句中使用了索引的话，那么order by中的列是不会使用索引的 </li><li>like：like ‘%aaa%’不会使用索引而like “aaa%”可以使用索引</li></ol><h3 id="联合索引最左匹配原则"><a href="#联合索引最左匹配原则" class="headerlink" title="联合索引最左匹配原则"></a>联合索引最左匹配原则</h3><ol><li>是不是用索引，和查询条件的顺序无关（优化器会自动调整条件的顺序），但和这些字段的查询手段有关</li><li>建立了abc的联合索引，相当于建立了 a的单列索引，ab的联合索引，以及abc的联合索引</li><li>一般根据最左匹配的原则，但在遇到范围查询后，匹配终止，也就是说，当条件为：<br>a like ‘%str%’、a like ‘%str’ 时，不走索引；当条件为 a like ‘str%’ 或者 “&gt;”, “&lt;”, “between”时， 仅使用了<strong>联合索引中a的部分</strong>；<br>b，c 同理，根据查询方式不同，即便条件中的3个字段都在索引里，也不一定使用了全索引<br>假如条件是  a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 这类情况，是必然走这个联合索引了</li></ol><h3 id="我们的数据库当中如何做的优化"><a href="#我们的数据库当中如何做的优化" class="headerlink" title="我们的数据库当中如何做的优化?"></a>我们的数据库当中如何做的优化?</h3><ul><li>对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在 where 子句中使用 !&#x3D; 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描</li><li>in 和 not in 也要慎用，否则会导致全表扫描（当数据库人为IN和NotIn使用索引查询的效率不如全表扫描时会放弃使用索引转而使用权标扫描）</li><li>like模糊全匹配也将导致全表扫描</li></ul><h3 id="回表查询和索引覆盖是什么？"><a href="#回表查询和索引覆盖是什么？" class="headerlink" title="回表查询和索引覆盖是什么？"></a>回表查询和索引覆盖是什么？</h3><p>概念：</p><ul><li>回表查询：先定位主键值，再定位行记录，它的性能较扫一遍索引树更低</li><li>索引覆盖：在一棵索引树上就能获取SQL所需的所有列数据，无需回表，即实现了索引覆盖</li></ul><p>如何实现索引覆盖：</p><ul><li>主键索引存储的是主键值和行记录（即聚簇索引），无需回表查询</li><li>普通索引存储的是索引和rowid的值，查询其他字段（非rowid字段和其他字段）需要回表查询，建立联合索引实现索引覆盖可以解决这个问题</li></ul><p>结合下面的实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 有一张表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `a` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"># 这几条语句有什么区别</span><br><span class="line"></span><br><span class="line"># 没有区别，没有回表查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> a <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 第一句会出现回表查询，其余都直接可以查到数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">from</span> test <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> a <span class="keyword">from</span> test <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 没有索引，都是全表查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">from</span> test <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> a <span class="keyword">from</span> test <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Select-from-table-where-a-‘1’-and-b-‘2’-and-c-’3’-索引-a-b-c-是否走索引"><a href="#Select-from-table-where-a-‘1’-and-b-‘2’-and-c-’3’-索引-a-b-c-是否走索引" class="headerlink" title="Select * from table where a &#x3D; ‘1’ and b &gt; ‘2’ and c&#x3D;’3’ 索引(a,b,c)是否走索引"></a>Select * from table where a &#x3D; ‘1’ and b &gt; ‘2’ and c&#x3D;’3’ 索引(a,b,c)是否走索引</h3><p>在a、b走完索引后，c肯定是无序了，所以c就没法走索引，数据库会觉得还不如全表扫描c字段来的快（扫描全部满足a&#x3D;1和b&gt;2的纪录）</p><p> 始终记得，在数据库中是先按照a排序，后按照b排序，最后按照c排序。 首先索引找a，找到后在a相等的条件下，b必然是有序的。因为先按照a排序，若a相同，按照b排序，因此a相等的条件下，b必然有序。 好，我们继续。当找到所有b&gt;2的之后，c还有序么？不，c不有序。因为（b,c）的组合可以是（100000,1），也可以是（1，100）。发现了么，当你根据b找到区间之后，c是无序的，因为b和c之间没有关系。你不能保证所有大于2的b的那些记录中，c还是有序的。</p><h3 id="现在一张表table，有a-b-c三个索引，select-from-table-where-a-1-and-b-2-order-by-c，这些字段是否都能使用索引？如果不能怎么优化"><a href="#现在一张表table，有a-b-c三个索引，select-from-table-where-a-1-and-b-2-order-by-c，这些字段是否都能使用索引？如果不能怎么优化" class="headerlink" title="现在一张表table，有a,b,c三个索引，select * from table where a &#x3D; 1 and b &#x3D; 2 order by c，这些字段是否都能使用索引？如果不能怎么优化"></a>现在一张表table，有a,b,c三个索引，select * from table where a &#x3D; 1 and b &#x3D; 2 order by c，这些字段是否都能使用索引？如果不能怎么优化</h3><p><a href="https://blog.csdn.net/gb4215287/article/details/78037835">https://blog.csdn.net/gb4215287/article/details/78037835</a><br>与其说是数据库只支持一条查询语句只使用一个索引，倒不如说N条独立索引同时在一条语句使用的消耗比只使用一个索引还要慢。<br>所以如上条的情况，最佳推荐是使用index(column1,column2,column3） 这种联合索引，此联合索引可以把b+tree结构的优势发挥得淋漓尽致：<br>一条主二叉树（column&#x3D;1），查询到column&#x3D;1节点后基于当前节点进行二级二叉树column2&#x3D;foo的查询，在二级二叉树查询到column2&#x3D;foo后，去三级二叉树column3&#x3D;bar查找。</p><h2 id="索引底层数据结构："><a href="#索引底层数据结构：" class="headerlink" title="索引底层数据结构："></a>索引底层数据结构：</h2><h3 id="MySql中InnoDB表为什么要建议用自增列做主键"><a href="#MySql中InnoDB表为什么要建议用自增列做主键" class="headerlink" title="MySql中InnoDB表为什么要建议用自增列做主键"></a>MySql中InnoDB表为什么要建议用自增列做主键</h3><p><a href="https://blog.csdn.net/bigtree_3721/article/details/73151028">https://blog.csdn.net/bigtree_3721/article/details/73151028</a></p><p>InnoDB引擎表的特点：</p><ol><li>InnoDB引擎表是基于B+树的索引组织表(IOT)</li></ol><p>关于B+树<br><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210427162633.jpeg" alt="img"><br>B+ 树的特点:</p><p>（1）所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的;</p><p>（2）不可能在非叶子结点命中;</p><p>（3）非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层;</p><ol start="2"><li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li><li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</li><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li><li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li></ol><p>综上总结，如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的，也就是下面这几种情况的存取效率最高：</p><ol><li>使用自增列(INT&#x2F;BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致；</li><li>该表不指定自增列做主键，同时也没有可以被选为主键的唯一索引(上面的条件)，这时候InnoDB会选择内置的ROWID作为主键，写入顺序和ROWID增长顺序一致；<br>除此以外，如果一个InnoDB表又没有显示主键，又有可以被选择为主键的唯一索引，但该唯一索引可能不是递增关系时(例如字符串、UUID、多字段联合唯一索引的情况)，该表的存取效率就会比较差。</li></ol><h3 id="MySql为什么使用B-Tree作为索引而不是其他二叉查找树（比如红黑树等）？"><a href="#MySql为什么使用B-Tree作为索引而不是其他二叉查找树（比如红黑树等）？" class="headerlink" title="MySql为什么使用B-Tree作为索引而不是其他二叉查找树（比如红黑树等）？"></a>MySql为什么使用B-Tree作为索引而不是其他二叉查找树（比如红黑树等）？</h3><p><a href="https://www.cnblogs.com/aspirant/p/9214485.html">https://www.cnblogs.com/aspirant/p/9214485.html</a><br>平衡二叉树不适合作为索引。那么什么才适合作为索引——B树。</p><p>平衡二叉树没能充分利用磁盘预读功能，而B树是为了充分利用磁盘预读功能来而创建的一种数据结构，也就是说B树就是为了作为索引才被发明出来的的。</p><p>来看看关于“局部性原理与磁盘预读”的知识： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">局部性原理与磁盘预读：</span><br><span class="line"></span><br><span class="line">由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： </span><br><span class="line">当一个数据被用到时，其附近的数据也通常会马上被使用。 </span><br><span class="line">程序运行期间所需要的数据通常比较集中。 </span><br><span class="line">由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</span><br></pre></td></tr></table></figure><p>搞清楚上面的意思。磁盘预读是具体实现，其理论依据是局部性原理。</p><p>为什么说红黑树没能充分利用磁盘预读功能，引用一篇博文的一段话： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</span><br></pre></td></tr></table></figure><p>也就是说，使用红黑树（平衡二叉树）结构的话，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。</p><p>B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</p><p>B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中。因此，虽然B树查询查询的次数不比平衡二叉树的次数少，但是相比起磁盘IO速度，内存中比较的耗时就可以忽略不计了。因此，B树更适合作为索引。</p><h3 id="为什么用B-Tree作为索引而不是B-Tree"><a href="#为什么用B-Tree作为索引而不是B-Tree" class="headerlink" title="为什么用B+-Tree作为索引而不是B-Tree"></a>为什么用B+-Tree作为索引而不是B-Tree</h3><p>比B树更适合作为索引的结构是B+树。MySQL中也是使用B+树作为索引。它是B树的变种，因此是基于B树来改进的。为什么B+树会比B树更加优秀呢？</p><p>B树：有序数组+平衡多叉树；<br>B+树：有序数组链表+平衡多叉树；</p><p>B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高区间访问的性能。而正是这个特性决定了B+树更适合用来存储外部数据。</p><p>引用一段话： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">走进搜索引擎的作者梁斌老师针对B树、B+树给出了他的意见（为了真实性，特引用其原话，未作任何改动）： “B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。 </span><br><span class="line">比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。 </span><br><span class="line">B树比如你的例子中查，17的话，一把就得到结果了， </span><br><span class="line">有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。 </span><br><span class="line">另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。”</span><br></pre></td></tr></table></figure><p>举个例子来对比。<br>B树： </p><p>比如说，我们要查找关键字范围在3到7的关键字，在找到第一个符合条件的数字3后，访问完第一个关键字所在的块后，得遍历这个B树，获取下一个块，直到遇到一个不符合条件的关键字。遍历的过程是比较复杂的。</p><p>B+树(叶节点保存数据，其他的节点 全部存放索引)： </p><p>相比之下，B+树的基于范围的查询简洁很多。由于叶子节点有指向下一个叶子节点的指针，因此从块1到块2的访问，通过块1指向块2的指针即可。从块2到块3也是通过一个指针即可。</p><p>引用一篇博文中网友评论的一段话： </p><p>数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。<br>B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。<br>正如上面所说，在数据库中基于范围的查询是非常频繁的，因此MySQL最终选择的索引结构是B+树而不是B树。 </p><h3 id="B-树和-B-树在构造和查询性能上有什么差异呢？"><a href="#B-树和-B-树在构造和查询性能上有什么差异呢？" class="headerlink" title="B+ 树和 B 树在构造和查询性能上有什么差异呢？"></a>B+ 树和 B 树在构造和查询性能上有什么差异呢？</h3><p>B+ 树的中间节点并不直接存储数据。</p><ol><li>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li><li>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</li><li>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</li></ol><h3 id="数据库索引，为什么不适用用二叉树："><a href="#数据库索引，为什么不适用用二叉树：" class="headerlink" title="数据库索引，为什么不适用用二叉树："></a>数据库索引，为什么不适用用二叉树：</h3><ol><li>平衡二叉树必须满足（所有节点的左右子树高度差不超过1）。执行插入还是删除操作，只要不满足上述条件，就要通过旋转来保持平衡，而旋转是非常耗时的，所以AVL树适合用于查找多的情况。</li><li>二叉树的数据结构，会导致“深度”，比较深，这种“瘦高”的特性，加大了平均查询的磁盘IO次数，随着数据量的增多，查询效率也会受到影响；</li></ol><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h3 id="MySql悲观锁和乐观锁如何实现"><a href="#MySql悲观锁和乐观锁如何实现" class="headerlink" title="MySql悲观锁和乐观锁如何实现"></a>MySql悲观锁和乐观锁如何实现</h3><ul><li><p>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，<strong>乐观锁和悲观锁是并发控制主要采用的技术手段。</strong></p><ul><li><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p></li><li><ul><li><strong>在查询完数据的时候就把事务锁起来，直到提交事务</strong></li><li>实现方式：使用数据库中的锁机制</li></ul></li><li><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p></li><li><ul><li><strong>在修改数据的时候把事务锁起来，通过version的方式来进行锁定</strong></li><li>实现方式：使用version版本或者时间戳</li></ul></li></ul><p>悲观锁：缺点性能低</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> eb_sku <span class="keyword">where</span> sku_id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">update</span> eb_sku <span class="keyword">set</span> stock <span class="operator">=</span> <span class="number">100</span><span class="operator">-</span> $&#123;quantity&#125; <span class="keyword">where</span> sku_id <span class="operator">=</span> <span class="number">10001</span></span><br></pre></td></tr></table></figure><p>乐观锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> eb_sku <span class="keyword">set</span> stock <span class="operator">=</span> <span class="number">100</span><span class="operator">-</span>$&#123;quantity&#125;, version <span class="operator">=</span> $&#123;version&#125;<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> sku_id <span class="operator">=</span> $&#123;sku_id&#125; <span class="keyword">and</span> version<span class="operator">=</span>$&#123;version&#125; <span class="keyword">and</span> stock <span class="operator">&gt;</span> $&#123;quantity&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="行锁、表锁"><a href="#行锁、表锁" class="headerlink" title="行锁、表锁"></a>行锁、表锁</h3><h3 id="间隙锁、临键锁"><a href="#间隙锁、临键锁" class="headerlink" title="间隙锁、临键锁"></a>间隙锁、临键锁</h3><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h3><h3 id="按照什么逻辑分库分表"><a href="#按照什么逻辑分库分表" class="headerlink" title="按照什么逻辑分库分表"></a>按照什么逻辑分库分表</h3><h3 id="分库分表如何扩容"><a href="#分库分表如何扩容" class="headerlink" title="分库分表如何扩容"></a>分库分表如何扩容</h3><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="Mysql中utf-8和utf8mb4的区别与使用场景"><a href="#Mysql中utf-8和utf8mb4的区别与使用场景" class="headerlink" title="Mysql中utf-8和utf8mb4的区别与使用场景"></a>Mysql中utf-8和utf8mb4的区别与使用场景</h3><p>MySQL中的<strong>utf8</strong>编码只支持最大3字节每字符，<strong>utf8mb4</strong>才是 真正意义上的“UTF-8”，utf8mb4支持4字节每字符，支持存储emoji，而utf8不支持。</p><h3 id="MySql-Innodb引擎和MyIASM引擎的区别"><a href="#MySql-Innodb引擎和MyIASM引擎的区别" class="headerlink" title="MySql Innodb引擎和MyIASM引擎的区别"></a>MySql Innodb引擎和MyIASM引擎的区别</h3><h4 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h4><ul><li>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。</li><li>该引擎还提供了行级锁和外键约束</li><li>使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</li><li>它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统</li><li>MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。</li><li>该引擎不支持FULLTEXT类型的索引（不支持全文索引）。</li><li>它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。</li><li>当需要使用数据库事务时，该引擎当然是首选。</li><li>由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。</li></ul><h4 id="MyIASM引擎"><a href="#MyIASM引擎" class="headerlink" title="MyIASM引擎"></a>MyIASM引擎</h4><ul><li>但是它没有提供对数据库事务的支持，也不支持行级锁和外键，</li><li>因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。</li><li>MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。</li><li>如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</li></ul><h4 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h4><ol><li>MyIASM是非事务安全的，而InnoDB是事务安全的</li><li>MyIASM锁的粒度是表级的，而InnoDB支持行级锁</li><li>MyIASM支持全文类型索引，而InnoDB不支持全文索引</li><li>MyIASM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyIASM</li><li>MyIASM表保存成文件形式，跨平台使用更加方便</li></ol><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li>MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM</li><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</li></ol><table><thead><tr><th></th><th>MyIASM</th><th>InnoDB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>锁的粒度</td><td>Table</td><td>Row</td></tr><tr><td>存储容量</td><td>没有上限</td><td>64TB</td></tr><tr><td><strong>哈希索引</strong></td><td><strong>不支持</strong></td><td><strong>支持</strong></td></tr><tr><td><strong>全文索引</strong></td><td><strong>支持</strong></td><td><strong>不支持</strong></td></tr><tr><td><strong>外键</strong></td><td><strong>不支持</strong></td><td><strong>支持</strong></td></tr></tbody></table><h3 id="MySQL如何给大表加索引"><a href="#MySQL如何给大表加索引" class="headerlink" title="MySQL如何给大表加索引"></a>MySQL如何给大表加索引</h3><p><a href="https://segmentfault.com/a/1190000040570831">https://segmentfault.com/a/1190000040570831</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库优化：&quot;&gt;&lt;a href=&quot;#数据库优化：&quot; class=&quot;headerlink&quot; title=&quot;数据库优化：&quot;&gt;&lt;/a&gt;数据库优化：&lt;/h2&gt;&lt;h3 id=&quot;索引失效的场景：&quot;&gt;&lt;a href=&quot;#索引失效的场景：&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="MySQL" scheme="https://blog.elfred.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第七周</title>
    <link href="https://blog.elfred.top/posts/8847320b.html"/>
    <id>https://blog.elfred.top/posts/8847320b.html</id>
    <published>2021-04-24T11:21:00.000Z</published>
    <updated>2025-03-08T14:46:55.134Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.04.19-2021.04.25</p><h3 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a></h3><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给你一个输入数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,1,3,5,6,4]</span><br><span class="line">输出：1 或 5 </span><br><span class="line">解释：你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li><li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li></ul><p> <strong>进阶：</strong>你可以实现时间复杂度为 <code>O(logN)</code> 的解决方案吗？</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h3><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.04.19-2021.04.25&lt;/p&gt;
&lt;h3 id=&quot;162-寻找峰值&quot;&gt;&lt;a href=&quot;#162-寻找峰值&quot; class=&quot;headerlink&quot; title=&quot;162. 寻找峰值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>10讲</title>
    <link href="https://blog.elfred.top/posts/18525c55.html"/>
    <id>https://blog.elfred.top/posts/18525c55.html</id>
    <published>2021-04-24T11:20:00.000Z</published>
    <updated>2025-03-08T14:46:55.127Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="10-递归：如何用三行代码找到“最终推荐人”？"><a href="#10-递归：如何用三行代码找到“最终推荐人”？" class="headerlink" title="10 | 递归：如何用三行代码找到“最终推荐人”？"></a>10 | 递归：如何用三行代码找到“最终推荐人”？</h1><h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><h3 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1. 一个问题的解可以分解为几个子问题的解"></a>1. 一个问题的解可以分解为几个子问题的解</h3><p>何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。</p><h3 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2.  这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2.  这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h3><p>比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。</p><h3 id="3-存在递归终止条件"><a href="#3-存在递归终止条件" class="headerlink" title="3. 存在递归终止条件"></a>3. 存在递归终止条件</h3><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)&#x3D;1，这就是递归的终止条件。</p><h2 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h2><p>写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong>，剩下将递推公式转化为代码就很简单了。</p><p>你先记住这个理论。我举一个例子，带你一步一步实现一个递归代码，帮你理解。</p><p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p><p>我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><blockquote><p>这里其实就是斐波那契数列，或者你自己在本子上画一下就知道了，第一阶有1种走法，第二阶有2种走法，第三阶有3种走法，第四阶有5种走法，第五阶有8种走法，这个走法的规律正好符合斐波那契数列1(这个1在此例子省略了)、1、2、3、5、8、13、21….不管哪个数都是前两个数的和，那么想象每个数下面都有一个类似数组一样的下标，那么第n个数就等于第n-1位置的数加上第n-2位置的数也就是F(n) &#x3D; F(n-1) + F(n-2)</p></blockquote><p>有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以 f(1)&#x3D;1。这个递归终止条件足够吗？我们可以用 n&#x3D;2，n&#x3D;3 这样比较小的数试验一下。</p><p>n&#x3D;2 时，f(2)&#x3D;f(1)+f(0)。如果递归终止条件只有一个 f(1)&#x3D;1，那 f(2) 就无法求解了。所以除了 f(1)&#x3D;1 这一个递归终止条件外，还要有 f(0)&#x3D;1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把 f(2)&#x3D;2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。</p><p>所以，递归终止条件就是 f(1)&#x3D;1，f(2)&#x3D;2。这个时候，你可以再拿 n&#x3D;3，n&#x3D;4 来验证一下，这个终止条件是否足够并且正确。</p><p>我们把递归终止条件和刚刚得到的递推公式放到一起就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(1) = 1;</span><br><span class="line">f(2) = 2;</span><br><span class="line">f(n) = f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><p>有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我总结一下，<strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</strong>。</p><p>虽然我讲了这么多方法，但是作为初学者的你，现在是不是还是有种想不太清楚的感觉呢？实际上，我刚学递归的时候，也有这种感觉，这也是文章开头我说递归代码比较难理解的地方。</p><p>刚讲的电影院的例子，我们的递归调用只有一个分支，也就是说“一个问题只需要分解为一个子问题”，我们很容易能够想清楚“递”和“归”的每一个步骤，所以写起来、理解起来都不难。</p><p>但是，当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解了。</p><p>像我刚刚讲的第二个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。</p><p>计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。</p><p>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？</p><p>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p><p>因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p><h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>除此之外，使用递归时还会出现重复计算的问题。刚才我讲的第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210424195819.jpeg" alt="img"></p><p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p><p>按照上面的思路，我们来改造一下刚才的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？</p><blockquote><p>调试递归:<br>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;10-递归：如何用三行代码找到“最终推荐人”？&quot;&gt;&lt;a href=&quot;#10-递归：如何用三行代码找到“最终推荐人”？&quot; class=&quot;headerlink&quot; title=&quot;10 | 递归：如何用三行代码找到“最终推荐人”？&quot;&gt;&lt;/a&gt;10 | 递归：如何</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计DDD</title>
    <link href="https://blog.elfred.top/posts/e7f6134d.html"/>
    <id>https://blog.elfred.top/posts/e7f6134d.html</id>
    <published>2021-04-22T11:47:00.000Z</published>
    <updated>2025-03-08T14:46:55.124Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="什么是领域驱动设计？"><a href="#什么是领域驱动设计？" class="headerlink" title="什么是领域驱动设计？"></a>什么是领域驱动设计？</h2><h2 id="为什么要使用DDD？"><a href="#为什么要使用DDD？" class="headerlink" title="为什么要使用DDD？"></a>为什么要使用DDD？</h2><h3 id="过度耦合"><a href="#过度耦合" class="headerlink" title="过度耦合"></a>过度耦合</h3><p>业务初期，我们的功能大都非常简单，普通的CRUD就能满足，此时系统是清晰的。随着迭代的不断演化，业务逻辑变得越来越复杂，我们的系统也越来越冗杂。模块彼此关联，谁都很难说清模块的具体功能意图是啥。修改一个功能时，往往光回溯该功能需要的修改点就需要很长时间，更别提修改带来的不可预知的影响面。</p><p>下图是一个常见的系统耦合病例。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/8a1f7d38.svg" alt="服务耦合示意图"></p><p>服务耦合示意图</p><p>订单服务接口中提供了查询、创建订单相关的接口，也提供了订单评价、支付、保险的接口。同时我们的表也是一个订单大表，包含了非常多字段。在我们维护代码时，牵一发而动全身，很可能只是想改下评价相关的功能，却影响到了创单核心路径。虽然我们可以通过测试保证功能完备性，但当我们在订单领域有大量需求同时并行开发时，改动重叠、恶性循环、疲于奔命修改各种问题。</p><p>上述问题，归根到底在于系统架构不清晰，划分出来的模块内聚度低、高耦合。</p><p>有一种解决方案，按照演进式设计的理论，让系统的设计随着系统实现的增长而增长。我们不需要作提前设计，就让系统伴随业务成长而演进。这当然是可行的，敏捷实践中的重构、测试驱动设计及持续集成可以对付各种混乱问题。重构——保持行为不变的代码改善清除了不协调的局部设计，测试驱动设计确保对系统的更改不会导致系统丢失或破坏现有功能，持续集成则为团队提供了同一代码库。</p><p>在这三种实践中，<strong>重构是克服演进式设计中大杂烩问题的主力</strong>，通过在单独的类及方法级别上做一系列小步重构来完成。我们可以很容易重构出一个独立的类来放某些通用的逻辑，但是你会发现你很难给它一个业务上的含义，只能给予一个技术维度描绘的含义。这会带来什么问题呢？新同学并不总是知道对通用逻辑的改动或获取来自该类。显然，制定项目规范并不是好的idea。我们又闻到了代码即将腐败的味道。</p><p>事实上，你可能意识到问题之所在。在解决现实问题时，我们会将问题映射到脑海中的概念模型，在模型中解决问题，再将解决方案转换为实际的代码。上述问题在于我们解决了设计到代码之间的重构，<strong>但提炼出来的设计模型，并不具有实际的业务含义，这就导致在开发新需求时，其他同学并不能很自然地将业务问题映射到该设计模型。设计似乎变成了重构者的自娱自乐，代码继续腐败，重新重构……无休止的循环。</strong></p><p>用DDD则可以很好地解决领域模型到设计模型的同步、演化，最后再将反映了领域的设计模型转为实际的代码。</p><p>注：模型是我们解决实际问题所抽象出来的概念模型，领域模型则表达与业务相关的事实；设计模型则描述了所要构建的系统。</p><h3 id="贫血症和失忆症"><a href="#贫血症和失忆症" class="headerlink" title="贫血症和失忆症"></a>贫血症和失忆症</h3><blockquote><p><strong>贫血领域对象</strong></p><p>贫血领域对象（Anemic Domain Object）是指仅用作数据载体，而没有行为和动作的领域对象。</p></blockquote><p>在我们习惯了J2EE的开发模式后，Action&#x2F;Service&#x2F;DAO这种分层模式，会很自然地写出过程式代码，而学到的很多关于OO理论的也毫无用武之地。使用这种开发方式，对象只是数据的载体，没有行为。以数据为中心，以数据库ER设计作驱动。分层架构在这种开发模式下，可以理解为是对数据移动、处理和实现的过程。</p><p>以笔者最近开发的系统抽奖平台为例：</p><ul><li>场景需求</li></ul><p>奖池里配置了很多奖项，我们需要按运营预先配置的概率抽中一个奖项。 实现非常简单，生成一个随机数，匹配符合该随机数生成概率的奖项即可。</p><ul><li>贫血模型实现方案</li></ul><p>先设计奖池和奖项的库表配置。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210307204734.svg" alt="抽奖ER图"></p><p>抽奖ER图</p><ul><li>设计AwardPool和Award两个对象，只有简单的get和set属性的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AwardPool</span> &#123;</span><br><span class="line">    <span class="type">int</span> awardPoolId;</span><br><span class="line">    List&lt;Award&gt; awards;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Award&gt; <span class="title function_">getAwards</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> awards;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAwards</span><span class="params">(List&lt;Award&gt; awards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.awards = awards;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Award</span> &#123;</span><br><span class="line">   <span class="type">int</span> awardId;</span><br><span class="line">   <span class="type">int</span> probability;<span class="comment">//概率</span></span><br><span class="line">  </span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Service代码实现</li></ul><p>设计一个LotteryService，在其中的drawLottery()方法写服务逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AwardPool</span> <span class="variable">awardPool</span> <span class="operator">=</span> awardPoolDao.getAwardPool(poolId);<span class="comment">//sql查询，将数据映射到AwardPool对象</span></span><br><span class="line"><span class="keyword">for</span> (Award award : awardPool.getAwards()) &#123;</span><br><span class="line">   <span class="comment">//寻找到符合award.getProbability()概率的award</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按照我们通常思路实现，可以发现：在业务领域里非常重要的抽奖，我的业务逻辑都是写在Service中的，Award充其量只是个数据载体，没有任何行为。<strong>简单的业务系统采用这种贫血模型和过程化设计是没有问题的，</strong>但在业务逻辑复杂了，业务逻辑、状态会散落到在大量方法中，原本的代码意图会渐渐不明确，我们将这种情况称为由贫血症引起的<strong>失忆症</strong>。</li></ul><p>更好的是采用领域模型的开发方式，将数据和行为封装在一起，并与现实世界中的业务对象相映射。各类具备明确的职责划分，将领域逻辑分散到领域对象中。继续举我们上述抽奖的例子，使用概率选择对应的奖品就应当放到AwardPool类中。</p><h3 id="软件系统复杂性应对"><a href="#软件系统复杂性应对" class="headerlink" title="软件系统复杂性应对"></a>软件系统复杂性应对</h3><p>解决<strong>复杂和大规模软件</strong>的武器可以被粗略地归为三类：抽象、分治和知识。</p><p><strong>分治</strong> 把问题空间分割为规模更小且易于处理的若干子问题。分割后的问题需要足够小，以便一个人单枪匹马就能够解决他们；其次，必须考虑如何将分割后的各个部分装配为整体。分割得越合理越易于理解，在装配成整体时，所需跟踪的细节也就越少。即更容易设计各部分的协作方式。评判什么是分治得好，即高内聚低耦合。</p><p><strong>抽象</strong> 使用抽象能够精简问题空间，而且问题越小越容易理解。举个例子，从北京到上海出差，可以先理解为使用交通工具前往，但不需要一开始就想清楚到底是高铁还是飞机，以及乘坐他们需要注意什么。</p><p><strong>知识</strong> 顾名思义，DDD可以认为是知识的一种。</p><p>DDD提供了这样的知识手段，让我们知道如何抽象出限界上下文以及如何去分治。</p><h3 id="与微服务架构相得益彰"><a href="#与微服务架构相得益彰" class="headerlink" title="与微服务架构相得益彰"></a>与微服务架构相得益彰</h3><p>微服务架构众所周知，此处不做赘述。我们创建微服务时，需要创建一个高内聚、低耦合的微服务。而DDD中的限界上下文则完美匹配微服务要求，可以将该限界上下文理解为一个微服务进程。</p><p>上述是从更直观的角度来描述两者的相似处。</p><p>在系统复杂之后，我们都需要用分治来拆解问题。一般有两种方式，技术维度和业务维度。技术维度是类似MVC这样，业务维度则是指按业务领域来划分系统。</p><p>微服务架构更强调从业务维度去做分治来应对系统复杂度，而DDD也是同样的着重业务视角。 如果<strong>两者在追求的目标（业务维度）达到了上下文的统一</strong>，那么在具体做法上有什么联系和不同呢？</p><p>我们将架构设计活动精简为以下三个层面：</p><ul><li>业务架构——根据业务需求设计业务模块及其关系</li><li>系统架构——设计系统和子系统的模块</li><li>技术架构——决定采用的技术及框架</li></ul><p>以上三种活动在实际开发中是有先后顺序的，但不一定孰先孰后。在我们解决常规套路问题时，我们会很自然地往熟悉的分层架构套（先确定系统架构），或者用PHP开发很快（先确定技术架构），在业务不复杂时，这样是合理的。</p><p>跳过业务架构设计出来的架构关注点不在业务响应上，可能就是个大泥球，在面临需求迭代或响应市场变化时就很痛苦。</p><p><strong>DDD的核心诉求就是将业务架构映射到系统架构上，在响应业务变化调整业务架构时，也随之变化系统架构。而微服务追求业务层面的复用，设计出来的系统架构和业务一致；在技术架构上则系统模块之间充分解耦，可以自由地选择合适的技术架构，去中心化地治理技术和数据。</strong></p><p>可以参见下图来更好地理解双方之间的协作关系：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210307204709.svg" alt="DDD与微服务关系"></p><p>DDD与微服务关系</p><h2 id="如何实践DDD"><a href="#如何实践DDD" class="headerlink" title="如何实践DDD"></a>如何实践DDD</h2><p>我们将通过上文提到的抽奖平台，来详细介绍我们如何通过DDD来解构一个中型的基于微服务架构的系统，从而做到系统的高内聚、低耦合。</p><p>首先看下抽奖系统的大致需求： 运营——可以配置一个抽奖活动，该活动面向一个特定的用户群体，并针对一个用户群体发放一批不同类型的奖品（优惠券，激活码，实物奖品等）。 用户-通过活动页面参与不同类型的抽奖活动。</p><p>设计领域模型的一般步骤如下：</p><ol><li>根据需求划分出初步的领域和限界上下文，以及上下文之间的关系；</li><li>进一步分析每个上下文内部，识别出哪些是实体，哪些是值对象；</li><li>对实体、值对象进行关联和聚合，划分出聚合的范畴和聚合根；</li><li>为聚合根设计仓储，并思考实体或值对象的创建方式；</li><li>在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构。</li></ol><h3 id="战略建模"><a href="#战略建模" class="headerlink" title="战略建模"></a>战略建模</h3><p>战略和战术设计是站在DDD的角度进行划分。战略设计侧重于高层次、宏观上去划分和集成限界上下文，而战术设计则关注更具体使用建模工具来细化上下文。</p><h4 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h4><p>现实世界中，领域包含了问题域和解系统。一般认为软件是对现实世界的部分模拟。在DDD中，解系统可以映射为一个个限界上下文，限界上下文就是软件对于问题域的一个特定的、有限的解决方案。</p><h4 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a>限界上下文</h4><blockquote><p><strong>限界上下文</strong></p><p>一个由显示边界限定的特定职责。领域模型便存在于这个边界之内。在边界内，每一个模型概念，包括它的属性和操作，都具有特殊的含义。</p></blockquote><p>一个给定的业务领域会包含多个限界上下文，想与一个限界上下文沟通，则需要通过显示边界进行通信。系统通过确定的限界上下文来进行解耦，而每一个上下文内部紧密组织，职责明确，具有较高的内聚性。</p><p>一个很形象的隐喻：细胞质所以能够存在，是因为细胞膜限定了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。</p><h4 id="划分限界上下文"><a href="#划分限界上下文" class="headerlink" title="划分限界上下文"></a>划分限界上下文</h4><p>划分限界上下文，不管是Eric Evans还是Vaughn Vernon，在他们的大作里都没有怎么提及。</p><p>显然我们不应该按技术架构或者开发任务来创建限界上下文，应该按照语义的边界来考虑。</p><p><strong>我们的实践是，考虑产品所讲的通用语言，从中提取一些术语称之为概念对象，寻找对象之间的联系；或者从需求里提取一些动词，观察动词和对象之间的关系；我们将紧耦合的各自圈在一起，观察他们内在的联系，从而形成对应的界限上下文。形成之后，我们可以尝试用语言来描述下界限上下文的职责，看它是否清晰、准确、简洁和完整。简言之，限界上下文应该从需求出发，按领域划分。</strong></p><p>前文提到，我们的用户划分为运营和用户。其中，运营对抽奖活动的配置十分复杂但相对低频。用户对这些抽奖活动配置的使用是高频次且无感知的。根据这样的业务特点，我们首先将抽奖平台划分为C端抽奖和M端抽奖管理平台两个子域，让两者完全解耦。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210307204646.svg" alt="抽奖平台领域"></p><p>抽奖平台领域</p><p>在确认了M端领域和C端的限界上下文后，我们再对各自上下文内部进行限界上下文的划分。下面我们用C端进行举例。</p><p>产品的需求概述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 抽奖活动有活动限制，例如用户的抽奖次数限制，抽奖的开始和结束的时间等；</span><br><span class="line">2. 一个抽奖活动包含多个奖品，可以针对一个或多个用户群体；</span><br><span class="line">3. 奖品有自身的奖品配置，例如库存量，被抽中的概率等，最多被一个用户抽中的次数等等；</span><br><span class="line">4. 用户群体有多种区别方式，如按照用户所在城市区分，按照新老客区分等；</span><br><span class="line">5. 活动具有风控配置，能够限制用户参与抽奖的频率。</span><br></pre></td></tr></table></figure><p>根据产品的需求，我们提取了一些关键性的概念作为子域，形成我们的限界上下文。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210307204603.svg" alt="C端抽奖领域"></p><p>C端抽奖领域</p><p>首先，抽奖上下文作为整个领域的核心，承担着用户抽奖的核心业务，抽奖中包含了奖品和用户群体的概念。</p><ul><li>在设计初期，我们曾经考虑划分出抽奖和发奖两个领域，前者负责选奖，后者负责将选中的奖品发放出去。但在实际开发过程中，我们发现这两部分的逻辑紧密连接，难以拆分。并且单纯的发奖逻辑足够简单，仅仅是调用第三方服务进行发奖，不足以独立出来成为一个领域。</li></ul><p>对于活动的限制，我们定义了活动准入的通用语言，将活动开始&#x2F;结束时间，活动可参与次数等限制条件都收拢到活动准入上下文中。</p><p>对于抽奖的奖品库存量，由于库存的行为与奖品本身相对解耦，库存关注点更多是库存内容的核销，且库存本身具备通用性，可以被奖品之外的内容使用，因此我们定义了独立的库存上下文。</p><p>由于C端存在一些刷单行为，我们根据产品需求定义了风控上下文，用于对活动进行风控。 最后，活动准入、风控、抽奖等领域都涉及到一些次数的限制，因此我们定义了计数上下文。</p><p>可以看到，通过DDD的限界上下文划分，我们界定出抽奖、活动准入、风控、计数、库存等五个上下文，每个上下文在系统中都高度内聚。</p><h4 id="上下文映射图"><a href="#上下文映射图" class="headerlink" title="上下文映射图"></a>上下文映射图</h4><p>在进行上下文划分之后，我们还需要进一步梳理上下文之间的关系。</p><blockquote><p><strong>康威（梅尔·康威）定律</strong></p><p>任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。</p></blockquote><p>康威定律告诉我们，系统结构应尽量的与组织结构保持一致。这里，我们认为团队结构（无论是内部组织还是团队间组织）就是组织结构，限界上下文就是系统的业务结构。因此，团队结构应该和限界上下文保持一致。</p><p>梳理清楚上下文之间的关系，从团队内部的关系来看，有如下好处：</p><ol><li>任务更好拆分，一个开发人员可以全身心的投入到相关的一个单独的上下文中；</li><li>沟通更加顺畅，一个上下文可以明确自己对其他上下文的依赖关系，从而使得团队内开发直接更好的对接。</li></ol><p>从团队间的关系来看，明确的上下文关系能够带来如下帮助：</p><ol><li>每个团队在它的上下文中能够更加明确自己领域内的概念，因为上下文是领域的解系统；</li><li>对于限界上下文之间发生交互，团队与上下文的一致性，能够保证我们明确对接的团队和依赖的上下游。</li></ol><blockquote><p><strong>限界上下文之间的映射关系</strong></p><ul><li>合作关系（Partnership）：两个上下文紧密合作的关系，一荣俱荣，一损俱损。</li><li>共享内核（Shared Kernel）：两个上下文依赖部分共享的模型。</li><li>客户方-供应方开发（Customer-Supplier Development）：上下文之间有组织的上下游依赖。</li><li>遵奉者（Conformist）：下游上下文只能盲目依赖上游上下文。</li><li>防腐层（Anticorruption Layer）：一个上下文通过一些适配和转换与另一个上下文交互。</li><li>开放主机服务（Open Host Service）：定义一种协议来让其他上下文来对本上下文进行访问。</li><li>发布语言（Published Language）：通常与OHS一起使用，用于定义开放主机的协议。</li><li>大泥球（Big Ball of Mud）：混杂在一起的上下文关系，边界不清晰。</li><li>另谋他路（SeparateWay）：两个完全没有任何联系的上下文。</li></ul></blockquote><p>上文定义了上下文映射间的关系，经过我们的反复斟酌，抽奖平台上下文的映射关系图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210307204349.svg" alt="上下文映射关系"></p><p>上下文映射关系</p><p>由于抽奖，风控，活动准入，库存，计数五个上下文都处在抽奖领域的内部，所以它们之间符合“一荣俱荣，一损俱损”的合作关系（PartnerShip，简称PS）。</p><p>同时，抽奖上下文在进行发券动作时，会依赖券码、平台券、外卖券三个上下文。抽奖上下文通过防腐层（Anticorruption Layer，ACL）对三个上下文进行了隔离，而三个券上下文通过开放主机服务（Open Host Service）作为发布语言（Published Language）对抽奖上下文提供访问机制。</p><p><strong>通过上下文映射关系，我们明确的限制了限界上下文的耦合性，即在抽奖平台中，无论是上下文内部交互（合作关系）还是与外部上下文交互（防腐层），耦合度都限定在数据耦合（Data Coupling）的层级。</strong></p><h3 id="战术建模——细化上下文"><a href="#战术建模——细化上下文" class="headerlink" title="战术建模——细化上下文"></a>战术建模——细化上下文</h3><p>梳理清楚上下文之间的关系后，我们需要从战术层面上剖析上下文内部的组织关系。首先看下DDD中的一些定义。</p><blockquote><p><strong>实体</strong></p><p>当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）。</p><p>例：最简单的，公安系统的身份信息录入，对于人的模拟，即认为是实体，因为每个人是独一无二的，且其具有唯一标识（如公安系统分发的身份证号码）。</p></blockquote><p>在实践上建议将属性的验证放到实体中。</p><blockquote><p><strong>值对象</strong></p><p>当一个对象用于对事务进行描述而没有唯一标识时，它被称作值对象（Value Object）。</p><p>例：比如颜色信息，我们只需要知道{“name”:“黑色”，”css”:“#000000”}这样的值信息就能够满足要求了，这避免了我们对标识追踪带来的系统复杂性。</p></blockquote><p>值对象很重要，在习惯了使用数据库的数据建模后，很容易将所有对象看作实体。使用值对象，可以更好地做系统优化、精简设计。</p><p>它具有不变性、相等性和可替换性。</p><p>在实践中，需要保证值对象创建后就不能被修改，即不允许外部再修改其属性。在不同上下文集成时，会出现模型概念的公用，如商品模型会存在于电商的各个上下文中。在订单上下文中如果你只关注下单时商品信息快照，那么将商品对象视为值对象是很好的选择。</p><blockquote><p><strong>聚合根</strong></p><p>Aggregate(聚合）是一组相关对象的集合，作为一个整体被外界访问，聚合根（Aggregate Root）是这个聚合的根节点。</p></blockquote><p>聚合是一个非常重要的概念，核心领域往往都需要用聚合来表达。其次，聚合在技术上有非常高的价值，可以指导详细设计。</p><p>聚合由根实体，值对象和实体组成。</p><p>如何创建好的聚合？</p><ul><li>边界内的内容具有一致性：在一个事务中只修改一个聚合实例。如果你发现边界内很难接受强一致，不管是出于性能或产品需求的考虑，应该考虑剥离出独立的聚合，采用最终一致的方式。</li><li>设计小聚合：大部分的聚合都可以只包含根实体，而无需包含其他实体。即使一定要包含，可以考虑将其创建为值对象。</li><li>通过唯一标识来引用其他聚合或实体：当存在对象之间的关联时，建议引用其唯一标识而非引用其整体对象。如果是外部上下文中的实体，引用其唯一标识或将需要的属性构造值对象。 如果聚合创建复杂，推荐使用工厂方法来屏蔽内部复杂的创建逻辑。</li></ul><p>聚合内部多个组成对象的关系可以用来指导数据库创建，但不可避免存在一定的抗阻。如聚合中存在List&lt;值对象&gt;，那么在数据库中建立1:N的关联需要将值对象单独建表，此时是有id的，建议不要将该id暴露到资源库外部，对外隐蔽。</p><blockquote><p><strong>领域服务</strong></p><p>一些重要的领域行为或操作，可以归类为领域服务。它既不是实体，也不是值对象的范畴。</p></blockquote><p>当我们采用了微服务架构风格，一切领域逻辑的对外暴露均需要通过领域服务来进行。如原本由聚合根暴露的业务逻辑也需要依托于领域服务。</p><blockquote><p><strong>领域事件</strong></p><p>领域事件是对领域内发生的活动进行的建模。</p></blockquote><p>抽奖平台的核心上下文是抽奖上下文，接下来介绍下我们对抽奖上下文的建模。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210307205016.svg" alt="抽奖上下文"></p><p>在抽奖上下文中，我们通过抽奖(DrawLottery)这个聚合根来控制抽奖行为，可以看到，一个抽奖包括了抽奖ID（LotteryId）以及多个奖池（AwardPool），而一个奖池针对一个特定的用户群体（UserGroup）设置了多个奖品（Award）。</p><p>另外，在抽奖领域中，我们还会使用抽奖结果（SendResult）作为输出信息，使用用户领奖记录（UserLotteryLog）作为领奖凭据和存根。</p><p><strong>谨慎使用值对象</strong></p><p>在实践中，我们发现虽然一些领域对象符合值对象的概念，但是随着业务的变动，很多原有的定义会发生变更，值对象可能需要在业务意义具有唯一标识，而对这类值对象的重构往往需要较高成本。因此在特定的情况下，我们也要根据实际情况来权衡领域对象的选型。</p><h2 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h2><p>对许多应用来说，这个解决方案就是使用事件驱动架构（event-driven architecture）。在这种架构中，当某件重要事情发生时，微服务会发布一个事件，例如更新一个业务实体。当订阅这些事件的微服务接收此事件时，就可以更新自己的业务实体，也可能会引发更多的事件发布。</p><p>可以使用事件来实现跨多服务的业务交易。交易一般由一系列步骤构成，每一步骤都由一个更新业务实体的微服务和发布激活下一步骤的事件构成。下图展现如何使用事件驱动方法，在创建订单时检查信用可用度，微服务通过消息代理（Message Broker）来交换事件。</p><ol><li>订单服务创建一个带有 NEW 状态的 Order （订单），发布了一个 “Order Created Event（创建订单）” 的事件。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225154505.png" alt="Order-Created-Event"></p><ol><li>客户服务消费 Order Created Event 事件，为此订单预留信用，发布 “Credit Reserved Event（信用预留）” 事件。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225154659.png" alt="Credit-Reserved-Event"></p><ol><li>订单服务消费 Credit Reserved Event ，改变订单的状态为 OPEN。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225154636.png" alt="Status-is-OPEN"></p><p>更复杂的场景可以引入更多步骤，例如在检查用户信用的同时预留库存等。</p><p>考虑到（a）每个服务原子性更新数据库和发布事件，然后，（b）消息代理确保事件传递至少一次，然后可以跨多个服务完成业务交易（此交易不是 ACID 交易）。这种模式提供弱确定性，例如最终一致性 eventual consistency。这种交易类型被称作 BASE model。</p><p>亦可以使用事件来维护不同微服务拥有数据预连接（pre-join）的实现视图。维护此视图的服务订阅相关事件并且更新视图。例如，客户订单视图更新服务（维护客户订单视图）会订阅由客户服务和订单服务发布的事件。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225154614.png" alt="pre-join"></p><p>当客户订单视图更新服务收到客户或者订单事件，就会更新 客户订单视图数据集。可以使用文档数据库（例如 MongoDB）来实现客户订单视图，为每个用户存储一个文档。客户订单视图查询服务负责响应对客户以及最近订单（通过查询客户订单视图数据集）的查询。</p><p>事件驱动架构也是既有优点也有缺点，此架构可以使得交易跨多个服务且提供最终一致性，并且可以使应用维护最终视图；而缺点在于编程模式比 ACID 交易模式更加复杂：为了从应用层级失效中恢复，还需要完成补偿性交易，例如，如果信用检查不成功则必须取消订单；另外，应用必须应对不一致的数据，这是因为临时（in-flight）交易造成的改变是可见的，另外当应用读取未更新的最终视图时也会遇见数据不一致问题。另外一个缺点在于订阅者必须检测和忽略冗余事件。</p><h2 id="Event-Sourcing"><a href="#Event-Sourcing" class="headerlink" title="Event Sourcing"></a>Event Sourcing</h2><p>Event sourcing （事件溯源）通过使用根本不同的事件中心方式来获得不需 2PC 的原子性，保证业务实体的一致性。 这种应用保存业务实体一系列状态改变事件，而不是存储实体现在的状态。应用可以通过重放事件来重建实体现在状态。只要业务实体发生变化，新事件就会添加到时间表中。因为保存事件是单一操作，因此肯定是原子性的。</p><p>为了理解事件源工作方式，考虑事件实体作为一个例子。传统方式中，每个订单映射为 ORDER 表中一行，例如在 ORDER_LINE_ITEM 表中。但是对于事件源方式，订单服务以事件状态改变方式存储一个订单：创建的，已批准的，已发货的，取消的；每个事件包括足够数据来重建订单状态。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225165545.png" alt="Event-sourcing"></p><p>事件是长期保存在事件数据库中，提供 API 添加和获取实体事件。事件存储跟之前描述的消息代理类似，提供 API 来订阅事件。事件存储将事件递送到所有感兴趣的订阅者，事件存储是事件驱动微服务架构的基干。</p><p>事件源方法有很多优点：解决了事件驱动架构关键问题，使得只要有状态变化就可以可靠地发布事件，也就解决了微服务架构中数据一致性问题。另外，因为是持久化事件而不是对象，也就避免了 object relational impedance mismatch problem。</p><p>数据源方法提供了 100%可靠的业务实体变化监控日志，使得获取任何时点实体状态成为可能。另外，事件源方法可以使得业务逻辑可以由事件交换的松耦合业务实体构成。这些优势使得单体应用移植到微服务架构变的相对容易。</p><p>事件源方法也有不少缺点，因为采用不同或者不太熟悉的变成模式，使得重新学习不太容易；事件存储只支持主键查询业务实体，必须使用 Command Query Responsibility Segregation (CQRS) 来完成查询业务，因此，应用必须处理最终一致数据。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html">美团技术博客-领域驱动设计在互联网业务开发中的实践</a></li><li><a href="https://doocs.github.io/advanced-java/#/./docs/micro-services/event-driven-data-management-for-microservices">微服务和分布式数据管理问题</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;什么是领域驱动设计？&quot;&gt;&lt;a href=&quot;#什么是领域驱动设计？&quot; class=&quot;headerlink&quot; title=&quot;什么是领域驱动设计？&quot;&gt;&lt;/a&gt;什么是领域驱动设计？&lt;/h2&gt;&lt;h2 id=&quot;为什么要使用DDD？&quot;&gt;&lt;a href=&quot;#为什么要使用</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="DDD" scheme="https://blog.elfred.top/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>08讲</title>
    <link href="https://blog.elfred.top/posts/e0865d0a.html"/>
    <id>https://blog.elfred.top/posts/e0865d0a.html</id>
    <published>2021-04-20T13:40:00.000Z</published>
    <updated>2025-03-08T14:46:55.129Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="08-栈：如何实现浏览器的前进和后退功能？"><a href="#08-栈：如何实现浏览器的前进和后退功能？" class="headerlink" title="08 | 栈：如何实现浏览器的前进和后退功能？"></a>08 | 栈：如何实现浏览器的前进和后退功能？</h1><h2 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h2><p>关于“栈”，我有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。<strong>后进者先出，先进者后出，这就是典型的“栈”结构</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210508072455.jpeg" alt="img"></p><p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><p>我第一次接触这种数据结构的时候，就对它存在的意义产生了很大的疑惑。因为我觉得，相比数组和链表，栈带给我的只有限制，并没有任何优势。那我直接使用数组或者链表不就好了吗？为什么还要用这个“操作受限”的“栈”呢？</p><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构</strong>。</p><h2 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h2><p>实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;           <span class="comment">//栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(String item)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组空间不够了，直接返回false，入栈失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将item放到下标为count的位置，并且count加一</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 栈为空，则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了定义和基本操作，那它的操作的时间、空间复杂度是多少呢？</p><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。</p><p>注意，这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为，这 n 个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p><p>空间复杂度分析是不是很简单？时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。</p><h2 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h2><p>刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储 next 指针，内存消耗相对较多。那我们如何基于数组实现一个可以支持动态扩容的栈呢？</p><p>你还记得，我们在数组那一节，是如何来实现一个支持动态扩容的数组的吗？当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p><p>所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。我画了一张图，你可以对照着理解一下。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210508072907.jpeg" alt="img"></p><h2 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h2><p>前面我讲的都比较偏理论，我们现在来看下，栈在软件工程中的实际应用。栈作为一个比较基础的数据结构，应用场景还是蛮多的。其中，比较经典的一个应用场景就是<strong>函数调用栈</strong>。</p><p>我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了让你更好地理解，我们一块来看下这段代码的执行过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看出，main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值。为了让你清晰地看到这个过程对应的函数栈里出栈、入栈的操作，我画了一张图。图中显示的是，在执行到 add() 函数时，函数调用栈的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210508073240.jpeg" alt="img"></p><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p>我们再来看栈的另一个常见的应用场景，编译器如何利用栈来实现<strong>表达式求值</strong>。</p><p>为了方便解释，我将算术表达式简化为只包含加减乘除四则运算，比如：34+13*9+44-12&#x2F;3。对于这个四则运算，我们人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事儿。如果换作你，让你来实现这样一个表达式求值的功能，你会怎么做呢？</p><p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><p>我将 3+5*8-6 这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过程。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210508073429.jpeg" alt="img"></p><h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。</p><p>我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p><p>这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p><p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>好了，我想现在你已经完全理解了栈的概念。我们再回来看看开篇的思考题，如何实现浏览器的前进、后退功能？其实，用两个栈就可以非常完美地解决这个问题。</p><p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p><p>比如你顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210508073855.jpeg" alt="img"></p><p>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210508073904.jpeg" alt="img"></p><p>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210508073951.jpeg" alt="img"></p><p>这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210508073921.jpeg" alt="img"></p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>我们来回顾一下今天讲的内容。栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。除此之外，我们还讲了一种支持动态扩容的顺序栈，你需要重点掌握它的均摊时间复杂度分析方法。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol><li><p>我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p><blockquote><p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p><p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p></blockquote></li><li><p>我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？</p><blockquote><p>虽然内存中的栈和数据结构的栈不是一回事，即内存中的栈是一段虚拟的内存空间，数据结构中的栈是一种抽象的数据类型，但是它们都有“栈”的特性——后进先出，所以都叫“栈”也无可厚非。</p></blockquote></li></ol><h2 id="多写多练"><a href="#多写多练" class="headerlink" title="多写多练"></a>多写多练</h2><ul><li><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h4></li><li><h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h4></li><li><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4></li><li><h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h4></li><li><h4 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器</a></h4></li><li><h4 id="682-棒球比赛"><a href="#682-棒球比赛" class="headerlink" title="682. 棒球比赛"></a><a href="https://leetcode-cn.com/problems/baseball-game/">682. 棒球比赛</a></h4></li><li><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;08-栈：如何实现浏览器的前进和后退功能？&quot;&gt;&lt;a href=&quot;#08-栈：如何实现浏览器的前进和后退功能？&quot; class=&quot;headerlink&quot; title=&quot;08 | 栈：如何实现浏览器的前进和后退功能？&quot;&gt;&lt;/a&gt;08 | 栈：如何实现浏览器的前</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>第六周</title>
    <link href="https://blog.elfred.top/posts/5a474594.html"/>
    <id>https://blog.elfred.top/posts/5a474594.html</id>
    <published>2021-04-18T14:13:00.000Z</published>
    <updated>2025-03-08T14:46:55.133Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.04.12-2021.04.18</p><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h3><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210418221157.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>0 &lt;= n &lt;= 3 * 104^</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-03-06-动物收容所"><a href="#面试题-03-06-动物收容所" class="headerlink" title="面试题 03.06. 动物收容所"></a><a href="https://leetcode-cn.com/problems/animal-shelter-lcci/">面试题 03.06. 动物收容所</a></h3><p>动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如<code>enqueue</code>、<code>dequeueAny</code>、<code>dequeueDog</code>和<code>dequeueCat</code>。允许使用Java内置的LinkedList数据结构。</p><p><code>enqueue</code>方法有一个<code>animal</code>参数，<code>animal[0]</code>代表动物编号，<code>animal[1]</code>代表动物种类，其中 0 代表猫，1 代表狗。</p><p><code>dequeue*</code>方法返回一个列表<code>[动物编号, 动物种类]</code>，若没有可以收养的动物，则返回<code>[-1,-1]</code>。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入：</span><br><span class="line">[&quot;AnimalShelf&quot;, &quot;enqueue&quot;, &quot;enqueue&quot;, &quot;dequeueCat&quot;, &quot;dequeueDog&quot;, &quot;dequeueAny&quot;]</span><br><span class="line">[[], [[0, 0]], [[1, 0]], [], [], []]</span><br><span class="line"> 输出：</span><br><span class="line">[null,null,null,[0,0],[-1,-1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入：</span><br><span class="line">[&quot;AnimalShelf&quot;, &quot;enqueue&quot;, &quot;enqueue&quot;, &quot;enqueue&quot;, &quot;dequeueDog&quot;, &quot;dequeueCat&quot;, &quot;dequeueAny&quot;]</span><br><span class="line">[[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []]</span><br><span class="line"> 输出：</span><br><span class="line">[null,null,null,null,[2,1],[0,0],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>收纳所的最大容量为20000</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.04.12-2021.04.18&lt;/p&gt;
&lt;h3 id=&quot;42-接雨水&quot;&gt;&lt;a href=&quot;#42-接雨水&quot; class=&quot;headerlink&quot; title=&quot;42. 接雨水&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://le</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>第五周</title>
    <link href="https://blog.elfred.top/posts/3f490e4d.html"/>
    <id>https://blog.elfred.top/posts/3f490e4d.html</id>
    <published>2021-04-06T05:59:00.000Z</published>
    <updated>2025-03-08T14:46:55.133Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.04.06-2021.04.11</p><h3 id="面试题-08-06-汉诺塔问题"><a href="#面试题-08-06-汉诺塔问题" class="headerlink" title="面试题 08.06. 汉诺塔问题"></a><a href="https://leetcode-cn.com/problems/hanota-lcci/">面试题 08.06. 汉诺塔问题</a></h3><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><p>你需要原地修改栈。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [2, 1, 0], B = [], C = []</span><br><span class="line">输出：C = [2, 1, 0]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1, 0], B = [], C = []</span><br><span class="line">输出：C = [1, 0]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li>A中盘子的数目不大于14个。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h4><p>难度中等1077</p><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>进阶：</strong></p><ul><li>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</li></ul><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210406141723.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210406141731.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.04.06-2021.04.11&lt;/p&gt;
&lt;h3 id=&quot;面试题-08-06-汉诺塔问题&quot;&gt;&lt;a href=&quot;#面试题-08-06-汉诺塔问题&quot; class=&quot;headerlink&quot; title=&quot;面试题 08.06. 汉诺塔</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>第四周</title>
    <link href="https://blog.elfred.top/posts/50d7cb0a.html"/>
    <id>https://blog.elfred.top/posts/50d7cb0a.html</id>
    <published>2021-03-29T05:59:00.000Z</published>
    <updated>2025-03-08T14:46:55.133Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.03.29-2021.04.04</p><h3 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h3><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p><p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li><li><code>1 &lt;= value &lt;= 10^5</code></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题59-I-滑动窗口的最大值"><a href="#面试题59-I-滑动窗口的最大值" class="headerlink" title="面试题59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">面试题59 - I. 滑动窗口的最大值</a></h3><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p>注意：本题与主站 239 题相同：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.03.29-2021.04.04&lt;/p&gt;
&lt;h3 id=&quot;剑指-Offer-59-II-队列的最大值&quot;&gt;&lt;a href=&quot;#剑指-Offer-59-II-队列的最大值&quot; class=&quot;headerlink&quot; title=&quot;剑指</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>07讲</title>
    <link href="https://blog.elfred.top/posts/b8e54d5c.html"/>
    <id>https://blog.elfred.top/posts/b8e54d5c.html</id>
    <published>2021-03-28T17:00:00.000Z</published>
    <updated>2025-03-08T14:46:55.127Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="07-链表（下）：如何轻松写出正确的链表代码？"><a href="#07-链表（下）：如何轻松写出正确的链表代码？" class="headerlink" title="07 | 链表（下）：如何轻松写出正确的链表代码？"></a>07 | 链表（下）：如何轻松写出正确的链表代码？</h1><h2 id="几个写链表代码的技巧"><a href="#几个写链表代码的技巧" class="headerlink" title="几个写链表代码的技巧"></a>几个写链表代码的技巧</h2><h3 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h3><p>实际上，对于指针或引用的理解，你只需要记住下面这句话就可以了：</p><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p><p>在编写链表代码的时候，我们经常会有这样的代码：p-&gt;next&#x3D;q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。</p><p>还有一个更复杂的，也是我们写链表代码经常会用到的：p-&gt;next&#x3D;p-&gt;next-&gt;next。这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。</p><p>掌握了指针或引用的概念，你应该可以很轻松地看懂链表代码。恭喜你，已经离写出链表代码近了一步！</p><h3 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h3><p>不知道你有没有这样的感觉，写链表代码的时候，指针指来指去，一会儿就不知道指到哪里了。所以，我们在写的时候，一定注意不要弄丢了指针。</p><p>指针往往都是怎么弄丢的呢？我拿单链表的插入操作为例来给你分析一下。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210329002827.jpeg" alt="img"></p><p>如图所示，我们希望在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a。如果我们将代码实现变成下面这个样子，就会发生指针丢失和内存泄露。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = x;  <span class="comment">// 将p的next指针指向x结点；</span></span><br><span class="line">x-&gt;next = p-&gt;next;  <span class="comment">// 将x的结点的next指针指向b结点；</span></span><br></pre></td></tr></table></figure><p>初学者经常会在这儿犯错。p-&gt;next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 x-&gt;next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。</p><p>对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。所以，我们<strong>插入结点时，一定要注意操作的顺序</strong>，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，我们只需要把第 1 行和第 2 行代码的顺序颠倒一下就可以了。</p><p>同理，<strong>删除链表结点时，也一定要记得手动释放内存空间</strong>，否则，也会出现内存泄漏的问题。当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。</p><h3 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h3><p>首先，我们先来回顾一下单链表的插入和删除操作。如果我们在结点 p 后面插入一个新的结点，只需要下面两行代码就可以搞定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = new_node;</span><br></pre></td></tr></table></figure><p>但是，当我们要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。我们需要进行下面这样的特殊处理，其中 head 表示链表的头结点。所以，从这段代码，我们可以发现，对于单链表的插入操作，第一个结点和其他结点的插入逻辑是不一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == null) &#123;</span><br><span class="line">  head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看单链表结点删除操作。如果要删除结点 p 的后继结点，我们只需要一行代码就可以搞定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure><p>但是，如果我们要删除链表中的最后一个结点，前面的删除代码就不 work 了。跟插入类似，我们也需要对于这种情况特殊处理。写成代码是这样子的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head-&gt;next == null) &#123;</span><br><span class="line">   head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面的一步一步分析，我们可以看出，<strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</strong>。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。如何来解决这个问题呢？</p><p>技巧三中提到的哨兵就要登场了。哨兵，解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。</p><p>还记得如何表示一个空链表吗？head&#x3D;null 表示链表中没有结点了。其中 head 表示头结点指针，指向链表中的第一个结点。</p><p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫<strong>带头链表</strong>。相反，没有哨兵结点的链表就叫作<strong>不带头链表</strong>。</p><p>我画了一个带头链表，你可以发现，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入第一个节点</span></span><br><span class="line">new_node-&gt;next = dummy_node-&gt;next</span><br><span class="line">dummy_node-&gt;next = new_node</span><br><span class="line"><span class="comment">// 删除最后一个节点</span></span><br><span class="line">dummy_node-&gt;next = dummy_node-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210329003540.jpeg" alt="img"></p><h3 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h3><p>软件开发中，代码在一些边界或者异常情况下，最容易产生 Bug。链表代码也不例外。要实现没有 Bug 的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p><p>我经常用来检查链表代码是否正确的边界条件有这样几个：</p><ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul><h3 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h3><p>对于稍微复杂的链表操作，比如前面我们提到的单链表反转，指针一会儿指这，一会儿指那，一会儿就被绕晕了。总感觉脑容量不够，想不清楚。所以这个时候就要使用大招了，<strong>举例法</strong>和<strong>画图法</strong>。</p><p>你可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210329004753.jpeg" alt="img"></p><p>看图写代码，是不是就简单多啦？而且，当我们写完代码之后，也可以举几个例子，画在纸上，照着代码走一遍，很容易就能发现代码中的 Bug。</p><h3 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h3><p>我精选了 5 个常见的链表操作。你只要把这几个操作都能写熟练，不熟就多写几遍，我保证你之后再也不会害怕写链表代码。</p><ul><li><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></p></li><li><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></p></li><li><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p></li><li><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></p></li><li><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></p></li></ul><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>今天我们讲到用哨兵来简化编码实现，你是否还能够想到其他场景，利用哨兵可以大大地简化编码难度？</p><blockquote><p>哨兵可以理解为它可以减少特殊情况的判断，比如判空，比如判越界，比如减少链表插入删除中对空链表的判断，比如例子中对i越界的判断。</p><p>空与越界可以认为是小概率情况，所以代码每一次操作都走一遍判断，在大部分情况下都会是多余的。</p><p>哨兵的巧妙就是提前将这种情况去除，比如给一个哨兵结点，以及将key赋值给数组末元素，让数组遍历不用判断越界也可以因为相等停下来。</p><p>使用哨兵的指导思想应该是将小概率需要的判断先提前扼杀，比如提前给他一个值让他不为null，或者提前预设值，或者多态的时候提前给个空实现，然后在每一次操作中不必再判断以增加效率。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;07-链表（下）：如何轻松写出正确的链表代码？&quot;&gt;&lt;a href=&quot;#07-链表（下）：如何轻松写出正确的链表代码？&quot; class=&quot;headerlink&quot; title=&quot;07 | 链表（下）：如何轻松写出正确的链表代码？&quot;&gt;&lt;/a&gt;07 | 链表（下）</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>06讲</title>
    <link href="https://blog.elfred.top/posts/592a39.html"/>
    <id>https://blog.elfred.top/posts/592a39.html</id>
    <published>2021-03-27T06:57:00.000Z</published>
    <updated>2025-03-08T14:46:55.126Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="06-链表（上）：如何实现LRU缓存淘汰算法"><a href="#06-链表（上）：如何实现LRU缓存淘汰算法" class="headerlink" title="06 | 链表（上）：如何实现LRU缓存淘汰算法?"></a>06 | 链表（上）：如何实现LRU缓存淘汰算法?</h1><h2 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h2><h3 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h3><p>我们先从<strong>底层的存储结构</strong>上来看一看。</p><p>为了直观地对比，我画了一张图。从图中我们看到，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p><p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210327143549.jpeg" alt="img"></p><h3 id="五花八门的的链表结构"><a href="#五花八门的的链表结构" class="headerlink" title="五花八门的的链表结构"></a>五花八门的的链表结构</h3><p>链表结构五花八门，今天我重点给你介绍三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。我们首先来看最简单、最常用的<strong>单链表</strong>。</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>我们刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“<strong>结点</strong>”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210327144616.jpeg" alt="img"></p><p>从我画的单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 NULL</strong>，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以**时间复杂度是 O(n)**。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><p>为了方便你理解，我画了一张图，从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的**时间复杂度是 O(1)**。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210327144923.jpeg" alt="img"></p><p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 <strong>O(n) 的时间复杂度</strong>。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210327145318.jpeg"></p><p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>单链表和循环链表是不是都不难？接下来我们再来看一个稍微复杂的，在实际的软件开发中，也更加常用的链表结构：<strong>双向链表</strong>。</p><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210327145700.jpeg" alt="img"></p><p>从我画的图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p><h4 id="双链表相对单链表的优势"><a href="#双链表相对单链表的优势" class="headerlink" title="双链表相对单链表的优势"></a>双链表相对单链表的优势</h4><p>那相比单链表，双向链表适合解决哪种问题呢？</p><p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>你可能会说，我刚讲到单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的。我再来带你分析一下链表的两个操作。</p><p>我们先来看<strong>删除操作</strong>。</p><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li>删除结点中“值等于某个给定值”的结点；</li><li>删除给定指针指向的结点。</li></ul><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。</p><p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p><p>对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next&#x3D;q，说明 p 是 q 的前驱结点。</p><p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p><p>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。你可以参照我刚刚讲过的删除操作自己分析一下。</p><p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p>了解了循环链表和双向链表，如果把这两种链表整合在一起就是一个新的版本：<strong>双向循环链表</strong>。我想不用我多讲，你应该知道双向循环链表长什么样子了吧？你可以自己试着在纸上画一画。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210327154453.jpeg" alt="img"></p><h3 id="链表-VS-数组性能大比拼"><a href="#链表-VS-数组性能大比拼" class="headerlink" title="链表 VS 数组性能大比拼"></a>链表 VS 数组性能大比拼</h3><p>通过前面内容的学习，你应该已经知道，数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210327154545.jpeg" alt="img"></p><p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><blockquote><p>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找（<strong>计算机的局部性原理</strong>），如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。 对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。</p></blockquote><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p><h2 id="基于链表实现-LRU-缓存淘汰算法"><a href="#基于链表实现-LRU-缓存淘汰算法" class="headerlink" title="基于链表实现 LRU 缓存淘汰算法"></a>基于链表实现 LRU 缓存淘汰算法</h2><h3 id="常见的缓存淘汰策略"><a href="#常见的缓存淘汰策略" class="headerlink" title="常见的缓存淘汰策略"></a>常见的缓存淘汰策略</h3><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p><p>这些策略你不用死记，我打个比方你很容易就明白了。假如说，你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？对应一下，你的选择标准是不是和上面的三种策略神似呢？</p><h3 id="LRU在操作系统中的应用"><a href="#LRU在操作系统中的应用" class="headerlink" title="LRU在操作系统中的应用"></a>LRU在操作系统中的应用</h3><p>LRU最近最少未使用算法。在OS虚拟存储器那部分。用到了该算法，根据程序的局部性原理，前人设计出了虚拟存储器，每个进程只被分配几个内存块，当进程的内存块被占完了之后。从硬盘上又重新读取了一个内存块的数据量，此时，哪个内存块的内容被换出去比较合适呢？如果置换算法采取的不好，就会导致缺页率上升。进程频繁的发生缺页中断。OS就会频繁的在内存和外存之间替换页面。影响了进程的执行效率，这种现象又称之为”抖动”，LRU置换算法的缺页率相对比较低。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：</li></ol><ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul><p>现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p><p>实际上，我们可以继续优化这个实现思路，比如引入<strong>散列表</strong>（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol><li><p>如何基于数组实现LRU算法</p><blockquote><p>循环数组？</p></blockquote></li><li><p>如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？</p><blockquote></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;06-链表（上）：如何实现LRU缓存淘汰算法&quot;&gt;&lt;a href=&quot;#06-链表（上）：如何实现LRU缓存淘汰算法&quot; class=&quot;headerlink&quot; title=&quot;06 | 链表（上）：如何实现LRU缓存淘汰算法?&quot;&gt;&lt;/a&gt;06 | 链表（上）：如</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>05讲</title>
    <link href="https://blog.elfred.top/posts/12ec85d7.html"/>
    <id>https://blog.elfred.top/posts/12ec85d7.html</id>
    <published>2021-03-25T12:57:00.000Z</published>
    <updated>2025-03-08T14:46:55.126Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="数组：为什么很多编程语言中数组都从0开始编号？"><a href="#数组：为什么很多编程语言中数组都从0开始编号？" class="headerlink" title="数组：为什么很多编程语言中数组都从0开始编号？"></a>数组：为什么很多编程语言中数组都从0开始编号？</h1><h2 id="数组如何实现随机访问？"><a href="#数组如何实现随机访问？" class="headerlink" title="数组如何实现随机访问？"></a>数组如何实现随机访问？</h2><h3 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a>什么是数组？</h3><p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据</strong>。</p><h3 id="数组是如何实现根据下标随机访问数组元素的吗？"><a href="#数组是如何实现根据下标随机访问数组元素的吗？" class="headerlink" title="数组是如何实现根据下标随机访问数组元素的吗？"></a>数组是如何实现根据下标随机访问数组元素的吗？</h3><p>我们拿一个长度为 10 的 int 类型的数组 int[] a &#x3D; new int[10]来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address &#x3D; 1000。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210324230955.jpeg" alt="img"></p><p>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。</p><h2 id="容器和数组该如何选择？"><a href="#容器和数组该如何选择？" class="headerlink" title="容器和数组该如何选择？"></a>容器和数组该如何选择？</h2><ol><li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li><li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</li><li>还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList&lt;object&gt;&gt; array。</li></ol><p>总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p><h2 id="为什么数组要从-0-开始编号？"><a href="#为什么数组要从-0-开始编号？" class="headerlink" title="为什么数组要从 0 开始编号？"></a>为什么数组要从 0 开始编号？</h2><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k<span class="number">-1</span>) * type_size</span><br></pre></td></tr></table></figure><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p><p>不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是历史原因。</p><p>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>1.前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。</p><blockquote><p>分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p><p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。</p><p>缺点主要有两个：1. 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；2. 内存碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发一次垃圾回收动作。</p></blockquote><p>2.前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？</p><blockquote><p>二维数组内存寻址：</p><p>对于 m * n 的数组，a [i][j] (i &lt; m, j &lt; n)的地址为：</p><p><code>address = base_address + ( i * n + j) * type_size</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;数组：为什么很多编程语言中数组都从0开始编号？&quot;&gt;&lt;a href=&quot;#数组：为什么很多编程语言中数组都从0开始编号？&quot; class=&quot;headerlink&quot; title=&quot;数组：为什么很多编程语言中数组都从0开始编号？&quot;&gt;&lt;/a&gt;数组：为什么很多编程语言</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>第三周</title>
    <link href="https://blog.elfred.top/posts/e7fad26f.html"/>
    <id>https://blog.elfred.top/posts/e7fad26f.html</id>
    <published>2021-03-24T05:59:00.000Z</published>
    <updated>2025-03-08T14:46:55.132Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.03.22-2021.03.28</p><h3 id="面试题-16-26-计算器"><a href="#面试题-16-26-计算器" class="headerlink" title="面试题 16.26. 计算器"></a><a href="https://leetcode-cn.com/problems/calculator-lcci/">面试题 16.26. 计算器</a></h3><p>给定一个包含正整数、加(+)、减(-)、乘(*)、除(&#x2F;)的算数表达式(括号除外)，计算其结果。</p><p>表达式仅包含非负整数，<code>+</code>， <code>-</code> ，<code>*</code>，<code>/</code> 四种运算符和空格 <code> </code>。 整数除法仅保留整数部分。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;3+2*2&quot;</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot; 3/2 &quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot; 3+5 / 2 &quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>你可以假设所给定的表达式都是有效的。</li><li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>主要思想如下：</p><ol><li>将减法转化为加法（取相反数） </li><li>由于乘除法优先级高，直接计算</li><li>整数不仅一位，会&gt;10 </li><li>表达式中没有括号</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">preSign</span> <span class="operator">=</span> <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="comment">// 连续数字字符串转为数字，比如字符串 “23”</span></span><br><span class="line">                <span class="comment">// num 第一次保存为2，num第二次保存 2*10 + 3 = 23。</span></span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是运算符或者是最后一个字符</span></span><br><span class="line">            <span class="keyword">if</span> ((!Character.isDigit(c) &amp;&amp; c != <span class="string">&#x27; &#x27;</span>) || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (preSign) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stack.push(num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stack.push(-num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stack.push(stack.pop() * num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        stack.push(stack.pop() / num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                preSign = c;</span><br><span class="line">                <span class="comment">// num用完归零</span></span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将栈中元素求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            res += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></h3><p>请根据每日 <code>气温</code> 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p><strong>提示：</strong><code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] T) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> T.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 维护一个单调递减栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> T[i];</span><br><span class="line">            <span class="comment">// 如果栈不为空并且当前元素大于栈顶元素，弹出栈中比当前小的元素</span></span><br><span class="line">            <span class="comment">// 并更新它们在返回数组中对应位置的值（需要等待的天数）</span></span><br><span class="line">            <span class="comment">// 栈里面需要保存元素在数组中的下标，而不是具体的数字。因为需要根据下标修改结果数组</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">preIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                ans[preIndex] = i - preIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.03.22-2021.03.28&lt;/p&gt;
&lt;h3 id=&quot;面试题-16-26-计算器&quot;&gt;&lt;a href=&quot;#面试题-16-26-计算器&quot; class=&quot;headerlink&quot; title=&quot;面试题 16.26. 计算器&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>04讲</title>
    <link href="https://blog.elfred.top/posts/aa50e2b2.html"/>
    <id>https://blog.elfred.top/posts/aa50e2b2.html</id>
    <published>2021-03-21T14:50:00.000Z</published>
    <updated>2025-03-08T14:46:55.125Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"><a href="#复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"></a>复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</h1><h3 id="一、复杂度分析的4个概念"><a href="#一、复杂度分析的4个概念" class="headerlink" title="一、复杂度分析的4个概念"></a>一、复杂度分析的4个概念</h3><ol><li><strong>最好情况时间复杂度</strong>：代码在最理想情况下执行的时间复杂度。</li><li><strong>最坏情况时间复杂度</strong>：代码在最坏情况下执行的时间复杂度。</li><li><strong>平均时间复杂度</strong>：用代码在所有情况下执行的次数的加权平均值表示。</li><li><strong>均摊时间复杂度</strong>：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</li></ol><h3 id="二、为什么要引入这4个概念？"><a href="#二、为什么要引入这4个概念？" class="headerlink" title="二、为什么要引入这4个概念？"></a>二、为什么要引入这4个概念？</h3><ol><li>同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。</li><li>代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</li></ol><h3 id="三、如何分析平均、均摊时间复杂度？"><a href="#三、如何分析平均、均摊时间复杂度？" class="headerlink" title="三、如何分析平均、均摊时间复杂度？"></a>三、如何分析平均、均摊时间复杂度？</h3><ol><li><strong>平均时间复杂度</strong>：代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。</li><li><strong>均摊时间复杂度</strong>：两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度&quot;&gt;&lt;a href=&quot;#复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>03讲</title>
    <link href="https://blog.elfred.top/posts/3787da0b.html"/>
    <id>https://blog.elfred.top/posts/3787da0b.html</id>
    <published>2021-03-21T14:47:11.000Z</published>
    <updated>2025-03-08T14:46:55.127Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"><a href="#复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？" class="headerlink" title="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"></a>复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</h1><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><h4 id="1-只关注循环执行次数最多的一段代码"><a href="#1-只关注循环执行次数最多的一段代码" class="headerlink" title="1.只关注循环执行次数最多的一段代码"></a>1.只关注循环执行次数最多的一段代码</h4><p>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。</p><h4 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2.加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</h4><p><strong>时间复杂度不是代码的执行时间，而是一种随着数据规模不断增长的一种变化趋势</strong>。所以遇到常量执行时间的代码，无论这段代码执行10000次、100000次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。</p><h4 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h4><h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><p>虽然代码千差万别，但是常见的复杂度量级并不多。我稍微总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210321211233.jpeg" alt="img"></p><h4 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1.O(1)"></a>1.O(1)</h4><p>我稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。</p><h4 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2.O(logn)、O(nlogn)"></a>2.O(logn)、O(nlogn)</h4><h4 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="3.O(m+n)、O(m*n)"></a>3.O(m+n)、O(m*n)</h4><h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p>前面我讲过，时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p><p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</p><h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>基础复杂度分析的知识到此就讲完了，我们来总结一下。</p><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210321220126.jpeg" alt="img"></p><h3 id="留言区优秀总结"><a href="#留言区优秀总结" class="headerlink" title="留言区优秀总结"></a>留言区优秀总结</h3><h4 id="一、什么是复杂度分析？"><a href="#一、什么是复杂度分析？" class="headerlink" title="一、什么是复杂度分析？"></a>一、什么是复杂度分析？</h4><p>1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。<br>2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</p><h4 id="二、为什么要进行复杂度分析？"><a href="#二、为什么要进行复杂度分析？" class="headerlink" title="二、为什么要进行复杂度分析？"></a>二、为什么要进行复杂度分析？</h4><p>1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</p><h4 id="三、如何进行复杂度分析？"><a href="#三、如何进行复杂度分析？" class="headerlink" title="三、如何进行复杂度分析？"></a>三、如何进行复杂度分析？</h4><h5 id="1-大O表示法"><a href="#1-大O表示法" class="headerlink" title="1.大O表示法"></a>1.大O表示法</h5><p>1）来源<br>算法的执行时间与每行代码的执行次数成正比，用T(n) &#x3D; O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。<br>2）特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。</p><h5 id="2-复杂度分析法则"><a href="#2-复杂度分析法则" class="headerlink" title="2.复杂度分析法则"></a>2.复杂度分析法则</h5><p>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</p><h4 id="四、常用的复杂度级别？"><a href="#四、常用的复杂度级别？" class="headerlink" title="四、常用的复杂度级别？"></a>四、常用的复杂度级别？</h4><p>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）<br>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）</p><h4 id="五、如何掌握好复杂度分析方法？"><a href="#五、如何掌握好复杂度分析方法？" class="headerlink" title="五、如何掌握好复杂度分析方法？"></a>五、如何掌握好复杂度分析方法？</h4><p>复杂度分析关键在于多练，所谓孰能生巧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？&quot;&gt;&lt;a href=&quot;#复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？&quot; class=&quot;headerlink&quot; title=&quot;复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>面试高频算法题</title>
    <link href="https://blog.elfred.top/posts/e62dd828.html"/>
    <id>https://blog.elfred.top/posts/e62dd828.html</id>
    <published>2021-03-21T09:35:00.000Z</published>
    <updated>2025-03-08T14:46:55.098Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><h3 id="36进制加法"><a href="#36进制加法" class="headerlink" title="36进制加法"></a>36进制加法</h3><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210321174103.png" alt="图片"></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>36进制由0-9，a-z，共36个字符表示。</p><p>要求按照加法规则计算出任意两个36进制正整数的和，如 1b + 2x &#x3D; 48  （解释：47+105&#x3D;152），1 + a &#x3D; b （解释：1+10 &#x3D; 11 ） , 1z + 1 &#x3D; 20 （解释：71 + 1 &#x3D; 72）</p><p>要求：不允许使用先将36进制数字整体转为10进制，相加后再转回为36进制的做法</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>跟<a href="https://leetcode-cn.com/problems/add-strings/">LC415. 字符串相加</a>做法类似，掌握十进制的大整数加法后，本题只需要注意将<code>10</code>变成<code>36</code>，以及36进制字符与数值的转换。这里使用<code>getChar(int n)</code>和<code>getInt(char c)</code>两个辅助函数来完成36进制字符与数值的转换。</p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add36Strings</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add36Strings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> num1.length(), n2 = num2.length();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                x = getInt(num1.charAt(i));</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                y = getInt(num2.charAt(j));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;</span><br><span class="line">            res.append(getChar(sum % <span class="number">36</span>));</span><br><span class="line">            carry = sum / <span class="number">36</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符转换为数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getInt</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数字转换为字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> <span class="title function_">getChar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>) (n + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>) (n - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Add36Strings</span> <span class="variable">add36Strings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Add36Strings</span>();</span><br><span class="line">        add36Strings.add36Strings(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        add36Strings.add36Strings(<span class="string">&quot;1b&quot;</span>, <span class="string">&quot;2x&quot;</span>);</span><br><span class="line">        add36Strings.add36Strings(<span class="string">&quot;1z&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;字节跳动&quot;&gt;&lt;a href=&quot;#字节跳动&quot; class=&quot;headerlink&quot; title=&quot;字节跳动&quot;&gt;&lt;/a&gt;字节跳动&lt;/h2&gt;&lt;h3 id=&quot;36进制加法&quot;&gt;&lt;a href=&quot;#36进制加法&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
    <category term="算法" scheme="https://blog.elfred.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>02讲</title>
    <link href="https://blog.elfred.top/posts/8f3bbd6e.html"/>
    <id>https://blog.elfred.top/posts/8f3bbd6e.html</id>
    <published>2021-03-17T14:10:00.000Z</published>
    <updated>2025-03-08T14:46:55.125Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><p>为了让你对数据结构和算法有个全面的认识，我画了一张图，里面几乎涵盖了所有数据结构和算法书籍中都会讲到的知识点。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210317221223.jpeg" alt="img"></p><h4 id="常用的数据结构与算法"><a href="#常用的数据结构与算法" class="headerlink" title="常用的数据结构与算法"></a>常用的数据结构与算法</h4><p>所以，结合我自己的学习心得，还有这些年的面试、开发经验，我总结了<strong>20个最常用的、最基础</strong>的数据结构与算法，<strong>不管是应付面试还是工作需要，只要集中精力逐一攻克这20个知识点就足够了。</strong></p><p>这里面有 10 个数据结构：<strong>数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树</strong>；10 个算法：<strong>递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</strong>。</p><p>在学习数据结构和算法的过程中，你也要注意，不要只是死记硬背，不要为了学习和学习，而是**要学习它的“来历” “自身的特点” “适合解决的问题” 以及 “实际的应用场景” ** 。</p><h3 id="一些可以让你事半功倍的学习技巧"><a href="#一些可以让你事半功倍的学习技巧" class="headerlink" title="一些可以让你事半功倍的学习技巧"></a>一些可以让你事半功倍的学习技巧</h3><h4 id="1-边学边练，适度刷题"><a href="#1-边学边练，适度刷题" class="headerlink" title="1.边学边练，适度刷题"></a>1.边学边练，适度刷题</h4><h4 id="2-多问、多思考、多互动"><a href="#2-多问、多思考、多互动" class="headerlink" title="2.多问、多思考、多互动"></a>2.多问、多思考、多互动</h4><h4 id="3-打怪升级学习法"><a href="#3-打怪升级学习法" class="headerlink" title="3.打怪升级学习法"></a>3.打怪升级学习法</h4><p><strong>学习的过程中，我们碰到最大的问题就是，坚持不下来。</strong></p><p>所以，<strong>我们在枯燥的学习过程中，也可以给自己设立一个切实可行的目标</strong>，就像打怪升级一样。</p><h4 id="4-只是需要沉淀，不要想试图一下子掌握所有"><a href="#4-只是需要沉淀，不要想试图一下子掌握所有" class="headerlink" title="4.只是需要沉淀，不要想试图一下子掌握所有"></a>4.只是需要沉淀，不要想试图一下子掌握所有</h4><p>在学习的过程中，一定会碰到“拦路虎”。如果哪个知识点没有怎么学懂，不要着急，这是正常的。因为，想听一遍、看一遍就把所有知识掌握，这肯定是不可能的。<strong>学习知识的过程是反复迭代、不断沉淀的过程</strong>。</p><h3 id="留言区优秀总结"><a href="#留言区优秀总结" class="headerlink" title="留言区优秀总结"></a>留言区优秀总结</h3><h4 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h4><p>数据结构指的是“一组数据的存储结构”，算法指的是“操作数据的一组方法”。<br>数据结构是为算法服务的，算法是要作用再特定的数据结构上的。</p><h4 id="学什么："><a href="#学什么：" class="headerlink" title="学什么："></a>学什么：</h4><ol><li>效率和资源消耗的度量衡–复杂度分析。</li><li>最常用、最基础的20个数据结构与算法，学习他们的：“来历”、“特点”、“适合解决什么问题”和“实际的应用场景”。10个数据结构：<strong>数组、链表、栈、队列、散列表、二叉树‘、堆、跳表、图、Trie树</strong>；10个算法： <strong>递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</strong>。</li></ol><h4 id="怎么学："><a href="#怎么学：" class="headerlink" title="怎么学："></a>怎么学：</h4><ol><li>边学边练，每周花 1~2 小时集中攻关三节课涉及的数据结构和算法，全部写出来。</li><li>主动提问、多思考、多互动。在留言区增加自己的留言。</li><li>自我激励，每次学习完做一篇学习笔记。</li><li>沉下心不要浮躁，先把这些基础的数据结构和算法，还有学习方法熟练掌握后，再追求更高层次。</li></ol><hr><p>flag：每篇文章必写学习笔记，每周必实现一次该周代码。</p><h3 id="学习工具"><a href="#学习工具" class="headerlink" title="学习工具"></a>学习工具</h3><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a><br>此网站可以将指定算法可视化，能方便理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h3&gt;&lt;h4 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink&quot; title=&quot;思维导图&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://blog.elfred.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>第二周</title>
    <link href="https://blog.elfred.top/posts/aae4713d.html"/>
    <id>https://blog.elfred.top/posts/aae4713d.html</id>
    <published>2021-03-16T05:59:00.000Z</published>
    <updated>2025-03-08T14:46:55.132Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.03.15-2021.03.21</p><h3 id="Leetcode-206-反转链表"><a href="#Leetcode-206-反转链表" class="headerlink" title="Leetcode 206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">Leetcode 206. 反转链表</a></h3><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="迭代法："><a href="#迭代法：" class="headerlink" title="迭代法："></a>迭代法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">         <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h5><p><strong>递归编程的三个条件</strong>：</p><ol><li>大问题拆成两个子问题</li><li>子问题求解方式和大问题一样</li><li>存在最小子问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">/* 递归终止条件：</span></span><br><span class="line"><span class="comment">         * 1. head==null链表为空，不需要反转</span></span><br><span class="line"><span class="comment">         * 2. head.next==null只剩一个节点的时候，也不需要反转</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leetcode-2-两数相加"><a href="#Leetcode-2-两数相加" class="headerlink" title="Leetcode 2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">Leetcode 2. 两数相加</a></h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210316155523.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果l1或l2不为空或者进位为1，则继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">            <span class="comment">// 不为空则sum加上这个值，同时指针往下走</span></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.03.15-2021.03.21&lt;/p&gt;
&lt;h3 id=&quot;Leetcode-206-反转链表&quot;&gt;&lt;a href=&quot;#Leetcode-206-反转链表&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 2</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>第一周</title>
    <link href="https://blog.elfred.top/posts/9af29de5.html"/>
    <id>https://blog.elfred.top/posts/9af29de5.html</id>
    <published>2021-03-08T05:59:11.000Z</published>
    <updated>2025-03-08T14:46:55.131Z</updated>
    
    <content type="html"><![CDATA[<hr><p>数据结构与算法之美每周打卡 2021.03.08-2021.03.14</p><h3 id="面试题-01-03-URL化"><a href="#面试题-01-03-URL化" class="headerlink" title="面试题 01.03. URL化"></a><a href="https://leetcode-cn.com/problems/string-to-url-lcci/">面试题 01.03. URL化</a></h3><p>URL化。编写一种方法，将字符串中的空格全部替换为<code>%20</code>。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用<code>Java</code>实现的话，请使用字符数组实现，以便直接在数组上操作。）</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;Mr John Smith    &quot;, 13</span><br><span class="line">输出：&quot;Mr%20John%20Smith&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;               &quot;, 5</span><br><span class="line">输出：&quot;%20%20%20%20%20&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>字符串长度在 [0, 500000] 范围内。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpaces</span><span class="params">(String S, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chs = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>, j = S.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从右往前走，把左边的的字符串拷贝到右边</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                chs[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                chs[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                chs[j--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chs[j--] = chs[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后取拷贝完之后的字符串，也就是j+1开始，字符串长度减去j+1</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chs, j + <span class="number">1</span>, S.length() - j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1528-重新排列字符串"><a href="#1528-重新排列字符串" class="headerlink" title="1528. 重新排列字符串"></a><a href="https://leetcode-cn.com/problems/shuffle-string/">1528. 重新排列字符串</a></h3><p>给你一个字符串 <code>s</code> 和一个 <strong>长度相同</strong> 的整数数组 <code>indices</code> 。</p><p>请你重新排列字符串 <code>s</code> ，其中第 <code>i</code> 个字符需要移动到 <code>indices[i]</code> 指示的位置。</p><p>返回重新排列后的字符串。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210322161725.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;codeleet&quot;, indices = [4,5,6,7,0,2,1,3]</span><br><span class="line">输出：&quot;leetcode&quot;</span><br><span class="line">解释：如图所示，&quot;codeleet&quot; 重新排列后变为 &quot;leetcode&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;, indices = [0,1,2]</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line">解释：重新排列后，每个字符都还留在原来的位置上。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aiohn&quot;, indices = [3,1,4,2,0]</span><br><span class="line">输出：&quot;nihao&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaiougrt&quot;, indices = [4,0,2,6,7,3,1,5]</span><br><span class="line">输出：&quot;arigatou&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;art&quot;, indices = [1,0,2]</span><br><span class="line">输出：&quot;rat&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>s.length == indices.length == n</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母。</li><li><code>0 &lt;= indices[i] &lt; n</code></li><li><code>indices</code> 的所有的值都是唯一的（也就是说，<code>indices</code> 是整数 <code>0</code> 到 <code>n - 1</code> 形成的一组排列）。</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">restoreString</span><span class="params">(String s, <span class="type">int</span>[] indices)</span> &#123;</span><br><span class="line">       <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            res[indices[i]] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;数据结构与算法之美每周打卡 2021.03.08-2021.03.14&lt;/p&gt;
&lt;h3 id=&quot;面试题-01-03-URL化&quot;&gt;&lt;a href=&quot;#面试题-01-03-URL化&quot; class=&quot;headerlink&quot; title=&quot;面试题 01.03. URL化&quot;</summary>
      
    
    
    
    
    <category term="数据结构与算法之美" scheme="https://blog.elfred.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    <category term="每周打卡" scheme="https://blog.elfred.top/tags/%E6%AF%8F%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>设计模式初探</title>
    <link href="https://blog.elfred.top/posts/74108e1f.html"/>
    <id>https://blog.elfred.top/posts/74108e1f.html</id>
    <published>2021-03-01T12:48:00.000Z</published>
    <updated>2025-03-08T14:46:55.112Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h3><p>面向对象的设计模式有七大基本原则：</p><ul><li>开闭原则（Open Closed Principle，OCP）</li><li>单一职责原则（Single Responsibility Principle, SRP）</li><li>里氏代换原则（Liskov Substitution Principle，LSP）</li><li>依赖倒转原则（Dependency Inversion Principle，DIP）</li><li>接口隔离原则（Interface Segregation Principle，ISP）</li><li>合成&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle，CARP）</li><li>最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）</li></ul><p>简单理解就是：<strong>开闭原则是总纲</strong>，它指导我们要对扩展开放，对修改关闭；单一职责原则指导我们实现类要职责单一；里氏替换原则指导我们不要破坏继承体系；依赖倒置原则指导我们要面向接口编程；接口隔离原则指导我们在设计接口的时候要精简单一；迪米特法则指导我们要降低耦合。</p><span id="more"></span><h3 id="工厂模式-Factory-Method-Pattern"><a href="#工厂模式-Factory-Method-Pattern" class="headerlink" title="工厂模式 Factory Method Pattern"></a>工厂模式 Factory Method Pattern</h3><p><strong>模式：工厂模式</strong></p><blockquote><p>工厂模式又细分为工厂方法模式和抽象工厂模式，本文主要介绍工厂方法模式。</p></blockquote><p><strong>模式定义</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法是一个类的实例化延迟到其子类。</p><p>工厂模式通用类图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210301205001.png" alt="图片"></p><p>我们通过一段较为通用的代码来解释如何使用工厂模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象的产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个具体的产品 (可以定义多个具体的产品)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;&#125;  <span class="comment">//具体的执行逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象的工厂</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">createProduct</span><span class="params">(Class&lt;T&gt; c)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的工厂可以生产出相应的产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">createProduct</span><span class="params">(Class c)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> (Product) Class.forName(c.getName()).newInstance();</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式 Strategy Pattern"></a>策略模式 Strategy Pattern</h3><p><strong>模式：策略模式</strong></p><p><strong>模式定义</strong>：定义一系列算法，将每个算法都封装起来，并且它们可以互换。策略模式是一种对象行为模式。</p><p>策略模式通用类图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210301205021.png" alt="图片"></p><p>我们通过一段比较通用的代码来解释怎么使用策略模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">strategyImplementation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的策略实现(可以定义多个具体的策略实现)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyImplementation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行策略A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装策略，屏蔽高层模块对策略、算法的直接访问，屏蔽可能存在的策略变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.strategyImplementation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式 State Pattern"></a>状态模式 State Pattern</h3><p><strong>模式：状态模式</strong></p><p><strong>模式定义</strong>：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。</p><p>状态模式的通用类图如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210301205104.webp" alt="图片"></p><p>对比策略模式的类型会发现和状态模式的类图很类似，但实际上有很大的区别，具体体现在concrete class上。策略模式通过Context产生唯一一个ConcreteStrategy作用于代码中，而状态模式则是通过context组织多个ConcreteState形成一个状态转换图来实现业务逻辑。接下来，我们通过一段通用代码来解释怎么使用状态模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个抽象的状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义状态A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span> &#123;&#125;  <span class="comment">//本状态下必须要处理的事情</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setCurrentState(Context.contreteStateB);  <span class="comment">//切换到状态B        </span></span><br><span class="line">        <span class="built_in">super</span>.context.handle2();  <span class="comment">//执行状态B的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义状态B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span> &#123;&#125;  <span class="comment">//本状态下必须要处理的事情，...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setCurrentState(Context.contreteStateA);  <span class="comment">//切换到状态A</span></span><br><span class="line">        <span class="built_in">super</span>.context.handle1();  <span class="comment">//执行状态A的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个上下文管理环境</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ConcreteStateA</span> <span class="variable">contreteStateA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStateA</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ConcreteStateB</span> <span class="variable">contreteStateB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStateB</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State CurrentState;</span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;<span class="keyword">return</span> CurrentState;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrentState</span><span class="params">(State currentState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.CurrentState = currentState;</span><br><span class="line">        <span class="built_in">this</span>.CurrentState.setContext(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span> &#123;<span class="built_in">this</span>.CurrentState.handle1();&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span> &#123;<span class="built_in">this</span>.CurrentState.handle2();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义client执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        context.setCurrentState(<span class="keyword">new</span> <span class="title class_">ContreteStateA</span>());</span><br><span class="line">        context.handle1();</span><br><span class="line">        context.handle2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="责任链模式-Chain-of-Responsibility-Pattern"><a href="#责任链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="责任链模式 Chain of Responsibility Pattern"></a>责任链模式 Chain of Responsibility Pattern</h3><p><strong>模式：责任链模式</strong></p><p><strong>模式定义</strong>：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p><p>责任链模式通用类图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210301214900.png" alt="图片"></p><p>我们通过一段比较通用的代码来解释如何使用责任链模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个抽象的handle</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;  <span class="comment">//指向下一个处理者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;  <span class="comment">//处理者能够处理的级别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求传递，注意final，子类不可重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level == request.getRequstLevel()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.echo(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.nextHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.nextHandler.handleMessage(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;已经到最尽头了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法，子类实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">echo</span><span class="params">(Request request)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个具体的handleA</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandleRuleA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandleRuleA</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">echo</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是处理者1,我正在处理A规则&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个具体的handleB</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandleRuleB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;&#125;  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HandleRuleA</span> <span class="variable">handleRuleA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandleRuleA</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">HandleRuleB</span> <span class="variable">handleRuleB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandleRuleB</span>(<span class="number">2</span>);</span><br><span class="line">        handleRuleA.setNextHandler(handleRuleB);  <span class="comment">//这是重点，将handleA和handleB串起来</span></span><br><span class="line">        handleRuleA.echo(<span class="keyword">new</span> <span class="title class_">Request</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>TODO</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://mp.weixin.qq.com/s/9gDGQhzRAL3pj35VAinZbQ">设计模式在外卖营销业务中的实践</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;设计模式原则&quot;&gt;&lt;a href=&quot;#设计模式原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式原则&quot;&gt;&lt;/a&gt;设计模式原则&lt;/h3&gt;&lt;p&gt;面向对象的设计模式有七大基本原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开闭原则（Open Closed Principle，OCP）&lt;/li&gt;
&lt;li&gt;单一职责原则（Single Responsibility Principle, SRP）&lt;/li&gt;
&lt;li&gt;里氏代换原则（Liskov Substitution Principle，LSP）&lt;/li&gt;
&lt;li&gt;依赖倒转原则（Dependency Inversion Principle，DIP）&lt;/li&gt;
&lt;li&gt;接口隔离原则（Interface Segregation Principle，ISP）&lt;/li&gt;
&lt;li&gt;合成&amp;#x2F;聚合复用原则（Composite&amp;#x2F;Aggregate Reuse Principle，CARP）&lt;/li&gt;
&lt;li&gt;最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单理解就是：&lt;strong&gt;开闭原则是总纲&lt;/strong&gt;，它指导我们要对扩展开放，对修改关闭；单一职责原则指导我们实现类要职责单一；里氏替换原则指导我们不要破坏继承体系；依赖倒置原则指导我们要面向接口编程；接口隔离原则指导我们在设计接口的时候要精简单一；迪米特法则指导我们要降低耦合。&lt;/p&gt;</summary>
    
    
    
    
    <category term="设计模式" scheme="https://blog.elfred.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法思想掌握</title>
    <link href="https://blog.elfred.top/posts/9680e536.html"/>
    <id>https://blog.elfred.top/posts/9680e536.html</id>
    <published>2021-02-27T04:36:00.000Z</published>
    <updated>2025-03-08T14:46:55.109Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="395-至少有K个重复字符的最长子串"><a href="#395-至少有K个重复字符的最长子串" class="headerlink" title="395. 至少有K个重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有K个重复字符的最长子串</a></h3><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaabb&quot;, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ababbc&quot;, k = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子串为 &quot;ababb&quot; ，其中 &#x27;a&#x27; 重复了 2 次， &#x27;b&#x27; 重复了 3 次。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s</code> 仅由小写英文字母组成</li><li><code>1 &lt;= k &lt;= 10^5</code></li></ul><span id="more"></span><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题要求的一个最长的子字符串的长度，该子字符串中每个字符出现的次数都最少为 kk。</p><p>求最长子字符串&#x2F;区间的这类题一般可以用滑动窗口来做，但是本题滑动窗口的代码不好写，我改用递归。也借本题来帮助大家理解递归。</p><ul><li><strong>重点：我们在调用递归函数的时候，把递归函数当做普通函数（黑箱）来调用，即明白该函数的输入输出是什么，而不用管此函数内部在做什么。</strong></li></ul><p>下面是详细讲解。</p><ol><li><strong>递归最基本的是记住递归函数的含义（务必牢记函数定义）</strong>：本题的 <code>longestSubstring(s, k)</code> 函数表示的就是题意，即求一个最长的子字符串的长度，该子字符串中每个字符出现的次数都最少为 k。函数入参 s 是表示源字符串；k 是限制条件，即子字符串中每个字符最少出现的次数；函数返回结果是满足题意的最长子字符串长度。</li><li><strong>递归的终止条件（能直接写出的最简单 case）</strong>：如果字符串 s 的长度少于 k，那么一定不存在满足题意的子字符串，返回 0；</li><li><strong>调用递归（重点）</strong>：如果一个字符 c 在 s 中出现的次数少于 k 次，那么 s 中所有的包含 c 的子字符串都不能满足题意。所以，应该在 s 的所有不包含 c 的子字符串中继续寻找结果：把 s 按照 c 分割（分割后每个子串都不包含 c），得到很多子字符串 t；<strong>下一步要求 t作为源字符串的时候，它的最长的满足题意的子字符串长度</strong>（到现在为止，我们把大问题分割为了小问题(s → t)）。此时我们发现，恰好已经定义了函数 <code>longestSubstring(s, k)</code> 就是来解决这个问题的！所以直接把 <code>longestSubstring(s, k)</code> 函数拿来用，于是形成了递归。</li><li>未进入递归时的返回结果：如果 s 中的每个字符出现的次数都大于 k 次，那么 s 就是我们要求的字符串，直接返回该字符串的长度。</li></ol><p>总之，通过上面的分析，我们看出了：<strong>我们不是为了递归而递归</strong>。而是因为我们把大问题拆解成了小问题，恰好有函数可以解决小问题，所以直接用这个函数。由于这个函数正好是本身，所以我们把此现象叫做递归。小问题是原因，递归是结果。而<strong>递归函数到底怎么一层层展开与终止的，不要用大脑去想</strong>，这是计算机干的事。我们只用把递归函数当做一个能解决问题的黑箱就够了，把更多的注意力放在拆解子问题、递归终止条件、递归函数的正确性上来。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; counter = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            counter.put(s.charAt(i), counter.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : counter.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter.get(c) &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (String t : s.split(String.valueOf(c))) &#123;</span><br><span class="line">                    res = Math.max(res, longestSubstring(t, k));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h3><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</p><p>返回同样按升序排列的结果链表。</p><p> <strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210326100625.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210326100625.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>题意：在一个<strong>有序</strong>链表中，如果一个节点的值出现不止一次，那么把这个节点删除掉。</p><p>重点：<strong>有序链表</strong>，所以，一个节点的值出现不止一次，那么它们必相邻。</p><h5 id="1-递归函数定义"><a href="#1-递归函数定义" class="headerlink" title="1. 递归函数定义"></a>1. 递归函数定义</h5><p><strong>递归最基本的是要明白递归函数的定义！</strong> 我反复强调过这一点。</p><p>递归函数直接使用题目给出的函数 <code>deleteDuplicates(head)</code> ，它的含义是 删除以 <code>head</code> 作为开头的有序链表中，值出现重复的节点。</p><h5 id="2-递归终止条件"><a href="#2-递归终止条件" class="headerlink" title="2. 递归终止条件"></a>2. 递归终止条件</h5><p>终止条件就是能想到的基本的、不用继续递归处理的case。</p><ul><li>如果 <code>head</code> 为空，那么肯定没有值出现重复的节点，直接返回 head；</li><li>如果 <code>head.next</code> 为空，那么说明链表中只有一个节点，也没有值出现重复的节点，也直接返回 head。</li></ul><h5 id="3-递归调用"><a href="#3-递归调用" class="headerlink" title="3. 递归调用"></a>3. 递归调用</h5><p>什么时候需要递归呢？我们想一下这两种情况：</p><ul><li>如果 <code>head.val != head.next.val</code> ，说明头节点的值<strong>不等于</strong>下一个节点的值，所以当前的 <code>head</code> 节点必须保留；但是 head.next 节点要不要保留呢？我们还不知道，需要对 <code>head.next</code> 进行递归，即对<code>head.next</code> 作为头节点的链表，去除值重复的节点。所以 <code>head.next = deleteDuplicates(head.next)</code>.</li><li>如果 <code>head.val == head.next.val</code> ，说明头节点的值<strong>等于</strong>下一个节点的值，所以当前的 <code>head</code> 节点必须删除；但是 head.next 节点要不要删除呢？我们还不知道，需要一直向后遍历寻找到与 head.val 不等的节点。与 head.val 相等的这一段链表都要删除，因此返回 <code>deleteDuplicates(move);</code></li></ul><h5 id="4-返回结果"><a href="#4-返回结果" class="headerlink" title="4. 返回结果"></a>4. 返回结果</h5><p>题目让我们返回删除了值重复的节点后剩余的链表，结合上面两种递归调用的情况。</p><ul><li>如果 <code>head.val != head.next.val</code> ，头结点需要保留，因此返回的是 <code>head</code>；</li><li>如果 <code>head.val == head.next.val</code> ，头结点需要删除，需要返回的是<code>deleteDuplicates(move);</code>。</li></ul><p>对链表 <code>1 -&gt; 2 -&gt; 2 -&gt; 3</code> 递归的过程如下。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210326103612.jpeg" alt="82.001.jpeg"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 没有节点或者只有一个节点，必然没有重复元素</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点和下一个节点，值不同，则head的值是需要保留的，对head.next继续递归</span></span><br><span class="line">        <span class="keyword">if</span> (head.val != head.next.val) &#123;</span><br><span class="line">            head.next = deleteDuplicates(head.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点与下一个节点的值重复了，重复的值都不能要。</span></span><br><span class="line">            <span class="comment">// 一直往下找，找到不重复的节点。返回对不重复节点的递归结果</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">move</span> <span class="operator">=</span> head.next;</span><br><span class="line">            <span class="keyword">while</span> (move != <span class="literal">null</span> &amp;&amp; head.val == move.val) &#123;</span><br><span class="line">                move = move.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(move);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h3><p>给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。</p><p>实现 NumArray 类：</p><ul><li>NumArray(int[] nums) 使用数组 nums 初始化对象</li><li>int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])）</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</li><li>-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li><li>0 &lt;&#x3D; i &lt;&#x3D; j &lt; nums.length</li><li>最多调用 10^4 次 sumRange 方法</li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>preSum（前缀和）</strong><br>今天这个题目让我们求一个区间 [i, j] 内的和，求区间和可以用 preSum 来做。</p><p>preSum 方法能快速计算指定区间段 i - j 的元素之和。它的计算方法是从左向右遍历数组，当遍历到数组的 i 位置时，preSum 表示 i 位置左边的元素之和。</p><p>假设数组长度为 N，我们定义一个长度为 N+1 的 preSum 数组，<strong>preSum[i] 表示该元素左边所有元素之和（不包含 i 元素）</strong>。然后遍历一次数组，累加区间 [0, i)范围内的元素，可以得到 preSum 数组。</p><p>求 <code>preSum</code> 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="built_in">len</span>(nums)</span><br><span class="line">preSum = <span class="built_in">range</span>(N + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    preSum[i + <span class="number">1</span>] = preSum[i] + nums[i]</span><br><span class="line"><span class="built_in">print</span>(preSum)</span><br></pre></td></tr></table></figure><p>利用 preSum 数组，可以在 O(1) 的时间内快速求出 nums 任意区间 [i, j] (两端都包含) 的各元素之和。</p><p><code>sum(i, j) = preSum[j + 1] - preSum[i]</code></p><p>对于本题，可以在 NumArray 类的构造函数的里面，求数组每个位置的 preSum；当计算sumRange(i, j)的时候直接返回 <code>preSum[j + 1] - preSum[i]</code> 可以得到区间和。</p><p>下面以数组 <code>[1, 12, -5, -6, 50, 3]</code> 为例，展示了求 preSum 的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210301102603.gif" alt="303，preSum.gif"></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[j + <span class="number">1</span>] - preSum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：构造函数的时间复杂度是 O(N), sumRange 函数调用的时间复杂度是 O(1)</li><li>空间复杂度：O(N)。</li></ul><h2 id="单调栈-Monotonic-Stack"><a href="#单调栈-Monotonic-Stack" class="headerlink" title="单调栈 Monotonic Stack"></a>单调栈 Monotonic Stack</h2><h3 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>今天题目的两个重点：</p><ul><li>如何求下一个更大的元素</li><li>如何实现循环数组</li></ul><h5 id="1-如何求下一个更大的元素"><a href="#1-如何求下一个更大的元素" class="headerlink" title="1. 如何求下一个更大的元素"></a>1. 如何求下一个更大的元素</h5><p>本题如果暴力求解，对于每个元素都向后去寻找比它更大的元素，那么时间复杂度 *O(N^2)*会超时。必须想办法优化。</p><p>我们注意到，暴力解法中，如果数组的前半部分是单调不增的，那么会有很大的计算资源的浪费。比如说 <code>[6,5,4,3,8]</code>，对于前面的 <code>[6,5,4,3]</code> 等数字都需要向后遍历，当寻找到元素 8 时才找到了比自己大的元素；而如果已知元素 6 向后找到元素 8 才找到了比自己的大的数字，那么对于元素 <code>[5,4,3]</code> 来说，它们都比元素 6 更小，所以比它们更大的元素一定是元素 8，不需要单独遍历对 <code>[5,4,3]</code> 向后遍历一次！</p><p>根据上面的分析可知，<strong>可以遍历一次数组，如果元素是单调递减的（则他们的「下一个更大元素」相同），我们就把这些元素保存，直到找到一个较大的元素；把该较大元素逐一跟保存了的元素比较，如果该元素更大，那么它就是前面元素的「下一个更大元素」</strong>。</p><p>在实现上，我们可以使用「<strong>单调栈</strong>」来实现，<strong>单调栈</strong>是说栈里面的元素从栈底到栈顶是<strong>单调递增</strong>或者<strong>单调递减</strong>的（类似于汉诺塔）。</p><p>本题应该用个「单调递减栈」来实现。</p><p>建立「单调递减栈」，并对原数组遍历一次：</p><ul><li>如果栈为空，则把当前元素放入栈内；</li><li>如果栈不为空，则需要判断当前元素和栈顶元素的大小：<ul><li>如果当前元素比栈顶元素大：说明当前元素是前面一些元素的「下一个更大元素」，则逐个弹出栈顶元素，直到当前元素比栈顶元素小为止。</li><li>如果当前元素比栈顶元素小：说明当前元素的「下一个更大元素」与栈顶元素相同，则把当前元素入栈。</li></ul></li></ul><p>可以用下面的动图来帮助理解：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210306142911.gif" alt="单调栈"></p><h5 id="2-如何实现循环数组"><a href="#2-如何实现循环数组" class="headerlink" title="2. 如何实现循环数组"></a>2. 如何实现循环数组</h5><p>题目说给出的数组是循环数组，何为循环数组？就是说数组的最后一个元素下一个元素是数组的第一个元素，形状类似于「环」。</p><ul><li>一种实现方式是，把数组复制一份到数组末尾，这样虽然不是严格的循环数组，但是对于本题已经足够了，因为本题对数组最多遍历两次。</li><li>另一个常见的实现方式是，使用取模运算 *%*可以把下标 <em>i</em> 映射到数组 <em>nums</em> 长度的 <em>0 - N</em> 内。</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>栈里面需要保存元素在数组中的下标，而不是具体的数字。因为需要根据下标修改结果数组 <code>res</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()]) &#123;</span><br><span class="line">                res[stack.pop()] = nums[i % n];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i % n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：*O(N)*，遍历了两次数组；</li><li>空间复杂度：*O(N)*，使用了额外空间「单调栈」，最坏情况下，栈内会保存数组的所有元素。</li></ul><h2 id="寻找下一个更大的元素需要移动的步数"><a href="#寻找下一个更大的元素需要移动的步数" class="headerlink" title="寻找下一个更大的元素需要移动的步数"></a><a href="https://zhuanlan.zhihu.com/p/26465701">寻找下一个更大的元素需要移动的步数</a></h2><p>给定一个数组，返回长度相同的数组。返回的数组的第i个位置的值应当是，对于原数组中的第i个元素，至少往右走多少步，才能遇到一个比自己大的元素（如果之后没有比自己大的元素，或者已经是最后一个元素，则在返回数组的对应位置放上-1）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [5,3,1,2,4]</span><br><span class="line">输出: [-1,3,1,1,-1]</span><br><span class="line">解释: 5找不到比它更大的所以是-1，3移动3位找到第一个比它大的4，以此类推</span><br></pre></td></tr></table></figure><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们维护这样一个单调递减的stack，stack内部存的是原数组的每个index。每当我们遇到一个比当前栈顶所对应的数（就是nums[stack.peek()]）大的数的时候，我们就遇到了一个“大数“。这个”大数“比它之前多少个数大我们不知道，但是至少比当前栈顶所对应的数大。我们弹出栈内所有对应数比这个数小的栈内元素，并更新它们在返回数组中对应位置的值。因为这个栈本身的单调性，当我们栈顶元素所对应的数比这个元素大的时候，我们可以保证，栈内所有元素都比这个元素大。对于每一个元素，当它出栈的时候，说明它遇到了自己的next greater element，我们也就要更新return数组中的对应位置的值。如果一个元素一直不曾出栈，那么说明不存在next greater element，我们也就不用更新return数组了。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] nextExceed(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">     <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">     <span class="comment">// 填充-1</span></span><br><span class="line">     Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">     Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">         <span class="comment">// 如果栈不为空并且当前元素大于栈顶元素</span></span><br><span class="line">         <span class="comment">// 弹出栈中比当前小的元素，并更新它们在返回数组中对应位置的值（移动的步数）</span></span><br><span class="line">         <span class="comment">// 栈里面需要保存元素在数组中的下标，而不是具体的数字。因为需要根据下标修改结果数组</span></span><br><span class="line">         <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i] &gt; nums[stack.peek()]) &#123;          </span><br><span class="line">             res[stack.peek()] = i - stack.peek();</span><br><span class="line">             stack.pop();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 下标入栈</span></span><br><span class="line">         stack.push(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;h3 id=&quot;395-至少有K个重复字符的最长子串&quot;&gt;&lt;a href=&quot;#395-至少有K个重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;395. 至少有K个重复字符的最长子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/&quot;&gt;395. 至少有K个重复字符的最长子串&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你找出 &lt;code&gt;s&lt;/code&gt; 中的最长子串， 要求该子串中的每一字符出现次数都不少于 &lt;code&gt;k&lt;/code&gt; 。返回这一子串的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &amp;quot;aaabb&amp;quot;, k = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最长子串为 &amp;quot;aaa&amp;quot; ，其中 &amp;#x27;a&amp;#x27; 重复了 3 次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &amp;quot;ababbc&amp;quot;, k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最长子串为 &amp;quot;ababb&amp;quot; ，其中 &amp;#x27;a&amp;#x27; 重复了 2 次， &amp;#x27;b&amp;#x27; 重复了 3 次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt; &lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 仅由小写英文字母组成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= k &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="https://blog.elfred.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.elfred.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>你需要了解这14种编程面试模式</title>
    <link href="https://blog.elfred.top/posts/d9dc84f3.html"/>
    <id>https://blog.elfred.top/posts/d9dc84f3.html</id>
    <published>2021-02-25T01:50:00.000Z</published>
    <updated>2025-03-08T14:46:55.111Z</updated>
    
    <content type="html"><![CDATA[<hr><p>作者：Fahim ul Haq</p><p>机器之心编译</p><p>参与：Panda</p><h1 id="解题套路"><a href="#解题套路" class="headerlink" title="解题套路"></a>解题套路</h1><p>咱们在面试程序员岗位时往往需要经历一个编程面试过程，雇主会借此考验面试者的技术实力。</p><p>然而，这些技术问题有时候却和我们的实际工作并无太大关系，也由此可能给我们的编程面试准备阶段带来很大的压力。</p><p>曾在 Facebook 和微软工作过的 Educative.io 创始人 Fahim ul Haq 近日发文总结了编程面试所遇到的问题的 14 种最常见的模式，也许能帮你看清各种编程面试问题「背后的真相」。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100733.png" alt="图片"></p><p>对很多开发者来说，编程工作的面试准备很容易让人焦虑。面试要涉及的东西实在太多，其中很多还往往与开发者的日常工作无关，只会额外增添压力。</p><p>这种现状导致了一个后果：现在的开发者往往需要花费数周时间在 LeetCode 等网站上了解综合数百个问题。</p><p>与我谈过的开发者在面试前的一个常见焦虑问题是：<strong>我是否已经解决过足够多的实际问题？我本可以做到更多吗？</strong></p><p>这就是我想要帮助开发者了解每个问题背后的底层模式的原因——这样他们就不必担忧解决数百个问题以及被 LeetCode 整得疲惫不堪了。</p><p>如果你理解面试的通用模式，你就可以将其用作模板，从而解决各种层级的稍有不同的问题。</p><p>这里我将列出最常见的 14 种模式，它们可被用于解决任何编程面试问题。</p><p>另外我还会说明如何识别每种模式，并会为每种模式提供一些问题示例。</p><p>这些内容都只是蜻蜓点水——<strong>我强烈建议你看看课程《Grokking the Coding Interview: Patterns for Coding Questions》，里面提供了全面的解释、示例和编程实践</strong>。</p><p>下面的模式说明假设你已经知悉了数据结构。如果你还不了解，那需要补充一下知识点哦。</p><p>我们今天将说明以下 14 种模式：</p><blockquote><ul><li>1．滑动窗口</li><li>2．二指针或迭代器</li><li>3．快速和慢速指针或迭代器</li><li>4．合并区间</li><li>5．循环排序</li><li>6．原地反转链表</li><li>7．树的宽度优先搜索（Tree BFS）</li><li>8．树的深度优先搜索（Tree DFS）</li><li>9．Two Heaps</li><li>10．子集</li><li>11．经过修改的二叉搜索</li><li>12．前 K 个元素</li><li>13．K 路合并</li><li>14．拓扑排序</li></ul></blockquote><p>我们开始吧！</p><span id="more"></span><h1 id="1．滑动窗口"><a href="#1．滑动窗口" class="headerlink" title="1．滑动窗口"></a>1．滑动窗口</h1><p>滑动窗口模式是用于在给定数组或链表的特定窗口大小上执行所需的操作，比如寻找包含所有 1 的最长子数组。</p><p>从第一个元素开始滑动窗口并逐个元素地向右滑，并根据你所求解的问题调整窗口的长度。</p><p>在某些情况下窗口大小会保持恒定，在其它情况下窗口大小会增大或减小。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100646.png" alt="图片"></p><p>下面是一些你可以用来确定给定问题可能需要滑动窗口的方法：</p><blockquote><ul><li>问题的输入是一种线性数据结构，比如链表、数组或字符串</li><li>你被要求查找最长&#x2F;最短的子字符串、子数组或所需的值</li></ul></blockquote><p>你可以使用滑动窗口模式处理的常见问题：</p><blockquote><ul><li>大小为 K 的子数组的最大和（简单）</li><li>带有 K 个不同字符的最长子字符串（中等）</li><li>寻找字符相同但排序不一样的字符串（困难）</li></ul></blockquote><h1 id="2．二指针或迭代器"><a href="#2．二指针或迭代器" class="headerlink" title="2．二指针或迭代器"></a>2．二指针或迭代器</h1><p>二指针（Two Pointers）是这样一种模式：</p><p>两个指针以一前一后的模式在数据结构中迭代，直到一个或两个指针达到某种特定条件。</p><p>二指针通常在排序数组或链表中搜索配对时很有用：比如当你必须将一个数组的每个元素与其它元素做比较时。</p><p>二指针是很有用的，因为如果只有一个指针，你必须继续在数组中循环回来才能找到答案。</p><p>这种使用单个迭代器进行来回在时间和空间复杂度上都很低效——这个概念被称为「渐进分析（asymptotic analysis）」。</p><p>尽管使用 1 个指针进行暴力搜索或简单普通的解决方案也有效果，但这会沿 O(n²) 线得到一些东西。在很多情况中，二指针有助于你寻找有更好空间或运行时间复杂度的解决方案。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100642.webp" alt="图片"></p><p>用于识别使用二指针的时机的方法：</p><blockquote><ul><li>可用于你要处理排序数组（或链接列表）并需要查找满足某些约束的一组元素的问题</li><li>数组中的元素集是配对、三元组甚至子数组</li></ul></blockquote><p>下面是一些满足二指针模式的问题：</p><blockquote><ul><li>求一个排序数组的平方（简单）</li><li>求总和为零的三元组（中等）</li><li>比较包含回退（backspace）的字符串（中等）</li></ul></blockquote><h1 id="3．快速和慢速指针"><a href="#3．快速和慢速指针" class="headerlink" title="3．快速和慢速指针"></a>3．快速和慢速指针</h1><p>快速和慢速指针方法也被称为 Hare &amp; Tortoise 算法，该算法会使用两个在数组（或序列&#x2F;链表）中以不同速度移动的指针。该方法在处理循环链表或数组时非常有用。</p><p>通过以不同的速度进行移动（比如在一个循环链表中），该算法证明这两个指针注定会相遇。只要这两个指针在同一个循环中，快速指针就会追赶上慢速指针。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100638.webp" alt="图片"></p><p>如何判别使用快速和慢速模式的时机？</p><blockquote><ul><li>处理链表或数组中的循环的问题</li><li>当你需要知道特定元素的位置或链表的总长度时</li></ul></blockquote><p>何时应该优先选择这种方法，而不是上面提到的二指针方法？</p><blockquote><ul><li>有些情况不适合使用二指针方法，比如在不能反向移动的单链接链表中。使用快速和慢速模式的一个案例是当你想要确定一个链表是否为回文（palindrome）时。</li></ul></blockquote><p>下面是一些满足快速和慢速指针模式的问题：</p><blockquote><ul><li>链表循环（简单）</li><li>回文链表（中等）</li><li>环形数组中的循环（困难）</li></ul></blockquote><h1 id="4．合并区间"><a href="#4．合并区间" class="headerlink" title="4．合并区间"></a>4．合并区间</h1><p>合并区间模式是一种处理重叠区间的有效技术。</p><p>在很多涉及区间的问题中，你既需要找到重叠的区间，也需要在这些区间重叠时合并它们。该模式的工作方式为：</p><p>给定两个区间（a 和 b），这两个区间有 6 种不同的互相关联的方式：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100634.webp" alt="图片"></p><p>理解并识别这六种情况有助于你求解范围广泛的问题，从插入区间到优化区间合并等。</p><p>那么如何确定何时该使用合并区间模式呢？</p><blockquote><ul><li>如果你被要求得到一个仅含互斥区间的列表</li><li>如果你听到了术语「重叠区间（overlapping intervals）」</li></ul></blockquote><p>合并区间模式的问题：</p><blockquote><ul><li>区间交叉（中等）</li><li>最大 CPU 负载（困难）</li></ul></blockquote><h1 id="5-循环排序"><a href="#5-循环排序" class="headerlink" title="5. 循环排序"></a>5. 循环排序</h1><p>这一模式描述了一种有趣的方法，处理的是涉及包含给定范围内数值的数组的问题。</p><p>循环排序模式一次会在数组上迭代一个数值，如果所迭代的当前数值不在正确的索引处，就将其与其正确索引处的数值交换。</p><p>你可以尝试替换其正确索引处的数值，但这会带来 O(n^2) 的复杂度，这不是最优的，因此要用循环排序模式。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100619.webp" alt="图片"></p><p>如何识别这种模式？</p><blockquote><ul><li>涉及数值在给定范围内的排序数组的问题</li><li>如果问题要求你在一个排序&#x2F;旋转的数组中找到缺失值&#x2F;重复值&#x2F;最小值</li></ul></blockquote><p>循环排序模式的问题：</p><blockquote><ul><li>找到缺失值（简单）</li><li>找到最小的缺失的正数值（中等）</li></ul></blockquote><h1 id="6-原地反转链表"><a href="#6-原地反转链表" class="headerlink" title="6. 原地反转链表"></a>6. 原地反转链表</h1><p>在很多问题中，你可能会被要求反转一个链表中一组节点之间的链接。</p><p>通常而言，你需要原地完成这一任务，即使用已有的节点对象且不占用额外的内存。这就是这个模式的用武之地。</p><p>该模式会从一个指向链表头的变量（current）开始一次反转一个节点，然后一个变量（previous）将指向已经处理过的前一个节点。</p><p>以锁步的方式，在移动到下一个节点之前将其指向前一个节点，可实现对当前节点的反转。</p><p>另外，也将更新变量「previous」，使其总是指向已经处理过的前一个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225102126.webp" alt="图片"></p><p>如何识别使用该模式的时机：</p><blockquote><ul><li>如果你被要求在不使用额外内存的前提下反转一个链表</li></ul></blockquote><p>原地反转链表模式的问题：</p><blockquote><ul><li>反转一个子列表（中等）</li><li>反转每个 K 个元素的子列表（中等）</li></ul></blockquote><h1 id="7．树的宽度优先搜索（Tree-BFS）"><a href="#7．树的宽度优先搜索（Tree-BFS）" class="headerlink" title="7．树的宽度优先搜索（Tree BFS）"></a>7．树的宽度优先搜索（Tree BFS）</h1><p>该模式基于宽度优先搜索（BFS）技术，可遍历一个树并使用一个队列来跟踪一个层级的所有节点，之后再跳转到下一个层级。</p><p>任何涉及到以逐层级方式遍历树的问题都可以使用这种方法有效解决。</p><p>Tree BFS 模式的工作方式是：将根节点推至队列，然后连续迭代知道队列为空。在每次迭代中，我们移除队列头部的节点并「访问」该节点。在移除了队列中的每个节点之后，我们还将其所有子节点插入到队列中。</p><p>如何识别 Tree BFS 模式：</p><blockquote><ul><li>如果你被要求以逐层级方式遍历（或按层级顺序遍历）一个树</li></ul></blockquote><p>Tree BFS 模式的问题：</p><blockquote><ul><li>二叉树层级顺序遍历（简单）</li><li>之字型遍历（Zigzag Traversal）（中等）</li></ul></blockquote><h1 id="8．树的深度优先搜索（Tree-DFS）"><a href="#8．树的深度优先搜索（Tree-DFS）" class="headerlink" title="8．树的深度优先搜索（Tree DFS）"></a>8．树的深度优先搜索（Tree DFS）</h1><p>Tree DFS 是基于深度优先搜索（DFS）技术来遍历树。</p><p>你可以使用递归（或该迭代方法的技术栈）来在遍历期间保持对所有之前的（父）节点的跟踪。</p><p>Tree DFS 模式的工作方式是从树的根部开始，如果这个节点不是一个叶节点，则需要做两件事：</p><blockquote><ul><li>1．决定现在是处理当前的节点（pre-order），或是在处理两个子节点之间（in-order），还是在处理两个子节点之后（post-order）</li><li>2．为当前节点的两个子节点执行两次递归调用以处理它们</li></ul></blockquote><p>如何识别 Tree DFS 模式：</p><blockquote><ul><li>如果你被要求用 in-order、pre-order 或 post-order DFS 来遍历一个树</li><li>如果问题需要搜索其中节点更接近叶节点的东西</li></ul></blockquote><p>Tree DFS 模式的问题：</p><blockquote><ul><li>路径数量之和（中等）</li><li>一个和的所有路径（中等）</li></ul></blockquote><h1 id="9．Two-Heaps"><a href="#9．Two-Heaps" class="headerlink" title="9．Two Heaps"></a>9．Two Heaps</h1><p>在很多问题中，我们要将给定的一组元素分为两部分。</p><p>为了求解这个问题，我们感兴趣的是了解一部分的最小元素以及另一部分的最大元素。这一模式是求解这类问题的一种有效方法。</p><p>该模式要使用两个堆（heap）：一个用于寻找最小元素的 Min Heap 和一个用于寻找最大元素的 Max Heap。</p><p>该模式的工作方式是：</p><p>先将前一半的数值存储到 Max Heap，这是由于你要寻找前一半中的最大数值。然后再将另一半存储到 Min Heap，因为你要寻找第二半的最小数值。在任何时候，当前数值列表的中间值都可以根据这两个 heap 的顶部元素计算得到。</p><p>识别 Two Heaps 模式的方法：</p><blockquote><ul><li>在优先级队列、调度等场景中有用</li><li>如果问题说你需要找到一个集合的最小&#x2F;最大&#x2F;中间元素</li><li>有时候可用于具有二叉树数据结构的问题</li></ul></blockquote><p>Two Heaps 模式的问题：</p><blockquote><ul><li>查找一个数值流的中间值（中等）</li></ul></blockquote><h1 id="10．子集"><a href="#10．子集" class="headerlink" title="10．子集"></a>10．子集</h1><p>很多编程面试问题都涉及到处理给定元素集合的排列和组合。</p><p>子集（Subsets）模式描述了一种用于有效处理所有这些问题的宽度优先搜索（BFS）方法。</p><p>该模式看起来是这样：</p><p>给定一个集合 [1, 5, 3]</p><blockquote><ul><li>1． 从一个空集开始：[[]]</li><li>2．向所有已有子集添加第一个数 (1)，从而创造新的子集：[[], [1]]</li><li>3．向所有已有子集添加第二个数 (5)：[[], [1], [5], [1,5]]</li><li>4．向所有已有子集添加第三个数 (3)：[[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]]</li></ul></blockquote><p>下面是这种子集模式的一种视觉表示：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100608.webp" alt="图片"></p><p>如何识别子集模式：</p><blockquote><ul><li>你需要找到给定集合的组合或排列的问题</li></ul></blockquote><p>子集模式的问题：</p><blockquote><ul><li>带有重复项的子集（简单）</li><li>通过改变大小写的字符串排列（中等）</li></ul></blockquote><h1 id="11．经过修改的二叉搜索"><a href="#11．经过修改的二叉搜索" class="headerlink" title="11．经过修改的二叉搜索"></a>11．经过修改的二叉搜索</h1><p>只要给定了排序数组、链表或矩阵，并要求寻找一个特定元素，你可以使用的最佳算法就是二叉搜索。</p><p>这一模式描述了一种用于处理所有涉及二叉搜索的问题的有效方法。</p><p>对于一个升序的集合，该模式看起来是这样的：</p><blockquote><ul><li>1．首先，找到起点和终点的中间位置。<br>寻找中间位置的一种简单方法是：middle &#x3D; (start + end) &#x2F; 2。<br>但这很有可能造成整数溢出，所以推荐你这样表示中间位置：middle &#x3D; start + (end—start) &#x2F; 2。</li><li>2．如果键值（key）等于中间索引处的值，那么返回这个中间位置。</li><li>3．如果键值不等于中间索引处的值：</li><li>4．检查 key &lt; arr[middle] 是否成立。如果成立，将搜索约简到 end &#x3D; middle—1【换行】5．检查 key &gt; arr[middle] 是否成立。如果成立，将搜索约简到 end &#x3D; middle + 1</li></ul></blockquote><p>下面给出了这种经过修改的二叉搜索模式的视觉表示：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100608.webp" alt="图片"></p><p>经过修改的二叉搜索模式的问题：</p><blockquote><ul><li>与顺序无关的二叉搜索（简单）</li><li>在经过排序的无限数组中搜索（中等）</li></ul></blockquote><h1 id="12-前-K-个元素"><a href="#12-前-K-个元素" class="headerlink" title="12. 前 K 个元素"></a>12. 前 K 个元素</h1><p>任何要求我们找到一个给定集合中前面的&#x2F;最小的&#x2F;最常出现的 K 的元素的问题都在这一模式的范围内。</p><p>跟踪 K 个元素的最佳的数据结构是 Heap。</p><p>这一模式会使用 Heap 来求解多个一次性处理一个给定元素集中 K 个元素的问题。</p><p>该模式是这样工作的：</p><blockquote><ul><li>1．根据问题的不同，将 K 个元素插入到 min-heap 或 max-heap 中</li><li>2．迭代处理剩余的数，如果你找到一个比 heap 中数更大的数，那么就移除那个数并插入这个更大的数</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100602.webp" alt="图片"></p><p>这里无需排序算法，因为 heap 将为你跟踪这些元素。</p><p>如何识别前 K 个元素模式：</p><blockquote><ul><li>如果你被要求寻找一个给定集合中前面的&#x2F;最小的&#x2F;最常出现的 K 的元素</li><li>如果你被要求对一个数值进行排序以找到一个确定元素</li></ul></blockquote><p>前 K 个元素模式的问题：</p><blockquote><ul><li>前面的 K 个数（简单）</li><li>最常出现的 K 个数（中等）</li></ul></blockquote><h1 id="13-K-路合并"><a href="#13-K-路合并" class="headerlink" title="13. K 路合并"></a>13. K 路合并</h1><p>K 路合并能帮助你求解涉及一组经过排序的数组的问题。</p><p>当你被给出了 K 个经过排序的数组时，你可以使用 Heap 来有效地执行所有数组的所有元素的排序遍历。你可以将每个数组的最小元素推送至 Min Heap 以获得整体最小值。</p><p>在获得了整体最小值后，将来自同一个数组的下一个元素推送至 heap。</p><p>然后，重复这一过程以得到所有元素的排序遍历结果。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100559.webp" alt="图片"></p><p>该模式看起来像这样：</p><blockquote><ul><li>1．将每个数组的第一个元素插入 Min Heap</li><li>2．之后，从该 Heap 取出最小（顶部的）元素，将其加入到合并的列表。</li><li>3．在从 Heap 移除了最小的元素之后，将同一列表的下一个元素插入该 Heap</li><li>4．重复步骤 2 和 3，以排序的顺序填充合并的列表</li></ul></blockquote><p>如何识别 K 路合并模式：</p><blockquote><ul><li>具有排序数组、列表或矩阵的问题</li><li>如果问题要求你合并排序的列表，找到一个排序列表中的最小元素</li></ul></blockquote><p>K 路合并模式的问题：</p><blockquote><ul><li>合并 K 个排序的列表（中等）</li><li>找到和最大的 K 个配对（困难）</li></ul></blockquote><h1 id="14-拓扑排序"><a href="#14-拓扑排序" class="headerlink" title="14. 拓扑排序"></a>14. 拓扑排序</h1><p>拓扑排序可用于寻找互相依赖的元素的线性顺序。</p><p>比如，如果事件 B 依赖于事件 A，那么 A 在拓扑排序时位于 B 之前。</p><p>这个模式定义了一种简单方法来理解执行一组元素的拓扑排序的技术。</p><p>该模式看起来是这样的：</p><blockquote><ul><li><p>1．初始化。<br>a）使用 HashMap 将图（graph）存储到邻接的列表中；<br>b）为了查找所有源，使用 HashMap 记录 in-degree 的数量</p></li><li><p>2．构建图并找到所有顶点的 in-degree。<br>a）根据输入构建图并填充 in-degree HashMap</p></li><li><p>3．寻找所有的源。<br>a）所有 in-degree 为 0 的顶点都是源，并会被存入一个队列</p></li><li><p>4．排序。<br>a）对于每个源，执行以下操作：</p><p>i）将其加入到排序的列表；<br>ii）根据图获取其所有子节点；<br>iii）将每个子节点的 in-degree 减少 1；<br>iv）如果一个子节点的 in-degree 变为 0，将其加入到源队列。</p><p>b）重复 (a)，直到源队列为空。</p></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100552.webp" alt="图片"></p><p>如何识别拓扑排序模式：</p><blockquote><ul><li>处理无向有环图的问题</li><li>如果你被要求以排序顺序更新所有对象</li><li>如果你有一类遵循特定顺序的对象</li></ul></blockquote><p>拓扑排序模式的问题：</p><blockquote><ul><li>任务调度（中等）</li><li>一个树的最小高度</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;作者：Fahim ul Haq&lt;/p&gt;
&lt;p&gt;机器之心编译&lt;/p&gt;
&lt;p&gt;参与：Panda&lt;/p&gt;
&lt;h1 id=&quot;解题套路&quot;&gt;&lt;a href=&quot;#解题套路&quot; class=&quot;headerlink&quot; title=&quot;解题套路&quot;&gt;&lt;/a&gt;解题套路&lt;/h1&gt;&lt;p&gt;咱们在面试程序员岗位时往往需要经历一个编程面试过程，雇主会借此考验面试者的技术实力。&lt;/p&gt;
&lt;p&gt;然而，这些技术问题有时候却和我们的实际工作并无太大关系，也由此可能给我们的编程面试准备阶段带来很大的压力。&lt;/p&gt;
&lt;p&gt;曾在 Facebook 和微软工作过的 Educative.io 创始人 Fahim ul Haq 近日发文总结了编程面试所遇到的问题的 14 种最常见的模式，也许能帮你看清各种编程面试问题「背后的真相」。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210225100733.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;对很多开发者来说，编程工作的面试准备很容易让人焦虑。面试要涉及的东西实在太多，其中很多还往往与开发者的日常工作无关，只会额外增添压力。&lt;/p&gt;
&lt;p&gt;这种现状导致了一个后果：现在的开发者往往需要花费数周时间在 LeetCode 等网站上了解综合数百个问题。&lt;/p&gt;
&lt;p&gt;与我谈过的开发者在面试前的一个常见焦虑问题是：&lt;strong&gt;我是否已经解决过足够多的实际问题？我本可以做到更多吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是我想要帮助开发者了解每个问题背后的底层模式的原因——这样他们就不必担忧解决数百个问题以及被 LeetCode 整得疲惫不堪了。&lt;/p&gt;
&lt;p&gt;如果你理解面试的通用模式，你就可以将其用作模板，从而解决各种层级的稍有不同的问题。&lt;/p&gt;
&lt;p&gt;这里我将列出最常见的 14 种模式，它们可被用于解决任何编程面试问题。&lt;/p&gt;
&lt;p&gt;另外我还会说明如何识别每种模式，并会为每种模式提供一些问题示例。&lt;/p&gt;
&lt;p&gt;这些内容都只是蜻蜓点水——&lt;strong&gt;我强烈建议你看看课程《Grokking the Coding Interview: Patterns for Coding Questions》，里面提供了全面的解释、示例和编程实践&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面的模式说明假设你已经知悉了数据结构。如果你还不了解，那需要补充一下知识点哦。&lt;/p&gt;
&lt;p&gt;我们今天将说明以下 14 种模式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1．滑动窗口&lt;/li&gt;
&lt;li&gt;2．二指针或迭代器&lt;/li&gt;
&lt;li&gt;3．快速和慢速指针或迭代器&lt;/li&gt;
&lt;li&gt;4．合并区间&lt;/li&gt;
&lt;li&gt;5．循环排序&lt;/li&gt;
&lt;li&gt;6．原地反转链表&lt;/li&gt;
&lt;li&gt;7．树的宽度优先搜索（Tree BFS）&lt;/li&gt;
&lt;li&gt;8．树的深度优先搜索（Tree DFS）&lt;/li&gt;
&lt;li&gt;9．Two Heaps&lt;/li&gt;
&lt;li&gt;10．子集&lt;/li&gt;
&lt;li&gt;11．经过修改的二叉搜索&lt;/li&gt;
&lt;li&gt;12．前 K 个元素&lt;/li&gt;
&lt;li&gt;13．K 路合并&lt;/li&gt;
&lt;li&gt;14．拓扑排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们开始吧！&lt;/p&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法模板</title>
    <link href="https://blog.elfred.top/posts/2cc2fa98.html"/>
    <id>https://blog.elfred.top/posts/2cc2fa98.html</id>
    <published>2021-02-22T14:55:00.000Z</published>
    <updated>2025-03-08T14:46:55.114Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="1-滑动窗口通用模板"><a href="#1-滑动窗口通用模板" class="headerlink" title="1.滑动窗口通用模板"></a>1.滑动窗口通用模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findSubArray</span>(<span class="params">nums</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(nums) <span class="comment"># 数组/字符串长度</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span></span><br><span class="line">    res = <span class="number">0</span> <span class="comment"># 保存最大的满足题目要求的 子数组/子串 长度</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; N: <span class="comment"># 当右边的指针没有搜索到 数组/字符串 的结尾</span></span><br><span class="line">        sums += nums[right] <span class="comment"># 增加当前右边指针的数字/字符的求和/计数</span></span><br><span class="line">        <span class="keyword">while</span> 区间[left, right]不符合题意：<span class="comment"># 此时需要一直移动左指针，直至找到一个符合题意的区间</span></span><br><span class="line">            sums -= nums[left] <span class="comment"># 移动左指针前需要从counter中减少left位置字符的求和/计数</span></span><br><span class="line">            left += <span class="number">1</span> <span class="comment"># 真正的移动左指针，注意不能跟上面一行代码写反</span></span><br><span class="line">        <span class="comment"># 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>) <span class="comment"># 需要更新结果</span></span><br><span class="line">        right += <span class="number">1</span> <span class="comment"># 移动右指针，去探索新的区间</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p><p>模板的整体思想是：</p><p>定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；<br>第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和&#x2F;计数；<br>第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和&#x2F;计数；<br>在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。<br>right 指针每次向右移动一步，开始探索新的区间。<br>模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。</p><h4 id="2-固定滑动窗口"><a href="#2-固定滑动窗口" class="headerlink" title="2.固定滑动窗口"></a>2.固定滑动窗口</h4><h5 id="leetcode-643-子数组最大平均数-I"><a href="#leetcode-643-子数组最大平均数-I" class="headerlink" title="leetcode 643. 子数组最大平均数 I"></a><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">leetcode 643. 子数组最大平均数 I</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum = sum + nums[i] - nums[i - k];</span><br><span class="line">        max = Math.max(sum, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * max / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="leetcode-1052-爱生气的书店老板"><a href="#leetcode-1052-爱生气的书店老板" class="headerlink" title="leetcode 1052.爱生气的书店老板"></a><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">leetcode 1052.爱生气的书店老板</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSatisfied</span><span class="params">(<span class="type">int</span>[] customers, <span class="type">int</span>[] grumpy, <span class="type">int</span> X)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> customers.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          total += customers[i] * (<span class="number">1</span> - grumpy[i]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">increase</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; X; i++) &#123;</span><br><span class="line">          increase += customers[i] * grumpy[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">maxIncrease</span> <span class="operator">=</span> increase;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> X; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="comment">// 如果是1的代表生气，0的代表不生气直接乘就可以（仍为0），因为之前已经算出来了</span></span><br><span class="line">          increase = increase - customers[i - X] * grumpy[i - X] + customers[i] * grumpy[i];</span><br><span class="line">          maxIncrease = Math.max(maxIncrease, increase);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> total + maxIncrease;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h3&gt;&lt;h4 id=&quot;1-滑动窗口通用模板&quot;&gt;&lt;a href=&quot;#1-滑动窗口通用模板&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://blog.elfred.top/posts/cdcc4eae.html"/>
    <id>https://blog.elfred.top/posts/cdcc4eae.html</id>
    <published>2021-02-21T15:49:00.000Z</published>
    <updated>2025-03-08T14:46:55.123Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="两阶段提交方案-XA-方案"><a href="#两阶段提交方案-XA-方案" class="headerlink" title="两阶段提交方案&#x2F;XA 方案"></a>两阶段提交方案&#x2F;XA 方案</h3><p>所谓的 XA 方案，即：两阶段提交，有一个<strong>事务管理器</strong>的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 <code>Spring + JTA</code> 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210221234444.png" alt="distributed-transacion-XA"></p><h3 id="TCC方案"><a href="#TCC方案" class="headerlink" title="TCC方案"></a>TCC方案</h3><p>TCC 的全称是： <code>Try</code> 、 <code>Confirm</code> 、 <code>Cancel</code> 。</p><ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong>。</li><li>Confirm 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong>。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要<strong>进行补偿</strong>，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul><p>这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个<strong>事务回滚</strong>实际上是<strong>严重依赖于你自己写代码来回滚和补偿</strong>了，会造成补偿代码巨大，非常之恶心。</p><p>比如说我们，一般来说跟<strong>钱</strong>相关的，跟钱打交道的，<strong>支付</strong>、<strong>交易</strong>相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>而且最好是你的各个业务执行的时间都比较短。</p><p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210221231742.png" alt="distributed-transacion-TCC"></p><h3 id="Saga方案"><a href="#Saga方案" class="headerlink" title="Saga方案"></a>Saga方案</h3><p>金融核心等业务可能会选择 TCC 方案，以追求强一致性和更高的并发量，而对于更多的金融核心以上的业务系统往往会选择补偿事务，补偿事务处理在 30 多年前就提出了 Saga 理论，随着微服务的发展，近些年才逐步受到大家的关注。目前业界比较公认的是采用 Saga 作为长事务的解决方案。</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>业务流程中每个参与者都提交本地事务，若某一个参与者失败，则补偿前面已经成功的参与者。下图左侧是正常的事务流程，当执行到 T3 时发生了错误，则开始执行右边的事务补偿流程，反向执行 T3、T2、T1 的补偿服务 C3、C2、C1，将 T3、T2、T1 已经修改的数据补偿掉。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210221231855.png" alt="distributed-transacion-TCC"></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>对于一致性要求高、短流程、并发高 的场景，如：金融核心系统，会优先考虑 TCC 方案。而在另外一些场景下，我们并不需要这么强的一致性，只需要保证最终一致性即可。</p><p>比如 很多金融核心以上的业务（渠道层、产品层、系统集成层），这些系统的特点是最终一致即可、流程多、流程长、还可能要调用其它公司的服务。这种情况如果选择 TCC 方案开发的话，一来成本高，二来无法要求其它公司的服务也遵循 TCC 模式。同时流程长，事务边界太长，加锁时间长，也会影响并发性能。</p><p>所以 Saga 模式的适用场景是：</p><ul><li>业务流程长、业务流程多；</li><li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口。</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>一阶段提交本地事务，无锁，高性能；</li><li>参与者可异步执行，高吞吐；</li><li>补偿服务易于实现，因为一个更新操作的反向操作是比较容易理解的。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不保证事务的隔离性。</li></ul><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>这个大概意思是这样的：</p><ol><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样<strong>保证不会重复处理消息</strong>；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li></ol><p>这个方案说实话最大的问题就在于<strong>严重依赖于数据库的消息表来管理事务</strong>啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p><p><img src="https://doocs.github.io/advanced-java/docs/distributed-system/images/distributed-transaction-local-message-table.png" alt="distributed-transaction-local-message-table"></p><h3 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h3><p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>大概的意思就是：</p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你就用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210221234417.png" alt="distributed-transaction-reliable-message"></p><h3 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h3><p>这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ol><h3 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h3><p>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p><p>你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p><p>友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p><p>当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;两阶段提交方案-XA-方案&quot;&gt;&lt;a href=&quot;#两阶段提交方案-XA-方案&quot; class=&quot;headerlink&quot; title=&quot;两阶段提交方案&amp;#x2F;XA 方案&quot;&gt;&lt;/a&gt;两阶段提交方案&amp;#x2F;XA 方案&lt;/h3&gt;&lt;p&gt;所谓的 XA 方案，即</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="分布式事务" scheme="https://blog.elfred.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="TCC" scheme="https://blog.elfred.top/tags/TCC/"/>
    
    <category term="消息一致性" scheme="https://blog.elfred.top/tags/%E6%B6%88%E6%81%AF%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://blog.elfred.top/posts/e255a10a.html"/>
    <id>https://blog.elfred.top/posts/e255a10a.html</id>
    <published>2021-02-04T07:29:00.000Z</published>
    <updated>2025-03-08T14:46:55.128Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP&#x2F;UDP"></a>TCP&#x2F;UDP</h2><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><h4 id="三次握手的流程"><a href="#三次握手的流程" class="headerlink" title="三次握手的流程"></a>三次握手的流程</h4><h4 id="为什么是三次，两次行不行？"><a href="#为什么是三次，两次行不行？" class="headerlink" title="为什么是三次，两次行不行？"></a>为什么是三次，两次行不行？</h4><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><h4 id="四次挥手的流程？"><a href="#四次挥手的流程？" class="headerlink" title="四次挥手的流程？"></a>四次挥手的流程？</h4><h4 id="为什么是四次挥手不是三次？"><a href="#为什么是四次挥手不是三次？" class="headerlink" title="为什么是四次挥手不是三次？"></a>为什么是四次挥手不是三次？</h4><h3 id="TCP如何保证可靠性传输"><a href="#TCP如何保证可靠性传输" class="headerlink" title="TCP如何保证可靠性传输"></a>TCP如何保证可靠性传输</h3><h3 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h3><p>TCP是个“流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</p><h4 id="TCP粘包-拆包问题说明"><a href="#TCP粘包-拆包问题说明" class="headerlink" title="TCP粘包&#x2F;拆包问题说明"></a>TCP粘包&#x2F;拆包问题说明</h4><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210212215650.png" alt="img"></p><p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。</p><ol><li>服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；</li><li>服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；</li><li>服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；</li><li>服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。</li></ol><p>如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。</p><h4 id="TCP粘包-拆包发生的原因"><a href="#TCP粘包-拆包发生的原因" class="headerlink" title="TCP粘包&#x2F;拆包发生的原因"></a>TCP粘包&#x2F;拆包发生的原因</h4><ol><li>应用程序write写入的字节大小大于套接口发送缓冲区大小；</li><li>进行MSS大小的TCP分段；</li><li>以太网帧的payload大于MTU进行IP分片。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210212215514.png" alt="img"></p><h4 id="粘包问题的解决策略"><a href="#粘包问题的解决策略" class="headerlink" title="粘包问题的解决策略"></a>粘包问题的解决策略</h4><p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下：</p><ol><li>消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；</li><li>在包尾增加回车换行符进行分割，例如FTP协议；</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；</li><li>更复杂的应用层协议。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;TCP-UDP&quot;&gt;&lt;a href=&quot;#TCP-UDP&quot; class=&quot;headerlink&quot; title=&quot;TCP&amp;#x2F;UDP&quot;&gt;&lt;/a&gt;TCP&amp;#x2F;UDP&lt;/h2&gt;&lt;h3 id=&quot;什么是TCP&quot;&gt;&lt;a href=&quot;#什么是TCP&quot; clas</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>系统架构设计</title>
    <link href="https://blog.elfred.top/posts/75203a6f.html"/>
    <id>https://blog.elfred.top/posts/75203a6f.html</id>
    <published>2021-01-30T06:09:00.000Z</published>
    <updated>2025-03-08T14:46:55.122Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="如何设计一个高并发系统？"><a href="#如何设计一个高并发系统？" class="headerlink" title="如何设计一个高并发系统？"></a>如何设计一个高并发系统？</h1><p>可以分为以下 6 点：</p><ul><li>系统拆分</li><li>缓存</li><li>MQ</li><li>分库分表</li><li>读写分离</li><li>ElasticSearch</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210126145855.png" alt="high-concurrency-system-design"></p><h1 id="如何设计一个高可用系统"><a href="#如何设计一个高可用系统" class="headerlink" title="如何设计一个高可用系统"></a>如何设计一个高可用系统</h1><h2 id="什么是高可用？可用性的判断标准是啥？"><a href="#什么是高可用？可用性的判断标准是啥？" class="headerlink" title="什么是高可用？可用性的判断标准是啥？"></a>什么是高可用？可用性的判断标准是啥？</h2><p><strong>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</strong></p><p><strong>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</strong></p><p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p><h2 id="哪些情况会导致系统不可用？"><a href="#哪些情况会导致系统不可用？" class="headerlink" title="哪些情况会导致系统不可用？"></a>哪些情况会导致系统不可用？</h2><ol><li>黑客攻击；</li><li>硬件故障，比如服务器坏掉。</li><li>并发量&#x2F;用户请求量激增导致整个服务宕掉或者部分服务不可用。</li><li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li><li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li><li>自然灾害或者人为破坏。</li><li>……</li></ol><h2 id="有哪些提高系统可用性的方法？"><a href="#有哪些提高系统可用性的方法？" class="headerlink" title="有哪些提高系统可用性的方法？"></a>有哪些提高系统可用性的方法？</h2><h3 id="1-注重代码质量，测试严格把关"><a href="#1-注重代码质量，测试严格把关" class="headerlink" title="1. 注重代码质量，测试严格把关"></a>1. 注重代码质量，测试严格把关</h3><p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p><p>另外，安利这个对提高代码质量有实际效果的宝贝：</p><ol><li>sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。</li><li>Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。</li><li>IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。</li></ol><h3 id="2-使用集群，减少单点故障"><a href="#2-使用集群，减少单点故障" class="headerlink" title="2.使用集群，减少单点故障"></a>2.使用集群，减少单点故障</h3><p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例，不到一秒就会有另外一台 Redis 实例顶上。</p><h3 id="3-限流"><a href="#3-限流" class="headerlink" title="3.限流"></a>3.限流</h3><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 alibaba-<a href="https://github.com/alibaba/Sentinel">Sentinel</a> 的 wiki。</p><h3 id="4-超时和重试机制设置"><a href="#4-超时和重试机制设置" class="headerlink" title="4.超时和重试机制设置"></a>4.超时和重试机制设置</h3><p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p><h3 id="5-熔断机制"><a href="#5-熔断机制" class="headerlink" title="5.熔断机制"></a>5.熔断机制</h3><p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的是流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p><h3 id="6-异步调用"><a href="#6-异步调用" class="headerlink" title="6.异步调用"></a>6.异步调用</h3><p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 <strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p><h3 id="7-使用缓存"><a href="#7-使用缓存" class="headerlink" title="7.使用缓存"></a>7.使用缓存</h3><p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><ol><li><strong>核心应用和服务优先使用更好的硬件</strong></li><li><strong>监控系统资源使用情况增加报警设置。</strong></li><li><strong>注意备份，必要时候回滚。</strong></li><li><strong>灰度发布：</strong> 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li><li><strong>定期检查&#x2F;更换硬件：</strong> 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li><li>…..(想起来再补充！也欢迎各位欢迎补充！)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210213235715.png" alt="如何设计高可用系统？"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;如何设计一个高并发系统？&quot;&gt;&lt;a href=&quot;#如何设计一个高并发系统？&quot; class=&quot;headerlink&quot; title=&quot;如何设计一个高并发系统？&quot;&gt;&lt;/a&gt;如何设计一个高并发系统？&lt;/h1&gt;&lt;p&gt;可以分为以下 6 点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="https://blog.elfred.top/posts/c783f2ce.html"/>
    <id>https://blog.elfred.top/posts/c783f2ce.html</id>
    <published>2021-01-30T05:55:00.000Z</published>
    <updated>2025-03-08T14:46:55.128Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="介绍下Linux（Unix）操作系统的五种IO模型"><a href="#介绍下Linux（Unix）操作系统的五种IO模型" class="headerlink" title="介绍下Linux（Unix）操作系统的五种IO模型"></a>介绍下Linux（Unix）操作系统的五种IO模型</h2><p>在Linux(UNIX)操作系统中，共有五种IO模型，分别是：<strong>阻塞IO模型</strong>、<strong>非阻塞IO模型</strong>、<strong>IO复用模型</strong>、<strong>信号驱动IO模型</strong>以及<strong>异步IO模型</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210126103811.jpeg" alt="图片"></p><p>我们说阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型都是同步的IO模型。原因是因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行的。</p><p><strong>同步和异步：</strong></p><p>从操作系统角度来说，<strong>网络IO的数据拷贝主要分为两个阶段，一是数据准备阶段，二是数据从内核拷贝到用户中。</strong></p><p>同步IO指的是数据从内核拷贝到用户时。发起该请求的线程会自己来拷贝数据（表现为线程阻塞拷贝）。</p><p>PS：一旦涉及到网络 IO必定会发生数据拷贝的阻塞（此阻塞非彼阻塞，这里的阻塞形容的是拷贝数据相对于CPU的速度来说是非常耗时的，看起来像线程阻塞了一样。我们常说的阻塞是线程挂起并让出CPU），只不过阻塞发生在其他的地方（自己来拷贝就是同步的，别人帮我拷贝就是异步的），因为IO必定会用到CPU，即使是零拷贝。</p><p><strong>阻塞和非阻塞：</strong></p><p>阻塞和非阻塞主要描述的是网络IO数据拷贝的第一个阶段。</p><p>阻塞指的是线程一直等待数据准备好，期间什么都不干，但是会让出CPU，这样其他线程可以执行（CPU的利用率比较高），数据准备好之后自己来拷贝数据。</p><p>非阻塞指的是在第一阶段，发起网络IO请求的时候会立即返回去干别的事情，但是会不断地进行询问数据是否准备好，这种方式称之为轮询。由于CPU要处理更多的系统调用（每次询问都是系统调用），这种模型的CPU利用率低。</p><h2 id="NIO是如何实现同步非阻塞的呢？"><a href="#NIO是如何实现同步非阻塞的呢？" class="headerlink" title="NIO是如何实现同步非阻塞的呢？"></a>NIO是如何实现同步非阻塞的呢？</h2><p>Java的NIO实现采用了同步非阻塞IO和IO多路复用，其核心组件是Selector。Selector会不断的主动的询问Channel是否有事件发生，有事件发生，会进行事件处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java nio</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  ......</span><br><span class="line">  selector.select(<span class="number">1</span>); <span class="comment">//不阻塞</span></span><br><span class="line">  Set&lt;SelectionKey&gt; selectionKeySet= selector.selectedKeys();</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//处理selectionKeySet中事件,线程没有阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java socket处理连接，线程会阻塞</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">//阻塞</span></span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream(); </span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//处理in中内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty采用的是NIO其对Java的NIO进行了改进，其内部也封装了Selector和Channel，采用串行并发来提高效率。</p><p>Java的NIO采用的是Reactor线程模型中的单Reactor单线程模型（前台和服务员是一个人，全程为顾客服务，可以服务多个人），Netty的NIO采用的是主从Reactor模型，是多Reactor多线程模型。</p><h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><p><a href="https://imageslr.com/2020/02/27/select-poll-epoll.html#%E4%BB%8E%E9%98%BB%E5%A1%9E-io-%E5%88%B0-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">参考：从阻塞-io-到-io-多路复用</a></p><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><ol><li>性能开销大<ol><li>调用 <code>select</code> 时会陷入内核，这时需要将参数中的 <code>fd_set</code> 从用户空间拷贝到内核空间</li><li>内核需要遍历传递进来的所有 <code>fd_set</code> 的每一位，不管它们是否就绪</li></ol></li><li>同时能够监听的文件描述符数量太少。受限于 <code>sizeof(fd_set)</code> 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同</li></ol><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 和 select 几乎没有区别。poll 采用链表的方式存储文件描述符，没有最大存储数量的限制。</p><p>从性能开销上看，poll 和 select 的差别不大。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>简而言之，epoll 有以下几个特点：</p><ul><li>使用<strong>红黑树</strong>存储文件描述符集合</li><li>使用<strong>队列</strong>存储就绪的文件描述符</li><li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li></ul><p>select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：<code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p><h3 id="epoll-的优点"><a href="#epoll-的优点" class="headerlink" title="epoll 的优点"></a>epoll 的优点</h3><p>一开始说，epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>对于“文件描述符数量少”，select 使用整型数组存储文件描述符集合，而 epoll 使用红黑树存储，数量较大。</p><p>对于“性能开销大”，<code>epoll_ctl</code> 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此 epoll 不需要像 <code>select</code> 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。</p><blockquote><p>相当于时间复杂度从 O(n) 降为 O(1)</p></blockquote><p>此外，每次调用 <code>select</code> 时都需要向内核拷贝所有要监听的描述符集合，而 epoll 对于每个描述符，只需要在 <code>epoll_ctl</code> 传递一次，之后 <code>epoll_wait</code> 不需要再次传递。这也大大提高了效率。</p><h3 id="水平触发、边缘触发"><a href="#水平触发、边缘触发" class="headerlink" title="水平触发、边缘触发"></a>水平触发、边缘触发</h3><p><code>select</code> 只支持水平触发，<code>epoll</code> 支持水平触发和边缘触发。</p><p>水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读&#x2F;写完，下次还会发出可读&#x2F;可写信号进行通知。</p><p>边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。</p><p>区别：边缘触发效率更高，<strong>减少了事件被重复触发的次数</strong>，函数不会返回大量用户程序可能不需要的文件描述符。</p><blockquote><p>水平触发、边缘触发的名称来源：数字电路当中的电位水平，高低电平切换瞬间的触发动作叫边缘触发，而处于高电平的触发动作叫做水平触发。</p></blockquote><h3 id="为什么边缘触发必须使用非阻塞-I-O？"><a href="#为什么边缘触发必须使用非阻塞-I-O？" class="headerlink" title="为什么边缘触发必须使用非阻塞 I&#x2F;O？"></a>为什么边缘触发必须使用非阻塞 I&#x2F;O？</h3><p>关于这个问题的解答，强烈建议阅读<a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">这篇文章</a>。下面是一些关键摘要：</p><ul><li>每次通过 <code>read</code> 系统调用读取数据时，最多只能读取缓冲区大小的字节数；如果某个文件描述符一次性收到的数据超过了缓冲区的大小，那么需要对其 <code>read</code> 多次才能全部读取完毕</li><li><strong><code>select</code> 可以使用阻塞 I&#x2F;O</strong>。通过 <code>select</code> 获取到所有可读的文件描述符后，遍历每个文件描述符，<code>read</code> <strong>一次</strong>数据（见上文 <a href="https://imageslr.com/2020/02/27/select-poll-epoll.html#selectdemo">select 示例</a>）<ul><li>这些文件描述符都是可读的，因此即使 <code>read</code> 是阻塞 I&#x2F;O，也一定可以读到数据，不会一直阻塞下去</li><li><code>select</code> 采用水平触发模式，因此如果第一次 <code>read</code> 没有读取完全部数据，那么下次调用 <code>select</code> 时依然会返回这个文件描述符，可以再次 <code>read</code></li><li><strong><code>select</code> 也可以使用非阻塞 I&#x2F;O</strong>。当遍历某个可读文件描述符时，使用 <code>for</code> 循环调用 <code>read</code> <strong>多次</strong>，直到读取完所有数据为止（返回 <code>EWOULDBLOCK</code>）。这样做会多一次 <code>read</code> 调用，但可以减少调用 <code>select</code> 的次数</li></ul></li><li>在 <code>epoll</code> 的边缘触发模式下，只会在文件描述符的可读&#x2F;可写状态发生切换时，才会收到操作系统的通知<ul><li>因此，如果使用 <code>epoll</code> 的<strong>边缘触发模式</strong>，在收到通知时，<strong>必须使用非阻塞 I&#x2F;O，并且必须循环调用 <code>read</code> 或 <code>write</code> 多次，直到返回 <code>EWOULDBLOCK</code> 为止</strong>，然后再调用 <code>epoll_wait</code> 等待操作系统的下一次通知</li><li>如果没有一次性读&#x2F;写完所有数据，那么在操作系统看来这个文件描述符的状态没有发生改变，将不会再发起通知，调用 <code>epoll_wait</code> 会使得该文件描述符一直等待下去，服务端也会一直等待客户端的响应，业务流程无法走完</li><li>这样做的好处是每次调用 <code>epoll_wait</code> 都是<strong>有效</strong>的——保证数据全部读写完毕了，等待下次通知。在水平触发模式下，如果调用 <code>epoll_wait</code> 时数据没有读&#x2F;写完毕，会直接返回，再次通知。因此边缘触发能显著减少事件被触发的次数</li><li>为什么 <code>epoll</code> 的<strong>边缘触发模式不能使用阻塞 I&#x2F;O</strong>？很显然，边缘触发模式需要循环读&#x2F;写一个文件描述符的所有数据。如果使用阻塞 I&#x2F;O，那么一定会在最后一次调用（没有数据可读&#x2F;写）时阻塞，导致无法正常结束</li></ul></li></ul><h3 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h3><ul><li><code>select</code>：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符</li><li><code>poll</code>：poll 采用链表的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别</li><li><code>epoll</code>：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合</li></ul><p><code>select</code>、<code>poll</code> 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；<code>epoll</code> 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。</p><p>此外 <code>select</code> 只支持水平触发，<code>epoll</code> 支持边缘触发。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>当连接数较多并且有很多的不活跃连接时，epoll 的效率比其它两者高很多。当连接数较少并且都十分活跃的情况下，由于 epoll 需要很多回调，因此性能可能低于其它两者。</p><h3 id="Redis-的线程模型"><a href="#Redis-的线程模型" class="headerlink" title="Redis 的线程模型"></a>Redis 的线程模型</h3><p>Redis 是一个单线程的工作模型，使用 I&#x2F;O 多路复用来处理客户端的多个连接。为什么 Redis 选择单线程也能效率这么高？</p><p>I&#x2F;O 设备（如磁盘、网络）等速度远远慢于 CPU，因此引入了多线程技术。当一个线程发起 I&#x2F;O 请求时，先将它挂起，切换到别的线程；当 I&#x2F;O 设备就绪时，再切换回该线程。总之，<strong>多线程技术是为了充分利用 CPU 的计算资源，适用于下层存储慢速的场景</strong>。</p><p>而 redis 是纯内存操作，读写速度非常快。所有的操作都会在内存中完成，不涉及任何 I&#x2F;O 操作，因此<strong>多线程频繁的上下文切换反而是一种负优化</strong>。Redis 选择基于非阻塞 I&#x2F;O 的 <strong>I&#x2F;O 多路复用机制</strong>，在单线程里<strong>并发</strong>处理客户端的多个连接，减少多线程带来的系统开销，同时也有更好的可维护性，方便开发和调试。</p><p>不过 redis 在最新的几个版本中也引入了多线程，目的是：</p><ol><li>异步处理删除操作。当删除超大键值对的时候，单线程内同步地删除可能会阻塞待处理的任务</li><li>应对网络 I&#x2F;O 的场景，网络 I&#x2F;O 是慢速 I&#x2F;O。redis6 吞吐量提高了 1 倍</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;介绍下Linux（Unix）操作系统的五种IO模型&quot;&gt;&lt;a href=&quot;#介绍下Linux（Unix）操</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis常见面试题</title>
    <link href="https://blog.elfred.top/posts/bf7bdd05.html"/>
    <id>https://blog.elfred.top/posts/bf7bdd05.html</id>
    <published>2021-01-23T08:24:00.000Z</published>
    <updated>2025-03-08T14:46:55.122Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><h3 id="Redis单线程的理解，Redis-为什么早期版本选择单线程？"><a href="#Redis单线程的理解，Redis-为什么早期版本选择单线程？" class="headerlink" title="Redis单线程的理解，Redis 为什么早期版本选择单线程？"></a>Redis单线程的理解，Redis 为什么早期版本选择单线程？</h3><h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><p>因为 Redis 是基于内存的操作，<strong>CPU 不是 Redis 的瓶颈</strong>，Redis 的瓶颈最有可能是 <strong>机器内存的大小</strong> 或者 <strong>网络带宽</strong>。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><blockquote><p>首先，我们需要明白，多线程解决的问题。当一个线程处理的任务是I&#x2F;O密集型的，而I&#x2F;O传输数据很慢，因此线程总是处于等待数据传输，从而造成CPU资源的浪费。这时我们可以开辟多个线程，当一个线程在等待I&#x2F;O传输时，调度其他线程进行任务处理。<br>然而，redis所有的数据都存储在内存中，此时并不需要I&#x2F;O操作。而多线程调度还会造成额外的开销且实现复杂。<br>最终，选用单线程即可。</p></blockquote><p>一种解释：</p><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><h4 id="简单总结一下"><a href="#简单总结一下" class="headerlink" title="简单总结一下"></a>简单总结一下</h4><ol><li>使用单线程模型能带来更好的 <strong>可维护性</strong>，方便开发和调试；</li><li>使用单线程模型也能 <strong>并发</strong> 的处理客户端的请求(I&#x2F;O 多路复用机制epoll)；</li><li>Redis 服务中运行的绝大多数操作的 <strong>性能瓶颈都不是 CPU</strong>；</li></ol><h3 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h3><p>简单总结：</p><ol><li><strong>纯内存操作</strong>：读取不需要进行磁盘 I&#x2F;O，所以比传统数据库要快上不少；*(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)*</li><li><strong>单线程，无锁竞争</strong>：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；</li><li><strong>多路 I&#x2F;O 复用模型，非阻塞 I&#x2F;O</strong>：采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；</li><li><strong>高效的数据结构，加上底层做了大量优化</strong>：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..</li></ol><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="Redis-的-SDS-和-C-中字符串相比有什么优势？"><a href="#Redis-的-SDS-和-C-中字符串相比有什么优势？" class="headerlink" title="Redis 的 SDS 和 C 中字符串相比有什么优势？"></a>Redis 的 SDS 和 C 中字符串相比有什么优势？</h3><h4 id="先简单总结一下"><a href="#先简单总结一下" class="headerlink" title="先简单总结一下"></a>先简单总结一下</h4><p>C 语言使用了一个长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串，并且字符数组最后一个元素总是 <code>\0</code>，这种简单的字符串表示方式 <strong>不符合 Redis 对字符串在安全性、效率以及功能方面的要求</strong>。</p><h4 id="再来说-C-语言字符串的问题"><a href="#再来说-C-语言字符串的问题" class="headerlink" title="再来说 C 语言字符串的问题"></a>再来说 C 语言字符串的问题</h4><p>这样简单的数据结构可能会造成以下一些问题：</p><ul><li><strong>获取字符串长度为 O(N) 级别的操作</strong> → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组；</li><li>不能很好的杜绝 <strong>缓冲区溢出&#x2F;内存泄漏</strong> 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题；</li><li>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>&#39;\0&#39;</code> 可能会被判定为提前结束的字符串而识别不了；</li></ul><h4 id="Redis-如何解决的-SDS-的优势"><a href="#Redis-如何解决的-SDS-的优势" class="headerlink" title="Redis 如何解决的 | SDS 的优势"></a>Redis 如何解决的 | SDS 的优势</h4><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210228212624.webp" alt="图片"></p><p>如果去看 Redis 的源码 <code>sds.h/sdshdr</code> 文件，你会看到 SDS 完整的实现细节，这里简单来说一下 Redis 如何解决的：</p><ol><li><strong>多增加 len 表示当前字符串的长度</strong>：这样就可以直接获取长度了，复杂度 O(1)；</li><li><strong>自动扩展空间</strong>：当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的覆盖情况；</li><li><strong>有效降低内存分配次数</strong>：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；</li><li><strong>二进制安全</strong>：C 语言字符串只能保存 <code>ascii</code> 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；</li></ol><h3 id="字典是如何实现的？Rehash-了解吗？"><a href="#字典是如何实现的？Rehash-了解吗？" class="headerlink" title="字典是如何实现的？Rehash 了解吗？"></a>字典是如何实现的？Rehash 了解吗？</h3><h4 id="先总体聊一下-Redis-中的字典"><a href="#先总体聊一下-Redis-中的字典" class="headerlink" title="先总体聊一下 Redis 中的字典"></a>先总体聊一下 Redis 中的字典</h4><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。*(存储在 RedisDb 数据结构中)*</p><h4 id="说明字典内部结构和-rehash"><a href="#说明字典内部结构和-rehash" class="headerlink" title="说明字典内部结构和 rehash"></a>说明字典内部结构和 rehash</h4><p><strong>Redis</strong> 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的 <strong>链地址法</strong> 来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。</p><p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个 <code>hashtable</code> 有值，但是在字典扩容缩容时，需要分配新的 <code>hashtable</code>，然后进行 <strong>渐进式搬迁</strong> *(rehash)*，这时候两个 <code>hashtable</code> 分别存储旧的和新的 <code>hashtable</code>，待搬迁结束后，旧的将被删除，新的 <code>hashtable</code> 取而代之。</p><h4 id="扩缩容的条件"><a href="#扩缩容的条件" class="headerlink" title="扩缩容的条件"></a>扩缩容的条件</h4><p>正常情况下，当 hash 表中 <strong>元素的个数等于第一维数组的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了第一维数组长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p><p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 **元素个数低于数组长度的 10%**，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><h6 id="为什么需要渐进式rehash呢？"><a href="#为什么需要渐进式rehash呢？" class="headerlink" title="为什么需要渐进式rehash呢？"></a>为什么需要渐进式rehash呢？</h6><p>在元素数量较少时，rehash会非常快的进行，但是当元素数量达到几百、甚至几个亿时进行rehash将会是一个非常耗时的操作。如果一次性将成万上亿的元素的键值对rehash到ht[1]，庞大的计算量可能会导致服务器在一段时间内停止服务，这是非常危险的！所以，rehash这个动作不能一次性、集中式的完成，而是分多次、渐进式地完成。</p><h6 id="渐进式rehash步骤："><a href="#渐进式rehash步骤：" class="headerlink" title="渐进式rehash步骤："></a><strong>渐进式rehash步骤：</strong></h6><ol><li>为<code>ht[1]</code>分配空间，让字典同时持有<code>ht[0]</code>和<code>ht[1]</code>两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行CRUD：添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将<code>ht[0]</code>哈希表在rehashidx索引上的所有键值对rehash到<code>ht[1]</code>，当rehash工作完成之后，程序将rehashidx+1(表示下次将rehash下一个桶)。</li><li>随着字典操作的不断执行，最终在某个时间点上，<code>ht[0]</code>的所有键值对都会被rehash至<code>ht[1]</code>，这时程序将rehashidx属性的值设为-1，表示rehash完成。</li></ol><p><strong>渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash 而带来的庞大计算量。</strong></p><p><strong>需要注意的是在渐进式rehash的过程，如果有增删改查操作时，如果<code>index</code>大于<code>rehashindex</code>，访问<code>ht[0]</code>，否则访问<code>ht[1]。</code></strong></p><h6 id="搬迁是埋伏在客户端请求指令当中，如果客户端闲置下来，没有后续指令触发这个搬迁，未搬迁完的的数据怎么办？"><a href="#搬迁是埋伏在客户端请求指令当中，如果客户端闲置下来，没有后续指令触发这个搬迁，未搬迁完的的数据怎么办？" class="headerlink" title="搬迁是埋伏在客户端请求指令当中，如果客户端闲置下来，没有后续指令触发这个搬迁，未搬迁完的的数据怎么办？"></a><strong>搬迁是埋伏在客户端请求指令当中，如果客户端闲置下来，没有后续指令触发这个搬迁，未搬迁完的的数据怎么办？</strong></h6><p>Redis 还会在定时任务中对字典进行主动搬迁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器定时任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">databaseCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">if</span> (server.activerehashing) &#123;</span><br><span class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line"> <span class="type">int</span> work_done = <span class="built_in">incrementallyRehash</span>(rehash_db);</span><br><span class="line"> <span class="keyword">if</span> (work_done) &#123;</span><br><span class="line"> <span class="comment">/* If the function did some work, stop here, we&#x27;ll do</span></span><br><span class="line"><span class="comment"> * more at the next cron loop. */</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">/* If this db didn&#x27;t need rehash, we&#x27;ll try the next one. */</span></span><br><span class="line"> rehash_db++;</span><br><span class="line"> rehash_db %= server.dbnum;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="渐进式rehash的疑问"><a href="#渐进式rehash的疑问" class="headerlink" title="渐进式rehash的疑问"></a><strong>渐进式rehash的疑问</strong></h6><ol><li><p>在迁移的过程中，会不会造成读少数据?</p><blockquote><p>不会，因为在迁移时，首先会从ht[0]读取数据，如果ht[0]读不到，则会去ht[1]读。</p></blockquote></li><li><p>在迁移过程中，新增加的数据会存放在哪个ht?</p><blockquote><p>迁移过程中，新增的数据只会存在ht[1]中，而不会存放到ht[0]，ht[0]只会减少不会新增。</p></blockquote></li></ol><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzUyMTg0NDA2Ng==&mid=2247484000&idx=1&sn=a7e02adebea31535c3870cc514719493&chksm=f9d5a66dcea22f7b7cdf210993cbe6c057c0456967ac106d76c89fdd76ed5cb271c879a83f3e&scene=21#wechat_redirect">Redis(2)——跳跃表</a></li></ul><h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p><strong>Redis 快照</strong> 是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在 2 分钟前创建的，并且现在已经至少有 <code>100</code> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p><strong>快照不是很持久</strong>。如果运行 Redis 的计算机停止运行，电源线出现故障或者您 <code>kill -9</code> 的实例意外发生，则写入 Redis 的最新数据将丢失。尽管这对于某些应用程序可能不是什么大问题，但有些使用案例具有充分的耐用性，在这些情况下，快照并不是可行的选择。</p><p><strong>AOF(Append Only File - 仅追加文件)</strong> 它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p><h4 id="Redis-4-0-的混合持久化"><a href="#Redis-4-0-的混合持久化" class="headerlink" title="Redis 4.0 的混合持久化"></a>Redis 4.0 的混合持久化</h4><p>重启 Redis 时，我们很少使用 <code>rdb</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>rdb</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p><p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210509211524.webp" alt="图片"></p><p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><h4 id="RDB-和-AOF-各自有什么优缺点？"><a href="#RDB-和-AOF-各自有什么优缺点？" class="headerlink" title="RDB 和 AOF 各自有什么优缺点？"></a>RDB 和 AOF 各自有什么优缺点？</h4><h5 id="RDB-优点"><a href="#RDB-优点" class="headerlink" title="RDB | 优点"></a>RDB | 优点</h5><ol><li>只有一个文件 <code>dump.rdb</code>，<strong>方便持久化</strong>。</li><li><strong>容灾性好</strong>，一个文件可以保存到安全的磁盘。</li><li><strong>性能最大化</strong>，<code>fork</code> 子进程来完成写操作，让主进程继续处理命令，所以使 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能</li><li>相对于数据集大时，比 AOF 的 <strong>启动效率</strong> 更高。</li></ol><h5 id="RDB-缺点"><a href="#RDB-缺点" class="headerlink" title="RDB | 缺点"></a>RDB | 缺点</h5><ol><li><strong>数据安全性低</strong>。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候；</li></ol><h5 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF | 优点"></a>AOF | 优点</h5><ol><li><strong>数据安全</strong>，aof 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次命令操作就记录到 aof 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li></ol><h5 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF | 缺点"></a>AOF | 缺点</h5><ol><li>AOF 文件比 RDB <strong>文件大</strong>，且 <strong>恢复速度慢</strong>。</li><li><strong>数据集大</strong> 的时候，比 rdb <strong>启动效率低</strong>。</li></ol><h4 id="两种方式如何选择？"><a href="#两种方式如何选择？" class="headerlink" title="两种方式如何选择？"></a>两种方式如何选择？</h4><ul><li>一般来说， 如果想达到足以媲美 PostgreSQL 的 <strong>数据安全性</strong>，你应该 <strong>同时使用两种持久化功能</strong>。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li><li>如果你非常关心你的数据， 但仍然 <strong>可以承受数分钟以内的数据丢失</strong>，那么你可以 <strong>只使用 RDB 持久化</strong>。</li><li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</li><li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li></ul><h4 id="Redis-的数据恢复"><a href="#Redis-的数据恢复" class="headerlink" title="Redis 的数据恢复"></a>Redis 的数据恢复</h4><p><strong>Redis</strong> 的数据恢复有着如下的优先级：</p><ol><li>如果只配置 AOF ，重启时加载 AOF 文件恢复数据；</li><li>如果同时配置了 RDB 和 AOF ，启动只加载 AOF 文件恢复数据；</li><li>如果只配置 RDB，启动将加载 dump 文件恢复数据。</li></ol><p>拷贝 <strong>AOF</strong> 文件到 Redis 的数据目录，启动 redis-server AOF 的数据恢复过程：Redis 虚拟一个客户端，读取 AOF 文件恢复 Redis 命令和参数，然后执行命令从而恢复数据，这些过程主要在 <code>loadAppendOnlyFile()</code> 中实现。</p><p>拷贝 <strong>RDB</strong> 文件到 Redis 的数据目录，启动 redis-server 即可，因为 RDB 文件和重启前保存的是真实数据而不是命令状态和参数。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="Redis主从复制核心原理"><a href="#Redis主从复制核心原理" class="headerlink" title="Redis主从复制核心原理"></a>Redis主从复制核心原理</h4><ol><li>salve node启动，会发送一个<code>PSYNC</code>命令给master node</li><li>如果是slave node初次连接到master node，会触发一次<code>full resynchronization</code> 全量复制。此时master回启动一个后台线程，生成<code>RDB</code>快照文件，同时将从客户端新收到的所有写命令缓存到内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</li><li>slave node如果跟master node有网络故障，断开了链接，会自动重连，连接之后master node仅会复制给salve部分缺少的数据。<br><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210119165016.png" alt="Redis-master-slave-replication"></li></ol><h4 id="主从复制是如何断点续传的？"><a href="#主从复制是如何断点续传的？" class="headerlink" title="主从复制是如何断点续传的？"></a>主从复制是如何断点续传的？</h4><p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p><p>master node会在内存中维护一个backlog，master和slave都会保存一个replica offset还有一个master run id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次replica offset开始复制，如果没有找到对应的offset，那么就会执行一次<code>resynchronization</code> 。</p><blockquote><p> 如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。</p></blockquote><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5MzU2NDgyNw==&mid=2247487138&idx=1&sn=0e580a60cf28707b012f7c2068ca2bbc&source=41#wechat_redirect">妈妈再也不担心我面试被Redis问得脸都绿了</a></li><li><a href="https://www.51cto.com/article/668394.html">redis渐进式rehash</a></li><li><a href="https://www.51cto.com/article/668394.html">Redis中的hash扩容渐进式rehash过程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;Redis线程模型&quot;&gt;&lt;a href=&quot;#Redis线程模型&quot; class=&quot;headerlink&quot; title=&quot;Redis线程模型&quot;&gt;&lt;/a&gt;Redis线程模型&lt;/h2&gt;&lt;h3 id=&quot;Redis单线程的理解，Redis-为什么早期版本选择单线程？&quot;</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="redis" scheme="https://blog.elfred.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>JVM面试题</title>
    <link href="https://blog.elfred.top/posts/eec2f852.html"/>
    <id>https://blog.elfred.top/posts/eec2f852.html</id>
    <published>2021-01-23T08:23:00.000Z</published>
    <updated>2025-03-08T14:46:55.120Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="对象已经死亡？"><a href="#对象已经死亡？" class="headerlink" title="对象已经死亡？"></a>对象已经死亡？</h2><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h2><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><strong>过程：加载、验证、准备、解析、初始化</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210610235314.jpeg" alt="img"></p><p>类加载过程分为三个阶段：Load、Link和Init，即<strong>加载</strong>、<strong>链接</strong>、<strong>初始化</strong></p><ol><li>第一步，Load阶段读取类文件产生二进制流，并转化为特定的数据结构，初步校验cafe babe魔法数、常量池、文件长度、是否有父类等，然后创建对应类的<code>java.lang.Class</code>实例</li><li>第二步，Link阶段包括<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>三个步骤。验证是更详细的校验，比如final是否合规、类型是否正确、静态变量是否合理等；准备阶段是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局。</li><li>第三步，Init阶段执行雷构造器&lt;clinit&gt;方法，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。</li></ol><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="什么是双亲委派机制"><a href="#什么是双亲委派机制" class="headerlink" title="什么是双亲委派机制"></a>什么是双亲委派机制</h3><p>首先，我们知道，虚拟机在加载类的过程中需要使用类加载器进行加载，而在Java中，类加载器有很多，那么当JVM想要加载一个.class文件的时候，到底应该由哪个类加载器加载呢？</p><p>这就不得不提到”双亲委派机制”。</p><p>首先，我们需要知道的是，Java语言系统中支持以下4种类加载器：</p><ul><li>Bootstrap ClassLoader 启动类加载器</li><li>Extention ClassLoader 标准扩展类加载器</li><li>Application ClassLoader 应用类加载器</li><li>User ClassLoader 用户自定义类加载器</li></ul><p>这四种类加载器之间，是存在着一种层次关系的，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021202205232103648.jpeg" alt="-w704"></p><p>一般认为上一层加载器是下一层加载器的父加载器，那么，除了BootstrapClassLoader之外，所有的加载器都是有父加载器的。</p><p>那么，所谓的双亲委派机制，指的就是：<strong>当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。</strong></p><p>那么，什么情况下父加载器会无法加载某一个类呢？</p><p>其实，Java中提供的这四种类型的加载器，是有各自的职责的：</p><ul><li>Bootstrap ClassLoader ，主要负责加载Java核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。</li><li>Extention ClassLoader，主要负责加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。</li><li>Application ClassLoader ，主要负责加载当前应用的classpath下的所有类</li><li>User ClassLoader ， 用户自定义的类加载器,可加载指定路径的class文件</li></ul><p>那么也就是说，一个用户自定义的类，如com.hollis.ClassHollis 是无论如何也不会被Bootstrap和Extention加载器加载的（<code>-Xbootclasspath</code>参数是否可以使得自定义类被bootstrap加载？）。</p><h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="JDK8-CMS：（关注最短垃圾回收停顿时间）"><a href="#JDK8-CMS：（关注最短垃圾回收停顿时间）" class="headerlink" title="JDK8-CMS：（关注最短垃圾回收停顿时间）"></a>JDK8-CMS：（关注最短垃圾回收停顿时间）</h4><p><strong>CMS回收器</strong>（Concurrent Mark Sweep Collector）是回收停顿时间比较短，目前比较常用的垃圾回收器。它通过初始标记（Initial Mark）、并发标记（Concurrent Mark）、重新标记（Remark)、并发清除（Concurrent Sweep）四个步骤完成垃圾回收工作。第1、3步的初始标记和重新标记阶段依然会引发STW。2、4步可以和应用程序并发执行。CMS采用“标记 - 清除算法”，因此产生大量的空间碎片。可以通过<code>-XX:+UseCMSCompactAtFullCollection</code>参数，强制JVM在FGC完成后对老年代进行压缩，执行一次空间碎片整理，但是会引发STW。为了减少STW次数，CMS还可以通过配置<code>-XX:+CMSFullGCsBeforeCompaction=n</code>参数，在执行了n次FGC后，JVM再在老年代执行空间碎片整理。</p><h4 id="JDK9-G1：（精准控制停顿时间，避免垃圾碎片）"><a href="#JDK9-G1：（精准控制停顿时间，避免垃圾碎片）" class="headerlink" title="JDK9-G1：（精准控制停顿时间，避免垃圾碎片）"></a>JDK9-G1：（精准控制停顿时间，避免垃圾碎片）</h4><p>G1（Garbage-First Garbage Collector）垃圾回收器。</p><p>是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器.以极⾼概率满⾜GC停顿时<br>间要求的同时,还具备⾼吞吐量性能特征；相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p><p>【1】基于标记-整理算法，不产生内存碎片。</p><p>【2】可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p><p>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾<br>收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。<strong>区域划</strong><br><strong>分</strong>和<strong>优先级区域</strong>回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p><ul><li><p><strong>初始标记</strong>：<strong>Stop The World，</strong>仅使用一条初始标记线程对GC Roots关联的对象进行标记</p></li><li><p><strong>并发标记</strong>：使用一条标记线程与用户线程并发执行。此过程进行<strong>可达性分析，速度很慢</strong></p></li><li><p><strong>最终标记</strong>：<strong>Stop The World</strong>，使用多条标记线程并发执行</p></li><li><p><strong>筛选回收</strong>：回收废弃对象，此时也要 <strong>Stop The World</strong>，并使用多条筛选回收线程并发执行</p></li></ul><h5 id="G1垃圾回收期原理"><a href="#G1垃圾回收期原理" class="headerlink" title="G1垃圾回收期原理"></a>G1垃圾回收期原理</h5><p>TODO</p><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>2022年6月5日TODO（作为亮点）</p><h4 id="如何配置垃圾收集器"><a href="#如何配置垃圾收集器" class="headerlink" title="如何配置垃圾收集器"></a><strong>如何配置垃圾收集器</strong></h4><ul><li>首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。</li><li>通常，堆空间我会设置成操作系统的 2&#x2F;3，超过 8GB 的堆，优先选用 G1</li><li>然后我会对 JVM 进行初步优化，比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例</li><li>依据系统容量、访问延迟、吞吐量等进行专项优化，我们的服务是高并发的，对 STW 的时间敏感</li><li>我会通过记录详细的 GC 日志，来找到这个瓶颈点，借用 GCeasy 这样的日志分析工具，定位问题</li></ul><h3 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h3><h4 id="MinorGC触发条件"><a href="#MinorGC触发条件" class="headerlink" title="MinorGC触发条件"></a>MinorGC触发条件</h4><p>当Eden区满时触发MinorGC</p><h4 id="FullGC触发条件"><a href="#FullGC触发条件" class="headerlink" title="FullGC触发条件"></a>FullGC触发条件</h4><ol><li>调用System.gc时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足（jdk8之前）</li><li>通过MinorGC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、FromSpace向ToSpace区复制时，对象大小大于ToSpace可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="JVM优化的思路"><a href="#JVM优化的思路" class="headerlink" title="JVM优化的思路"></a>JVM优化的思路</h3><p>1、一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用<code>-Xmn</code>设置年轻代的大小</p><p>2、对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：<code>-XX:PetenureSizeThreshold=1000000</code>，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p><p>3、一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构<code>-XX:MaxTenuringThreshold</code>设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p><p>4、设置最小堆和最大堆：<code>-Xmx</code>和<code>-Xms</code>稳定的堆大小堆垃圾回收是有利的，获得一个稳定的堆大小的方法是设置-Xms和-Xmx的值一样，即最大堆和最小堆一样，如果这样子设置，系统在运行时堆大小理论上是恒定的，稳定的堆空间可以减少GC次数，因此，很多服务端都会将这两个参数设置为一样的数值。稳定的堆大小虽然减少GC次数，但是增加每次GC的时间，因为每次GC要把堆的大小维持在一个区间内。</p><p>5、一个不稳定的堆并非毫无用处。在系统不需要使用大内存的时候，压缩堆空间，使得GC每次应对一个较小的堆空间，加快单次GC次数。基于这种考虑，JVM提供两个参数，用于压缩和扩展堆空间。<br>（1）<code>-XX:MinHeapFreeRatio</code> 参数用于设置堆空间的最小空闲比率。默认值是40，当堆空间的空闲内存比率小于40，JVM便会扩展堆空间<br>（2）<code>-XX:MaxHeapFreeRatio</code> 参数用于设置堆空间的最大空闲比率。默认值是70， 当堆空间的空闲内存比率大于70，JVM便会压缩堆空间。<br>（3）当-Xmx和-Xmx相等时，上面两个参数无效</p><p>6、通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器。<br>（1）<code>-XX:+UseParallelGC</code>:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。<br>（2）<code>-XX:+UseParallelOldGC</code>:设置老年代使用并行垃圾回收收集器。</p><p>7、尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。<code>-XX:+LargePageSizeInBytes</code> 设置内存页的大小</p><p>8、使用非占用的垃圾收集器。<code>-XX:+UseConcMarkSweepGC</code>老年代使用CMS收集器降低停顿。</p><p>9、<code>-XXSurvivorRatio=3</code>，表示年轻代中的分配比率：survivor:eden &#x3D; 2:3</p><p>10、JVM性能调优的工具：<br>（1）jps（Java Process Status）：输出JVM中运行的进程状态信息(现在一般使用jconsole)<br>（2）jstack：查看java进程内线程的堆栈信息。<br>（3）jmap：用于生成堆转存快照<br>（4）jhat：用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）<br>（3）jstat是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。<br>（4）VisualVM：故障处理工具</p><h3 id="生产环境JVM调优具体步骤"><a href="#生产环境JVM调优具体步骤" class="headerlink" title="生产环境JVM调优具体步骤"></a>生产环境JVM调优具体步骤</h3><h5 id="1-监控GC的状态"><a href="#1-监控GC的状态" class="headerlink" title="1.监控GC的状态"></a>1.监控GC的状态</h5><p>使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化。举一个例子，系统崩溃前的一些现象：每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也由之前的0.5s延长到4、5s，FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC，老年代的内存越来越大并且每次FGC后老年代没有内存释放，之后系统会无法响应新的数据，逐渐到达OutMemoryError的临界值，这个时候就需要分析JVM内存快照dump。</p><h5 id="2-生成堆的dump文件"><a href="#2-生成堆的dump文件" class="headerlink" title="2.生成堆的dump文件"></a>2.生成堆的dump文件</h5><p>通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆得大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成改文件。</p><h5 id="3-分析dump文件"><a href="#3-分析dump文件" class="headerlink" title="3.分析dump文件"></a>3.分析dump文件</h5><p>打开这个3G的堆信息文件，显然一般的Windows系统没有这么大的内存，必须借助高配置的Linux，几种工具打开该文件：Visual VM、IBM HeadpAnalyzer、JDK自带的Hprof工具、Mat（Eclipse专门的静态内存分析工具）推荐使用。Tips：文件太大，建议使用Eclipse专门的静态内存工具Mat打开分析。</p><h5 id="4-分析结果，判断是否需要优化"><a href="#4-分析结果，判断是否需要优化" class="headerlink" title="4.分析结果，判断是否需要优化"></a>4.分析结果，判断是否需要优化</h5><p>如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3s，或者频繁GC，则必须优化。注意： 如果满足下面的指标，<strong>则一般不需要进行 GC 优化：</strong></p><blockquote><ul><li>MinorGC 执行时间不到50ms；</li><li>Minor GC 执行不频繁，约10秒一次；</li><li>Full GC 执行时间不到1s；</li><li>Full GC 执行频率不算频繁，不低于10分钟1次。</li></ul></blockquote><h5 id="5-调整GC类型和内存分配"><a href="#5-调整GC类型和内存分配" class="headerlink" title="5.调整GC类型和内存分配"></a>5.调整GC类型和内存分配</h5><p>如果内存分配 过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。</p><h5 id="6-不断的分析和调整"><a href="#6-不断的分析和调整" class="headerlink" title="6.不断的分析和调整"></a>6.不断的分析和调整</h5><p>通过不断的试验和试错，分析并找出最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。</p><p>一般遇到问题就是打出当时的线程信息生成dump然后查异常代码。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651485913&idx=1&sn=c40e03e94a7eb1f62baaa09173afc860&chksm=bd251aa68a5293b00dd0228451e19eef1e98684e5d596bbed2d647b8530e02eac2042580870e&scene=21#wechat_redirect">附：JVM 性能调优监控工具 jps、jstack、jmap、jhat、jstat、hprof 使用详解</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.hollischuang.com/archives/6055">我竟然被”双亲委派”给虐了！</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;对象已经死亡？&quot;&gt;&lt;a href=&quot;#对象已经死亡？&quot; class=&quot;headerlink&quot; title=&quot;对象已经死亡？&quot;&gt;&lt;/a&gt;对象已经死亡？&lt;/h2&gt;&lt;h3 id=&quot;如何判断一个类是无用的类&quot;&gt;&lt;a href=&quot;#如何判断一个类是无用的类&quot; cl</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>多线程面试题</title>
    <link href="https://blog.elfred.top/posts/531c5825.html"/>
    <id>https://blog.elfred.top/posts/531c5825.html</id>
    <published>2021-01-23T08:23:00.000Z</published>
    <updated>2025-03-08T14:46:55.122Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h3><h3 id="进程上下文切换开销都有哪些？"><a href="#进程上下文切换开销都有哪些？" class="headerlink" title="进程上下文切换开销都有哪些？"></a>进程上下文切换开销都有哪些？</h3><p>那么上下文切换的时候，CPU的开销都具体有哪些呢？开销分成两种，一种是直接开销、一种是间接开销。</p><p>直接开销就是在切换时，cpu必须做的事情，包括：</p><ul><li><p>1、切换页表全局目录</p></li><li><p>2、切换内核态堆栈</p></li><li><p>3、切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</p></li><li><ul><li>ip(instruction pointer)：指向当前执行指令的下一条指令</li><li>bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址</li><li>sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址</li><li>cr3:页目录基址寄存器，保存页目录表的物理地址</li><li>……</li></ul></li><li><p>4、刷新TLB</p></li><li><p>5、系统调度器的代码执行</p></li></ul><p>间接开销主要指的是虽然切换到一个新进程后，由于各种缓存并不热，速度运行会慢一些。如果进程始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。其实我们上面的实验并没有很好地测量到这种情况，所以实际的上下文切换开销可能比3.5us要大。</p><p>想了解更详细操作过程的同学请参考《深入理解Linux内核》中的第三章和第九章。</p><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p><h2 id="原子性、有序性和可见性"><a href="#原子性、有序性和可见性" class="headerlink" title="原子性、有序性和可见性"></a>原子性、有序性和可见性</h2><h3 id="final关键字的可见性"><a href="#final关键字的可见性" class="headerlink" title="final关键字的可见性"></a>final关键字的可见性</h3><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><h3 id="CAS有什么问题？"><a href="#CAS有什么问题？" class="headerlink" title="CAS有什么问题？"></a>CAS有什么问题？</h3><p>CAS的缺点有如ABA问题，自旋锁消耗问题、多变量共享一致性问题：</p><p>1.<strong>ABA</strong>：<br>问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。</p><p>解决方法：CAS还是类似于乐观锁，同数据乐观锁的方式给它加一个版本号或者时间戳，如AtomicStampedReference</p><p>2.<strong>自旋消耗资源</strong>：<br>问题描述：多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。</p><p>解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。</p><p>JDK8新增的LongAddr和ConcurrentHashMap类似的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来。虽然base和cells都是volatile修饰的，但感觉这个sum操作没有加锁，可能sum的结果不是那么精确。</p><p>3.<strong>多变量共享一致性问题</strong>：<br>解决方法： CAS操作是针对一个变量的，如果对多个变量操作，解决方案如下</p><ol><li>可以加锁来解决</li><li>封装成对象类解决</li></ol><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程里，也可以是在不同的线程里。</p><p>与程序员密切相关的happens-before规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li></ul><blockquote><p><strong>注意：</strong>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p></blockquote><h3 id="单线程、多线程在单核CPU、多核CPU中的影响"><a href="#单线程、多线程在单核CPU、多核CPU中的影响" class="headerlink" title="单线程、多线程在单核CPU、多核CPU中的影响"></a>单线程、多线程在单核CPU、多核CPU中的影响</h3><p>我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p><p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p><p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p><p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在<strong>缓存一致性问题</strong>，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;h3 id=&quot;进程和线程的区别？&quot;&gt;&lt;a href=&quot;#进程和线程的区别？&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>2021面经</title>
    <link href="https://blog.elfred.top/posts/416557c5.html"/>
    <id>https://blog.elfred.top/posts/416557c5.html</id>
    <published>2021-01-20T08:49:00.000Z</published>
    <updated>2025-03-08T14:46:55.119Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="叮咚买菜"><a href="#叮咚买菜" class="headerlink" title="叮咚买菜"></a>叮咚买菜</h3><ul><li><p>hashmap的扩容过程</p></li><li><p>单向链表如何判断有环</p><blockquote><p>HashSet遍历和快慢指针</p></blockquote></li><li><p>如何找出一个数组重复元素最多的前K个元素</p><blockquote><p>TopK问题，堆排序，时间复杂度nLogK</p></blockquote></li><li><p>MySQL什么情况下会发生死锁？如何解决？</p><blockquote><p>举个例子：事务A按照先后顺序去更新id&#x3D;1和id&#x3D;2的记录，事务B同一时间按照先后顺序去更新id&#x3D;2和id&#x3D;1的记录，因为行锁是两阶段协议，A获得id&#x3D;1的行锁不会马上释放，此时B会等待A释放id&#x3D;1的行锁，而A会等待B释放id&#x3D;2的行锁，这样就形成了死锁。<br><strong>如何解决：</strong></p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li></ul></blockquote></li><li><p>ArrayList的contains方法和HashSet的contains方法的时间复杂度各是多少</p><blockquote><p>O(n)和O(1）</p></blockquote></li><li><p>2个线程，A生产数据，B消费数据，有哪几种实现形式（使用LinkedList实现有哪些需要注意的，线程安全问题，如何解决：加锁）</p></li><li><p>一个抽奖系统，奖品1的概率是10%，奖品2的概率是20%，不中奖的概率是70%，算法如何实现？</p><blockquote><p>随机数和区间</p></blockquote></li><li><p>缓存一致性如何保证？</p><blockquote><p>最好的解决方案是先更新数据库再删除缓存（在极端情况下也会有问题，比如说B线程更新数据的节点，缓存正好失效，此时线程A读取到了旧值，随后B操作数据库完成更新并且删除缓存之后，A再把旧值写入缓存，此时再去请求拿到的会是脏数据，这种概率非常低，基本可以忽略）</p></blockquote></li><li><p>Dubbo IO线程池和业务线程池有什么区别？默认是哪种线程池（Fixed）</p></li><li><p>使用Dubbo有没有遇到什么坑？</p><blockquote><ul><li>父子类有相同属性时值丢失：hessian序列化问题</li><li>自定义异常被包装成RuntimeException</li><li>Data length too large</li><li>线程耗尽：Provider默认是fixed线程池，且线程数为200</li></ul><p><a href="https://blog.csdn.net/u013256816/article/details/102674846"><strong>具体参考链接</strong></a></p></blockquote></li><li><p>网关是用来做什么的？为什么要用网关？</p></li><li><p>乐观锁和悲观锁有什么区别？乐观锁有哪些实现方式？（版本号机制和CAS算法）</p><blockquote><p>版本号机制和CAS算法</p></blockquote></li><li><p>线程池主要有哪些东西？线程池中如果没有任务，会是什么状态？</p></li><li><p>项目中遇到的技术难题，是如何解决的？</p></li><li><p>分库分表一些连表问题和条件查询是如何解决的？</p><blockquote><p>分两次查询，第一次把联表的id查出来，通过这些id再做一次查询</p></blockquote></li></ul><span id="more"></span><h3 id="东方头条"><a href="#东方头条" class="headerlink" title="东方头条"></a>东方头条</h3><ul><li><p>悲观锁和乐观锁的使用场景</p><blockquote><p>读多写少的场景用乐观锁，读少写多的场景用悲观锁</p></blockquote></li><li><p>redis线上使用应该注意什么？哪些命令会导致堵塞</p><blockquote><p>keys，避免使用keys，用scan替代，scan有个问题就是可能会查到重复的key，我们在内存里去重就好了</p></blockquote></li><li><p>设计一个程序，将1s内访问超过三次的IP禁掉</p></li></ul><h3 id="盒马"><a href="#盒马" class="headerlink" title="盒马"></a>盒马</h3><ul><li><p>如何避免死锁</p><blockquote><ul><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用lock.tryLock(timeout) 来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库链接里，否则会出现解锁失败的情况。</li></ul></blockquote></li><li><p>CHM（ConcurrentHashMap）1.7版本segment数组长度是多少（最小16，根据不同型号CPU可能有所不同）</p></li><li><p>序列化原理是什么？为什么要序列化</p></li><li><p>JVM如何给对象分配内存</p><blockquote><p>当创建一个对象时，需要给新生对象分配内存，而分配内存 就是在堆上进行分配。在堆上进行分配的时候，可能在新生代的Eden区上，也可能在老年代中分配，具体的分配策略需要参考一些内存分配的规则：</p><ol><li>优先在eden区分配：大多数情况下，新生对象都在新生代的Eden区进行内存分配，当新生代Eden区没足够空间的时候，会触发一次Minor GC</li><li>大对象直接进入老年代：当一个新生对象需要大量连续空间并且对象所需空间大于-XX:PretenureSizeThreshold参数值的时候，这个对象将在老年代分配内存空间，这样可以避免新生代发生大量的内存复制。</li><li>年龄大的存活对象进入老年代：在新生代每经过一次Minor GC，存活对象的年龄都会增加一岁，当年龄超过-XX:MaxTenuringThreshold参数值的时候，这个对象将进入老年代</li></ol><p><strong>动态对象年龄判断</strong>：如果新生代Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄等于或超过该年龄的对象将直接进入老年代，不再等待年龄超过-XX:MaxTenuringThreshold参数值的条件进入老年代。</p></blockquote></li><li><p>如何解决超卖问题</p></li></ul><h3 id="平安金服"><a href="#平安金服" class="headerlink" title="平安金服"></a>平安金服</h3><ul><li><p>SQL语句的执行顺序</p><blockquote><p>SQL的执行顺序：from—where–group by—having—select—order by</p></blockquote></li></ul><h3 id="掌门一对一"><a href="#掌门一对一" class="headerlink" title="掌门一对一"></a>掌门一对一</h3><ul><li><p>进程和线程的区别</p><blockquote><ol><li>进程是操作系统资源分配的最小单位，线程是CPU任务调度的最小单位。一个进程可以包含多个线程，所以进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</li><li>不同进程间数据很难共享，同一进程下不同线程间数据很易共享。</li><li>每个进程都有独立的代码和数据空间，进程要比线程消耗更多的计算机资源。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉。</li><li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</li></ol></blockquote></li><li><p>SpringBean的生命周期</p><blockquote><p>SpringBean 生命周期简单概括为4个阶段：</p><ol><li>实例化，创建一个Bean对象</li><li>填充属性，为属性赋值</li><li>初始化<ul><li>如果实现了<code>xxxAware</code>接口，通过不同类型的Aware接口拿到Spring容器的资源</li><li>如果实现了BeanPostProcessor接口，则会回调该接口的<code>postProcessBeforeInitialzation</code>和<code>postProcessAfterInitialization</code>方法</li><li>如果配置了<code>init-method</code>方法，则会执行<code>init-method</code>配置的方法</li></ul></li><li>销毁<ul><li>容器关闭后，如果Bean实现了<code>DisposableBean</code>接口，则会回调该接口的<code>destroy</code>方法</li><li>如果配置了<code>destroy-method</code>方法，则会执行<code>destroy-method</code>配置的方法</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210113194641.jpeg" alt="生命周期"></p></blockquote></li></ul><h3 id="微盟"><a href="#微盟" class="headerlink" title="微盟"></a>微盟</h3><ul><li><p>redis哨兵模式和cluster模式的区别以及原理？</p></li><li><p>Redis集群一般使用哪一种方案（cluser），cluser如何做到水平拓展的？</p></li><li><p>redis分布式锁如果加锁失败或者释放锁失败了怎么办？（如何保证加锁的安全性）</p></li><li><p>一致性哈希原理</p></li><li><p>redis单线程的理解，为什么选用单线程</p><blockquote><ol><li>使用单线程模型能带来更好的可维护性，方便开发和调试；</li><li>使用单线程模型也能并发的处理客户端的请求（I&#x2F;O多路复用）；</li><li>Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU，主要在内存和网络；</li></ol></blockquote></li><li><p>redis单线程为什么这么快？</p><blockquote><ol><li><strong>纯内存操作</strong>：读取不需要进行磁盘 I&#x2F;O，所以比传统数据库要快上不少；*(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)*</li><li><strong>单线程，无锁竞争</strong>：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；</li><li><strong>多路 I&#x2F;O 复用模型，非阻塞 I&#x2F;O</strong>：采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；</li><li><strong>高效的数据结构，加上底层做了大量优化</strong>：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..</li></ol></blockquote></li><li><p>聊聊对Redis I&#x2F;O多路复用的理解</p><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote></li><li><p>缓存穿透是什么？如何解决？</p><blockquote><p>拿一些缓存和数据库中都没有的非法参数进行请求；设置null值或者布隆过滤器。</p></blockquote></li><li><p>布隆过滤器使用场景和原理是什么？为什么会存在一定的误差？</p><blockquote><p><strong>应用场景</strong>主要有：</p><ol><li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li><li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li></ol><p><strong>布隆过滤器的原理</strong>是创建一个位数组，位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit &#x2F; 8 &#x3D; 125000 Byte &#x3D; 125000&#x2F;1024 kb ≈ 122kb 的空间。<strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p><p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md"><strong>具体参考这里</strong></a></p></blockquote></li><li><p>Redis布隆过滤器命令是什么？</p><blockquote><p><strong><code>BF.ADD </code>、<code>BF.MADD</code>、<code>BF.EXISTS</code> 、<code>BF.MEXISTS</code>、<code>BF.RESERVE</code></strong></p></blockquote></li><li><p>MySQL行锁的原理，锁的到底是什么？（索引）</p></li><li><p>对MVCC的理解，MVCC到底解决了什么问题？（乐观锁实现，提高性能读写冲突不加锁）</p><blockquote><p>MVCC是乐观锁的一种实现，读写冲突不加锁，提高了性能</p></blockquote></li><li><p>MVCC能解决幻读吗？</p><blockquote><p>MVCC不能彻底解决幻读，只能解决读情况下的幻读，写的幻读是通过加锁来解决。</p></blockquote></li><li><p>分布式事务如何解决？基于CAP理论和2PC，TCC是什么</p></li><li><p>MySQL深分页会有什么问题？（比如LIMIT 1000,100）如何解决？</p><blockquote><p><strong>深分页为什么会慢</strong>：举个例子，select * from where status &#x3D; 1 limit 10000,20，即使知道前10000个会丢掉，mysql也会去聚集索引上查一遍数据（回表），自然速度就非常慢，这里是因为limit offset只能作用于引擎层返回的结果集。换句话说，引擎层也很无辜，他并不知道这10000个是要扔掉的。<a href="https://blog.csdn.net/fengzongfu/article/details/103191867"><strong>具体参考点击这里</strong></a></p><p><strong>如何解决</strong>：</p><ol><li>根据实际业务需求，看是否能替换成下一页，上一页这种，这里是说，把limit,offset替换为&gt;辅助索引（即搜索条件）id的方式。该id再调用时，需要返回给前端。</li><li>覆盖索引：当辅助索引查询的数据，只有id和辅助索引本身，那么就不必再去回表查询。思路如下：select * from t wherer id in (select id from t where second_index &#x3D; xxx limit 10000,20)，这句话是说，先从条件查询中，查找数据对应的id，因为主键在辅助索引上就有，所以不用会回表查询。再通过这些已经被limit出来的id，去查聚集索引，这样只会20次随机IO。（或者用JOIN去优化，原理类似select * from t a join (select id from t where second_index &#x3D; xxx limit 10000,20) b on a.id&#x3D;b.id）</li></ol></blockquote></li><li><p>kafka内部是如何保证消息的幂等性？</p><blockquote><p>消息语义，精准一次性，消息高水位待补充</p></blockquote></li><li><p>如何保证kafka消息的全局的顺序性（设置key可以保证分区顺序性）</p><blockquote><p>设置相同的key可以保证分区的顺序性，全局顺序性可以设置一个 topic，一个 partition，一个 consumer</p></blockquote></li><li><p>kakfa ISR机制的原理</p></li><li><p>哲学家进餐问题</p></li></ul><h3 id="微盟二面"><a href="#微盟二面" class="headerlink" title="微盟二面"></a>微盟二面</h3><ul><li><p>dubbo有哪些组件（分层）？</p><blockquote><p>从大的范围来说，dubbo分为三层，business业务逻辑层由我们自己来提供接口和实现还有一些配置信息，RPC层就是真正的RPC调用的核心层，封装整个RPC的调用过程、负载均衡、集群容错、代理，remoting则是对网络传输协议和数据转换的封装。</p><p>划分到更细的层面，就是图中的10层模式，整个分层依赖由上至下，除开business业务逻辑之外，其他的几层都是SPI机制。<br><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210118154630.webp" alt="图片"></p></blockquote></li><li><p>简单讲讲dubbo服务注册与发现（服务暴露）的过程</p><blockquote><ol><li><p>在容器启动的时候，通过ServiceConfig解析标签，创建dubbo标签解析器来解析dubbo的标签，容器创建完成之后，触发ContextRefreshEvent事件回调开始暴露服务</p></li><li><p>通过ProxyFactory获取到invoker，invoker包含了需要执行的方法的对象信息和具体的URL地址</p></li><li><p>再通过DubboProtocol的实现把包装后的invoker转换成exporter，然后启动服务器server，监听端口</p></li><li><p>最后RegistryProtocol保存URL地址和invoker的映射关系，同时注册到服务中心</p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210118154814.webp" alt="图片"></p></li></ol></blockquote></li><li><p>讲讲缓存穿透（布隆过滤器的原理）</p></li><li><p>JVM内存区域</p><blockquote><ol><li>程序计数器（线程私有）：指向当前线程正在执行的字节码指令</li><li>虚拟机栈（线程私有）：虚拟机栈描述的是Java方法执行的线程内存模型：每个方法执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量、操作数栈、动态连接、方法出口等信息。</li><li>本地方法栈（线程私有）：调用本地native的内存模型</li><li>堆（线程共享）：Java对象存储的地方<br>（1）Java堆是虚拟机管理的内存中最大的一块<br>（2）Java堆是所有线程共享的区域<br>（3）在虚拟机启动时创建<br>（4）此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。存放new生成的对象和数组<br>（5）Java堆是垃圾收集器管理的内存区域，因此很多时候称为“GC堆”</li><li>方法区（线程共享）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据<br><strong>运行时常量池：</strong><br>A、是方法区的一部分<br>B、存放编译期生成的各种字面量和符号引用<br>C、Class文件中除了存有类的版本、字段、方法、接口等描述信息，还有一项是常量池，存有这个类的 编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/202120210125231657.png" alt="图片"></p></blockquote></li><li><p>分库分表之后多条件查询如何处理？（宽表或者ES）</p></li><li><p>MySQL最左匹配原则的原理</p></li><li><p>介绍下AQS</p></li><li><p>用过哪些JUC包下的类，场景各是什么？</p></li><li><p>docker之间是如何通信的</p></li></ul><h3 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h3><ul><li><p>excel大文件上传OOM的问题如何解决</p></li><li><p>分库分表之后的JOIN如何处理，分页如何处理</p><blockquote><p>TODO待补充</p></blockquote></li><li><p>MySQL是如何保证ACID的</p><blockquote><p>A（原子性）：<code>undo log</code>记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p><p>C（一致性）：从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。</p><p>I（隔离性）：MVCC保证了读的隔离性；排它锁保证写的隔离性。</p><p>D（持久性）：使用了WAL(Write-Ahead Logging，先写日志再写磁盘)。Redo log就是一种WAL的应用。当数据库忽然掉电，再重新启动时，MySQL可以通过Redo log还原数据。</p></blockquote></li></ul><h3 id="怪兽充电"><a href="#怪兽充电" class="headerlink" title="怪兽充电"></a>怪兽充电</h3><ul><li><p>几种分布式id生成方案，各有什么问题</p><blockquote><ol><li>UUID，性能较差，MySQL官方不推荐，会引起磁盘数据位置频繁变动</li><li><code>SNOWFLAKE</code>（雪花算法）是默认使用的主键生成方案，生成一个 64bit的长整型（<code>Long</code>）数据。<code>sharding-jdbc</code> 中雪花算法生成的主键主要由 4部分组成，<code>1bit</code>符号位、<code>41bit</code>时间戳位、<code>10bit</code>工作进程位以及 <code>12bit</code> 序列号位。</li><li>Tinyid</li></ol><p><a href="https://juejin.cn/post/6892959738670743565">具体参考链接</a></p></blockquote></li></ul><h3 id="快货运"><a href="#快货运" class="headerlink" title="快货运"></a>快货运</h3><ul><li><p>分布式锁（或其他互斥锁）如何保证安全的前提下同时提高性能</p><blockquote><p>使用分段锁：比如1000个库存分成10份，每个请求hash到不同的key上，最后再汇总</p></blockquote></li></ul><h3 id="一药网"><a href="#一药网" class="headerlink" title="一药网"></a>一药网</h3><ul><li><p>dubbo的线程模型</p></li><li><p>spring事务失效的场景</p></li><li><p>类加载过程</p><blockquote><p>类加载过程分为三个阶段：Load、Link和Init，即<strong>加载</strong>、<strong>链接</strong>、<strong>初始化</strong></p><ol><li>第一步，Load阶段读取类文件产生二进制流，并转化为特定的数据结构，初步校验cafe babe魔法数、常量池、文件长度、是否有父类等，然后创建对应的java.lang.Class实例</li><li>第二步，Link阶段包括<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>三个步骤。验证是更详细的校验，比如final是否合规、类型是否正确、静态变量是否合理等；准备阶段是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局。</li><li>第三步，Init阶段执行雷构造器&lt;clint&gt;方法，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。</li></ol></blockquote></li><li><p>包名和类名一样的两个类冲突如何解决</p></li></ul><h3 id="喜马拉雅"><a href="#喜马拉雅" class="headerlink" title="喜马拉雅"></a>喜马拉雅</h3><ul><li><p>JVM是基于栈还是寄存器进行解释的（栈）</p></li><li><p>new一个对象，实际发生了什么？（操作系统层面和JVM层面）</p></li><li><p>创建一个线程，对于操作系统来说到底发生了什么（CPU和内存方面）</p></li><li><p>线程切换有什么损耗？</p><blockquote><p>线程切换的时候还要执行内存换页，CPU 的缓存被清空,切换回来的时候还要重新从内存中读取信息,破坏了数据的局部性</p></blockquote></li><li><p>volatile保证的内存可见性是指什么？禁止重排序的原理</p></li><li><p>JMM的工作内存是在哪里？（CPU高速缓存，逻辑上部分属于栈）</p></li><li><p>操作系统线程和JVM线程的区别</p></li><li><p>leetcode98</p></li></ul><h3 id="货拉拉"><a href="#货拉拉" class="headerlink" title="货拉拉"></a>货拉拉</h3><ul><li>类的加载过程</li><li>类的卸载</li><li>JVM内存区域</li><li>常用垃圾回收器和GC算法，三色标记</li><li>垃圾回收的过程</li><li>设计一个高并发系统，例如秒杀系统</li></ul><h3 id="货拉拉二面"><a href="#货拉拉二面" class="headerlink" title="货拉拉二面"></a>货拉拉二面</h3><ul><li><p>强引用、软应用、弱引用、虚应用的区别以及使用场景</p><blockquote><p><strong>强引用，即Strong Reference，</strong>最为常见。如Object &#x3D; new Object()；这样的变量声明和定义就会产生对该对象的强引用。只要对象有强引用指向，并且GC Roots可达，那么Java内存回收时，也不会回收该对象。</p><p><strong>软引用，即Soft Reference，</strong>引用力度弱于”强引用“，是用在非必需对象的场景。在即将OOM之前，垃圾回收器会把这些软引用指向的对象加入回收范围，以获得更多的内存空间，让程序能够继续健康运行。主要用来缓存服务器中间计算结果及不需要实时保存的用户行为等。</p><p><strong>弱引用，即Weak Reference，</strong>引用强度较前两者更弱，也是用来描述非必需对象的。如果弱引用指向的对象只存在弱引用这一条线路，则在下一次YGC时会被回收。由于YGC时间的不确定性，弱引用何时被回收也具有不确定性。弱引用主要用于指向某个易消失的对象，在强引用断开后，此引用不会劫持对象。调用WeakReference.get()可能会返回null，要注意空指针异常。</p><p><strong>虚引用，即Phantom Reference，</strong>是极弱的一种引用关系，定义完成后，就无法通过该引用获取指向的对象。为一个对象设置虚引用的唯一目的就是希望能在这个对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用，当垃圾回收时，如果发现存在虚引用，就会在回收对象内存前，把这个虚引用加入与之关联的引用队列中。</p></blockquote></li><li><p>caffeine和guava区别，为什么选caffeine，caffeine的优势</p></li></ul><h3 id="涂鸦智能"><a href="#涂鸦智能" class="headerlink" title="涂鸦智能"></a>涂鸦智能</h3><ul><li><p>spring拓展点用过吗？（前置后置处理器，bean生命周期相关）</p></li><li><p>MySQL事务的原子性是如何保证的？</p><blockquote><p>通过undolog来保证原子性</p></blockquote></li><li><p>Kafka架构设计</p></li><li><p>Redis单线程为什么这么快</p></li><li><p>Redis单线程的理解</p></li><li><p>dubbo接口如果超时了，问题排查的思路</p></li></ul><h3 id="蔚来"><a href="#蔚来" class="headerlink" title="蔚来"></a>蔚来</h3><ul><li>介绍下cas算法</li><li>redis缓存雪崩如何解决</li><li>redis哨兵模式如何保证高可用</li><li>分库分表之后联表如果是两次查询的话性能会很差吗</li></ul><h3 id="阿里（企业智能）"><a href="#阿里（企业智能）" class="headerlink" title="阿里（企业智能）"></a>阿里（企业智能）</h3><ul><li><p>dubbo的原理是什么（工作原理）</p><blockquote><ol><li>服务启动的时候，provider和consumer根据配置信息，连接到注册中心register，分别向注册中心注册和订阅服务</li><li>register根据服务订阅关系，返回provider信息到consumer，同时consumer会把provider信息缓存到本地。如果信息有变更，consumer会收到来自register的推送</li><li>consumer生成代理对象，同时根据负载均衡策略，选择一台provider，同时定时向monitor记录接口的调用次数和时间信息</li><li>拿到代理对象之后，consumer通过代理对象发起接口调用</li><li>provider收到请求后对数据进行反序列化，然后通过代理调用具体的接口实现</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210118160303.webp" alt="图片"></p></blockquote></li><li><p>zookeeper的选举机制以及如何保证整个注册中心的稳定性</p><blockquote><p><strong>选举算法和流程：FastLeaderElection(默认提供的选举算法)：</strong></p><p>目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p><ol><li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。</li><li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。</li><li>服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为leader，服务器1,2成为follower。</li><li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为follower。</li><li>服务器5启动，后面的逻辑同服务器4成为follower。</li></ol></blockquote></li><li><p>动态代理的实现方式，AOP的实现方式，有什么区别？</p><blockquote><ol><li>JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</li><li>CGlib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li><li>区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。</li></ol></blockquote></li><li><p>ThreadLocal的原理</p></li><li><p>Redis持久化机制</p></li><li><p>一致性哈希原理</p></li><li><p>缓存击穿和缓存雪崩是什么？如何解决</p><blockquote><p><strong>击穿：</strong>1.热点数据永不失效；2.从数据库加载缓存数据的时候加互斥锁</p><p><strong>雪崩：</strong><br><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol></blockquote></li><li><p>Java CPU负载100%排查技巧</p><blockquote><ol><li>top命令按照CPU排序找到占用高的java进程pid比如<code>9702 </code></li><li>top -H -p pid查看这个进程中，消耗CPU最多的线程比如<code>10007</code>（<code>top -Hbp 9702 | awk &#39;/java/ &amp;&amp; $9&gt;50&#39;</code>这个命令表示查出CPU占用率超过某个值的所有线程，例如超过50%）</li><li>线程id转换为十六进制<code>printf &quot;%x\n&quot; 10007</code> 16进制id为<code>2717</code></li><li>使用jstack吧线程信息打印出来：<code>jstack $pid | grep 2717</code></li></ol></blockquote></li><li><p>死锁如何检测</p><blockquote><p>jsp -l 得到进程pid，然后jstack -l pid</p></blockquote></li></ul><h3 id="有赞"><a href="#有赞" class="headerlink" title="有赞"></a>有赞</h3><ul><li><p>异步更新缓存，如果该缓存是基于多张表算出来的话，应该如何更新</p></li><li><p>Kafka和RocketMQ的区别（分层设计和存储的区别）</p></li><li><p>MQ的顺序消息、事务消息、延迟消息是什么</p></li><li><p>Dubbo SPI机制和Java SPI机制的区别</p></li><li><p>Redis跳表的原理</p></li><li><p>Redis缓存穿透和缓存击穿以及如何解决</p></li><li><p>MySQL MVCC原理介绍一下</p></li><li><p>ThreadLocal的原理，ThreadLocalMap的key是什么？</p><blockquote><p>ThreadLocalMap的key是ThreadLocal的实例，因为一个线程可以有多个ThreadLocal变量</p></blockquote></li><li><p>synchronized和Lock的区别</p></li><li><p>Future原理</p></li><li><p>netty原理</p></li></ul><h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><ul><li><p>DDD的理解</p></li><li><p>如何保证系统的高可用</p></li><li><p>系统上游挂了怎么办，降级的话如何降级</p></li><li><p>流量突增的情况下，在不修改代码的情况下，如何应对这种场景</p></li><li><p>Redis持久化配置</p><blockquote><ul><li>不要仅仅使用 RDB，因为那样会导致你丢失很多数据；</li><li>也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</li><li>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li></ul></blockquote></li><li><p>Redis删除策略</p></li><li><p>缓存穿透、缓存雪崩（雪崩的话可以异步去刷新缓存时间）</p></li><li><p>Redis大key会有什么问题？大key如何优化</p><blockquote><p><strong>大key的风险：</strong><br>1.读写大key会导致超时严重，甚至阻塞服务。</p><p>2.如果删除大key，DEL命令可能阻塞Redis进程数十秒，使得其他请求阻塞，对应用程序和Redis集群可用性造成严重的影响。</p><p><strong>redis使用会出现大key的场景：</strong></p><p>1.单个简单key的存储的value过大；</p><p>2.hash、set、zset、list中存储过多的元素。</p><p><strong>解决问题：</strong></p><p>单个简单key的存储的value过大的解决方案：</p><ul><li>将大key拆分成对个key-value，使用multiGet方法获得值，这样的拆分主要是为了减少单台操作的压力，而是将压力平摊到集群各个实例中，降低单台机器的IO操作。</li></ul><p>hash、set、zset、list中存储过多的元素的解决方案：</p><ul><li><p>类似于第一种场景，使用第一种方案拆分;</p></li><li><p>以hash为例，将原先的hget、hset方法改成（加入固定一个hash桶的数量为10000），先计算field- 的hash值模取10000，确定该field在哪一个key上。</p></li></ul></blockquote></li><li><p>Redis基础数据结构</p></li><li><p>MySQL INNODB引擎没有设置主键会有什么问题</p><blockquote><ul><li>使用不了主键索引，查询会进行全表扫描</li><li>影响数据插入性能，插入数据需要生成ROW_ID，而生成的ROW_ID是全局共享的，并发会导致锁竞争，影响性能</li></ul></blockquote></li><li><p>B+Tree索引和Hash索引的优劣</p></li><li><p>MySQL可重复读隔离级别下读和写是如何加锁的？</p></li><li><p>行锁是加在什么上面？（索引）</p></li><li><p>JVM优化的思路（保持jvm的稳定，避免频繁gc）</p><blockquote><p><strong>策略 1：</strong>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p><p><strong>策略 2：</strong>大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。<code>-XX:PretenureSizeThreshold</code> 可以设置直接进入老年代的对象大小。</p><p><strong>策略 3：</strong>合理设置进入老年代对象的年龄，<code>-XX:MaxTenuringThreshold</code> 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。</p><p><strong>策略 4：</strong>设置稳定的堆大小，堆大小设置有两个参数：<code>-Xms</code> 初始化堆大小，<code>-Xmx</code> 最大堆大小。</p><p><strong>策略5：</strong>注意： 如果满足下面的指标，<strong>则一般不需要进行 GC 优化：</strong></p><blockquote><p>MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。</p></blockquote></blockquote></li><li><p>发现虚拟机频繁full GC时应该怎么办（full GC指的是清理整个堆空间，包括年轻代和永久代）</p><blockquote><ol><li>首先用命令查看触发GC的原因是什么 jstat –gccause 进程id</li><li>如果是System.gc()，则看下代码哪里调用了这个方法（可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc）</li><li>如果有perm gen的话（jdk1.8就没了），<strong>要给perm gen分配空间，但没有足够的空间时</strong>，会触发full gc。所以看看是不是perm gen区的值设置得太小了。</li><li>如果是一次fullgc之后，剩余对象不多。那么说明你的eden区设置太小，导致生命周期的对象进入了老年代。</li><li>如果一次fullgc之后，老年代回收率不大，那么说明老年代太小。</li><li>如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令</li><li>如果是GC locker，可能是程序依赖的JNI库的原因</li></ol></blockquote></li><li><p>垃圾回收算法</p><blockquote><p><strong>Mark-Sweep（标记-清除算法）：</strong></p><p>（1）思想：标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。<br>（2）优缺点：实现简单，容易产生内存碎片，导致需要分配一个较大连续空间时容易触发FGC。</p><p><strong>Copying（复制清除算法）：</strong></p><p>（1）思想：将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。<br>（2）优缺点：不容易产生内存碎片；可用内存空间少；存活对象多的话，效率低下。</p><p><strong>Mark-Compact（标记-整理算法）：</strong></p><p>（1）思想：先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存。<br>（2）优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下</p><p><strong>分代收集算法：</strong>（目前大部分JVM的垃圾收集器所采用的算法，思想：把堆分成新生代和老年代，永久代指的是方法区）：</p><p>（1） 因为新生代每次垃圾回收都要回收大部分对象，所以新生代采用<strong>Copying</strong>算法。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。<br>（2） 由于老年代每次只回收少量的对象，因此采用<strong>mark-compact</strong>算法。<br>（3） 在堆区外有一个永久代。对永久代的回收主要是无效的类和常量</p></blockquote></li><li><p>CMS是怎么进行垃圾回收的？（相关：G1垃圾回收过程）</p><blockquote><p><strong>CMS收集器</strong>基于“标记-清除”算法：</p><p>优点有：并发收集、低停顿</p><p>缺点：对CPU资源非常敏感，导致程序变慢，CMS无法处理浮动垃圾，容易 产生大量空间碎片。</p><p>垃圾回收过程分为四个步骤：<strong>初始标记</strong>、<strong>并发标记</strong> 、<strong>重新标记</strong> 、<strong>并发清除：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210121172804.png" alt="CMS 垃圾收集器 "></p><p><strong>G1 收集器</strong>基于“标记-整理”算法：</p><p>优点有：</p><ol><li>不产生内存碎片</li><li>可以非常精确的控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收</li></ol><p>G1工作过程分为几个步骤：<strong>初始标记</strong>、<strong>并发标记</strong>、<strong>最终标记</strong>、<strong>筛选回收</strong>。</p></blockquote></li><li><p>生产环境遇到JVM问题如何去解决？解决的步骤有哪些</p></li><li><p>并发编程线程安全三大问题：可见性、有序性、原子性分别如何去保证？</p><blockquote><p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化</strong>和<strong>使用内存屏障</strong>。</p><ul><li><p><strong>可见性</strong>：除了<code>volatile</code>之外，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性</p></li><li><p><strong>有序性</strong>：在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：</p><p><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p></li><li><p><strong>原子性</strong>：在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。这两个字节码，在Java中对应的关键字就是<code>synchronized</code>。</p><p>因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p></li></ul></blockquote></li><li><p>volatile如何保证可见性</p><blockquote><p>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条<strong>Lock</strong>前缀的指令，将这个变量所在缓存行的数据写回到系统内存。在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>volatile两条实现原则：</p><ol><li><strong>Lock前缀指令会引起处理器缓存回写到内存</strong>。LOCK#信号确保在声言该信号期间，处理器可以独占共享内存（通过锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存）。但在最近的处理器里，LOCK#信号一般不锁总线，而是锁缓存，锁总线开销比较大。在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确定修改的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性会阻止同时修改由两个以上处理器缓存的内存区域数据</strong>。</li><li><strong>一个处理器的缓存会写到内存会导致其他处理器的缓存无效</strong>。部分处理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。处理器使用<strong>嗅探技术</strong>保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。</li></ol></blockquote></li><li><p>volatile如何保证有序性</p><blockquote><p>它是通过<strong>内存屏障</strong>来实现的。</p><p>什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：</p><ol><li>阻止屏障两侧的指令重排序；</li><li>强制把写缓冲区&#x2F;高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</li></ol></blockquote></li><li><p>volatile能否保证原子性？</p><blockquote><p>不能。Num++这种操作无法保证原子性，Num++可以分为三步：读取i的值，将i的值+1，写入最新的i值。</p><p>举个例子：当线程1执行Num++语句时，先是读入Num的值为0，倘若此时让出CPU执行权，线程2获得执行，线程2会重新从主内存中，读入Num的值还是0，然后线程2执行+1操作，最后把Num&#x3D;1刷新到主内存中； 线程2执行完后，线程1由开始执行，但之前已经读取的Num的值0，所以它还是在0的基础上执行+1操作，也就是还是等于1，并刷新到主内存中。 所以最后输出结果可能是1也可能是2。</p></blockquote></li><li><p>synchronized如何保证可见性</p><blockquote><p>Synchronized能够实现原子性和可见性；在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</p></blockquote></li><li><p>synchronized如何保证有序性</p><blockquote><p>synchronized的有序性由”一个变量在同一个时刻只允许一个线程对其进行lock操作“这条规则获得的，这个规则决定了一个锁的两个同步代码块只能串行地进入。</p></blockquote></li><li><p>synchronized锁升级的过程</p><blockquote><p>无锁→偏向锁→轻量级锁→重量级锁</p></blockquote></li><li><p>使用线程池有什么好处？</p><blockquote><p>合理的使用线程池能够带来三个好处：</p><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ol></blockquote></li><li><p>线程创建的基本开销和线程切换开销</p><blockquote><p>线程创建开销：</p><ul><li>为线程堆栈分配并初始化一大块内存</li><li>需要进行系统调用以在主机OS中创建&#x2F;注册本机线程</li><li>创建初始化描述符并将其添加到JVM内部数据结构中</li></ul><p>线程切换开销：</p><p>线程切换的时候还要执行内存换页，CPU 的缓存被清空，切换回来的时候还要重新从内存中读取信息，破坏了数据的局部性。【分配内存、列入调度、内存换页、清空缓存和重新读取】</p></blockquote></li><li><p>创建线程的开销</p><blockquote><p><a href="https://qastack.cn/programming/5483047/why-is-creating-a-thread-said-to-be-expensive">https://qastack.cn/programming/5483047/why-is-creating-a-thread-said-to-be-expensive</a></p><p>Java线程的创建非常昂贵，因为其中涉及大量工作：</p><ul><li>必须为线程堆栈分配并初始化一大块内存。</li><li>需要进行系统调用以在主机OS中创建&#x2F;注册本机线程。</li><li>需要创建，初始化描述符并将其添加到JVM内部数据结构中。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/161628226">https://zhuanlan.zhihu.com/p/161628226</a></p><p>TODO待补充</p><p>对操作系统来说,创建一个线程的代价是十分昂贵的, 需要给它分配内存、列入调度，同时在线程切换的时候还要执行内存换页，CPU 的缓存被清空,切换回来的时候还要重新从内存中读取信息,破坏了数据的局部性。【分配内存、列入调度、内存换页、清空缓存和重新读取】</p><p><strong>关于内存开销</strong></p><p>Java线程的线程栈区别于堆，它是不受Java程序控制的，只受系统资源限制。默认一个线程的线程栈大小是1M，别小看这1M的空间，如果每个用户请求都新建线程的话，1024个用户光线程就占用了1个G的内存，如果系统比较大的话，一下子系统资源就不够用了，最后程序就崩溃了。</p><p>【创建一个线程默认需要消耗1M的内存，如果每个用户请求都创建一个线程，那么1024个用户就是1G了，并发量一大就扛不住了】</p></blockquote></li><li><p>线程是JVM创建还是操作系统去创建的？</p></li><li><p>Redis分布式锁获取锁成功，释放锁之前宕机，如何优雅的解决这个问题？</p></li></ul><h3 id="京东二面"><a href="#京东二面" class="headerlink" title="京东二面"></a>京东二面</h3><ul><li><p>HashMap扩容、缩容过程细节（HashMap没有缩容操作，因为反复横跳没太大意义）</p></li><li><p>什么是线程安全？</p><blockquote><p>引用《并发编程实战》：<br>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么就称这个对象是线程安全的。</p></blockquote></li><li><p>HashMap与CHM区别在哪里？CHM为了保证线程安全，在性能上做了哪些牺牲</p></li><li><p>Java内存区域有哪些？</p></li><li><p>HashMap与CHM区别在哪里？CHM为了保证线程安全，在性能上做了哪些牺牲</p></li><li><p>GCRoots有哪些？为什么选择这些对象作为GCRoots？</p><blockquote><p>参考《深入理解Java虚拟机第三版》第三章，固定可作为GC Roots的对象包括以下几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型所对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronize关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul></blockquote></li></ul><h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><ul><li><p>编程题：找出一个数组中出现次数为奇数的元素，并输出这些元素</p></li><li><p>快排时间复杂度是多少，快排是否稳定？稳定指的是什么？</p><blockquote><p>快排时间复杂度：最差n^2，平均nLogn</p><p>快排是不稳定的，因为是原地排序</p><p>稳定：如果 a 原本在 b 前面，而 a&#x3D;b，排序之后 a 仍然在 b 的前面。<br>不稳定：如果 a 原本在 b 的前面，而 a&#x3D;b，排序之后 a 可能会出现在 b 的后面。</p></blockquote></li><li><p>kafka为什么支持高吞吐</p></li><li><p>kafka如何做到水平拓展</p></li><li><p>一个http请求过来，SpringMVC的工作流程</p></li><li><p>Spring拦截器和filter的区别</p></li><li><p>线程池工作原理，线程多了会有什么问题？</p></li><li><p>如何设置核心线程数以及其他参数？</p></li><li><p>JUC底下用过哪些包，可重入锁的底层实现（AQS）</p></li><li><p>分库分表除了sharding jdbc还有哪些不需要引入三方jar包的</p></li><li><p>INNODB引擎有哪些锁，这些锁基于什么加的？</p><blockquote><p>表锁、行锁、乐观锁（MVCC）；行锁基于索引加锁。</p></blockquote></li><li><p>索引的数据结构</p></li><li><p>索引的种类</p></li><li><p>聚集索引和非聚集索引的区别</p></li></ul><h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><ul><li>HashMap的底层数据结构</li><li>HashMap rehash是啥，为什么要rehash</li><li>redis热点key是啥？如何去发现热点key（proxy）</li><li>什么是可重复读？什么是联合索引</li><li>MySQL如何保证数据的强一致性</li><li>MQ如何保证消息不丢失</li><li>tcp与udp的区别，tcp如何保证可靠性</li><li>内存泄露最终会导致什么</li><li>Linux查看一个目录最大的文件（du -sh *）</li></ul><h3 id="B站"><a href="#B站" class="headerlink" title="B站"></a>B站</h3><ul><li>SpringBoot的启动流程</li><li>kafka rebalance机制</li><li>kafka架构设计，如何保证消息不丢失</li><li>抽奖场景：奖品扣库存如何保证高并发</li><li>优惠券发放场景：假设上游接口全部可靠，如何保证发放优惠券的可靠性（延迟消息）</li><li>如何保证redis加锁和释放锁的安全性（什么情况下会出现释放锁不安全的问题）</li><li>分布式事务解决方案</li><li>ShardingJDBC原理，怎么做的，会有什么问题</li><li>数据分库分表之后数据如何不停机迁移</li></ul><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ul><li>对DDD的理解</li><li>DDD中业务域如何划分</li><li>聚合根、实体和值对象的区别</li><li>工厂模式在实际中的使用</li><li>手写一个策略模式</li></ul><h3 id="滴滴-1"><a href="#滴滴-1" class="headerlink" title="滴滴"></a>滴滴</h3><ul><li>JVM调优</li><li>Dubbo和SpringCloud的区别</li><li>分布式事务如何处理</li></ul><h3 id="58安居客"><a href="#58安居客" class="headerlink" title="58安居客"></a>58安居客</h3><ul><li><p>分库分表如果用非分表的字段去查询，怎么办（比如name字段，可以用name建索引，name和sharding-key建立kv）</p><blockquote><p>做mapping表，name和分片key做映射</p></blockquote></li><li><p>分库分表批量操作极端情况，如果三次操作在三个不同的库，如何保证数据一致性（在相同的本地库，生成一条prepare记录，使其成为本地事务，保证单库事务成功，单库是没有数据一致性问题，最后再一个个commit，如果一个失败，则依次回滚）</p></li><li><p>ddd相关：充血模型和贫血模型的区别；ddd在项目中是如何实施的？</p></li><li><p>Zookeeper如何保证CP？Eureka如何保证AP？</p><blockquote><p><strong>Zookeeper保证CP</strong></p><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p><p><strong>Eureka保证AP</strong></p><p>Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p><ol><li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</li><li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li></ol><p>因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p></blockquote></li><li><p>hasmap具体为什么不安全？（不安全的表现是对象丢失，例如两个线程都执行到同一个hash桶目前为空，都创建一个entry，会有一个entry被覆盖掉；不安全是因为不可见，为什么不可见？）</p></li><li><p>数据库缓存一致性问题</p></li><li><p>redis SDS优化点</p></li><li><p>redis跳表相对于平衡树有什么区别？</p></li><li><p>redis IO多路复用原理</p></li><li><p>JMM工作内存对应到计算机硬件层面是什么？（高速缓存？或者内存？）</p></li><li><p>异步事件驱动的好处和坏处（坏处就是代码不直观，无法直接找到消费者；这种情况又如何优化）</p></li><li><p>分库分表场景：如何同时通过买家和卖家id去查询订单</p><blockquote><p>订单表，比如以买家id分片，做卖家id和买家id的映射表，做两次查询</p></blockquote></li><li><p>本地事务执行成功，MQ发送失败，本地事务如何回滚（发送回调？）</p></li><li><p>ES和MySQL的区别，ES这么强大，为什么还需要有MySQL（MySQL为什么不能被替代）</p></li><li><p>可重入锁原理</p></li><li><p>读写锁AQS用法的区别（是否共享模式）</p></li><li><p>为什么要加锁（因为内存不可见），为什么内存不可见</p></li><li><p>CMS垃圾回收器有什么问题？为什么？怎么解决？</p><blockquote><p><strong>问题</strong>：CMS在重新标记（Remark）的过程中会浮动垃圾，容易产生大量空间碎片。</p><p><strong>原因</strong>：CMS垃圾回收器是基于“标记-清除”算法；Remark过程标记活着的对象，从GCRoot的可达性判断对象活着，但无法标记“死亡”的对象。</p><p>如果在初始阶段被标记为活着，并发运行过程中“死亡”，remark过程中无法纠正，因此变为浮动垃圾，需等待下次GC的到来。</p><p><strong>如何解决</strong>：可以通过<code>-XX:+UseCMSCompactAtFullCollection</code>参数，强制JVM在FGC完成后对老年代进行压缩，执行一次空间碎片整理，但是会引发STW。为了减少STW次数，CMS还可以通过配置<code>-XX:+CMSFullGCsBeforeCompaction=n</code>参数，在执行了n次FGC后，JVM再在老年代执行空间碎片整理。</p></blockquote></li></ul><h3 id="百度（ACG互联网）一面"><a href="#百度（ACG互联网）一面" class="headerlink" title="百度（ACG互联网）一面"></a>百度（ACG互联网）一面</h3><ul><li>什么是DDD？和传统开发模式的区别</li><li>同一个topic只有四个分区的情况下如何提高消费吞吐，假设有同样分区数量的消费者（不考虑消费者本地多线程消费）（将原topic按照一定规则分片，转发到其他topic，再进行消费）</li><li><a href="https://leetcode-cn.com/problems/3sum/">Leetcode15. 三数之和</a></li></ul><h3 id="百度（ACG互联网）二面"><a href="#百度（ACG互联网）二面" class="headerlink" title="百度（ACG互联网）二面"></a>百度（ACG互联网）二面</h3><ul><li><p>docer原理，如何做隔离</p></li><li><p>负载均衡机制有哪几种：4层和7层的有什么区别</p></li><li><p>各种锁机制（内置锁、分布式锁）</p></li><li><p><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></p></li></ul><h3 id="商汤科技"><a href="#商汤科技" class="headerlink" title="商汤科技"></a>商汤科技</h3><ul><li>一致性哈希分库分表方案如何动态感知节点的增减，这种分库分表如何扩容</li><li>类加载机过程（从class文件到就绪）</li><li>SpringBoot启动流程</li><li>dubbo服务注册流程</li><li>微服务链路追踪是怎么做的</li><li>Redis主从复制过程</li><li>AQS原理，可重入锁是如何做到可重入的；读写锁的原理</li><li>Kafka如何做到高可用的</li><li>如何设计一个注册中心</li><li>kafka partition与consumer工作机制</li><li>负载均衡机制</li><li>redis排它锁（分布式锁）</li><li>观察者模式</li></ul><h3 id="滴滴-2"><a href="#滴滴-2" class="headerlink" title="滴滴"></a>滴滴</h3><ul><li><p>分布式事务是如何做的</p></li><li><p>kafka如何保证消息顺序性</p></li><li><p>kafka消息是如何存储的</p></li><li><p>MySQL索引原理：B树和B+树的区别以及各自的优缺点</p></li><li><p>Rpc(dubbo)和Http调用的区别（http原生调用是十进制、dubbo是二进制，dubbo性能好一点）</p></li><li><p>数据库缓存一致性性</p></li><li><p>Redis为什么这么快</p></li><li><p>跳表和红黑树的区别</p><blockquote><p><del>跳表最差是O(N)，平均O(LogN)；红黑树相对跳表比较稳定，是O(LogN)，跳表有一定的运气成分</del></p></blockquote></li></ul><h3 id="小红书（2021-4-23）"><a href="#小红书（2021-4-23）" class="headerlink" title="小红书（2021&#x2F;4&#x2F;23）"></a>小红书（2021&#x2F;4&#x2F;23）</h3><ul><li>分布式事务如何处理</li><li>MySQL事务原理以及MVCC原理</li><li>MySQL聚集索引和非聚集索引区别</li><li>Redis热点key问题</li><li>Redis集群原理</li><li>Spring生命周期</li><li>Spring如何解决循环依赖（三级缓存）</li></ul><h3 id="滴滴-3"><a href="#滴滴-3" class="headerlink" title="滴滴"></a>滴滴</h3><ul><li><p>MySQL B+树 500万节点，树高是多少？如何配置</p><blockquote><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。</p><p>以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p></blockquote></li><li><p>https</p></li><li><p>堆排序是否稳定，以及原理</p><blockquote><p>不稳定，构建大根堆或者小根堆</p></blockquote></li><li><p>积分转账到一个第三方服务如何设计</p><blockquote><p>分为转出-转账中-转账成功三步：</p><p>转出：本地扣减，插入本地消息表，包含本地事务id，支付账户、接收人、积分数量、状态等</p><p>转账中：轮询本地消息表，调用第三方RPC（如果失败，一直重试，有个重试上限）</p><p>转账成功：调用成功之后，更新本地消息表状态为成功</p><p>关键点：幂等和重试，如果重试一定次数后，回滚扣减的积分，将本地事务表状态设置为失败</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;叮咚买菜&quot;&gt;&lt;a href=&quot;#叮咚买菜&quot; class=&quot;headerlink&quot; title=&quot;叮咚买菜&quot;&gt;&lt;/a&gt;叮咚买菜&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;hashmap的扩容过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单向链表如何判断有环&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HashSet遍历和快慢指针&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何找出一个数组重复元素最多的前K个元素&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TopK问题，堆排序，时间复杂度nLogK&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MySQL什么情况下会发生死锁？如何解决？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举个例子：事务A按照先后顺序去更新id&amp;#x3D;1和id&amp;#x3D;2的记录，事务B同一时间按照先后顺序去更新id&amp;#x3D;2和id&amp;#x3D;1的记录，因为行锁是两阶段协议，A获得id&amp;#x3D;1的行锁不会马上释放，此时B会等待A释放id&amp;#x3D;1的行锁，而A会等待B释放id&amp;#x3D;2的行锁，这样就形成了死锁。&lt;br&gt;&lt;strong&gt;如何解决：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。&lt;/li&gt;
&lt;li&gt;另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ArrayList的contains方法和HashSet的contains方法的时间复杂度各是多少&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;O(n)和O(1）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2个线程，A生产数据，B消费数据，有哪几种实现形式（使用LinkedList实现有哪些需要注意的，线程安全问题，如何解决：加锁）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个抽奖系统，奖品1的概率是10%，奖品2的概率是20%，不中奖的概率是70%，算法如何实现？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;随机数和区间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缓存一致性如何保证？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最好的解决方案是先更新数据库再删除缓存（在极端情况下也会有问题，比如说B线程更新数据的节点，缓存正好失效，此时线程A读取到了旧值，随后B操作数据库完成更新并且删除缓存之后，A再把旧值写入缓存，此时再去请求拿到的会是脏数据，这种概率非常低，基本可以忽略）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Dubbo IO线程池和业务线程池有什么区别？默认是哪种线程池（Fixed）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Dubbo有没有遇到什么坑？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;父子类有相同属性时值丢失：hessian序列化问题&lt;/li&gt;
&lt;li&gt;自定义异常被包装成RuntimeException&lt;/li&gt;
&lt;li&gt;Data length too large&lt;/li&gt;
&lt;li&gt;线程耗尽：Provider默认是fixed线程池，且线程数为200&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013256816/article/details/102674846&quot;&gt;&lt;strong&gt;具体参考链接&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网关是用来做什么的？为什么要用网关？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;乐观锁和悲观锁有什么区别？乐观锁有哪些实现方式？（版本号机制和CAS算法）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;版本号机制和CAS算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程池主要有哪些东西？线程池中如果没有任务，会是什么状态？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;项目中遇到的技术难题，是如何解决的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分库分表一些连表问题和条件查询是如何解决的？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分两次查询，第一次把联表的id查出来，通过这些id再做一次查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo面试题</title>
    <link href="https://blog.elfred.top/posts/7644b6f2.html"/>
    <id>https://blog.elfred.top/posts/7644b6f2.html</id>
    <published>2021-01-18T08:31:05.000Z</published>
    <updated>2025-03-08T14:46:55.122Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="dubbo分层"><a href="#dubbo分层" class="headerlink" title="dubbo分层"></a>dubbo分层</h3><p>从大的范围来说，dubbo分为三层，business业务逻辑层由我们自己来提供接口和实现还有一些配置信息，RPC层就是真正的RPC调用的核心层，封装整个RPC的调用过程、负载均衡、集群容错、代理，remoting则是对网络传输协议和数据转换的封装。</p><p>划分到更细的层面，就是图中的10层模式，整个分层依赖由上至下，除开business业务逻辑之外，其他的几层都是SPI机制。<br><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210118155842.webp" alt="图片"></p><h3 id="能说下Dubbo的工作原理吗？"><a href="#能说下Dubbo的工作原理吗？" class="headerlink" title="能说下Dubbo的工作原理吗？"></a>能说下Dubbo的工作原理吗？</h3><ol><li>服务启动的时候，provider和consumer根据配置信息，连接到注册中心register，分别向注册中心注册和订阅服务</li><li>register根据服务订阅关系，返回provider信息到consumer，同时consumer会把provider信息缓存到本地。如果信息有变更，consumer会收到来自register的推送</li><li>consumer生成代理对象，同时根据负载均衡策略，选择一台provider，同时定时向monitor记录接口的调用次数和时间信息</li><li>拿到代理对象之后，consumer通过代理对象发起接口调用</li><li>provider收到请求后对数据进行反序列化，然后通过代理调用具体的接口实现</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210118155952.webp" alt="图片"></p><h3 id="dubbo服务暴露的过程"><a href="#dubbo服务暴露的过程" class="headerlink" title="dubbo服务暴露的过程"></a>dubbo服务暴露的过程</h3><ol><li>在容器启动的时候，通过ServiceConfig解析标签，创建dubbo标签解析器来解析dubbo的标签，容器创建完成之后，触发ContextRefreshEvent事件回调开始暴露服务</li><li>通过ProxyFactory获取到invoker，invoker包含了需要执行的方法的对象信息和具体的URL地址</li><li>再通过DubboProtocol的实现把包装后的invoker转换成exporter，然后启动服务器server，监听端口</li><li>最后RegistryProtocol保存URL地址和invoker的映射关系，同时注册到服务中心</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kuqi007/picGo/2021/20210118160055.webp" alt="图片"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/TOcBA5AFDsMNCCosI5tZZA">https://mp.weixin.qq.com/s/TOcBA5AFDsMNCCosI5tZZA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;dubbo分层&quot;&gt;&lt;a href=&quot;#dubbo分层&quot; class=&quot;headerlink&quot; title=&quot;dubbo分层&quot;&gt;&lt;/a&gt;dubbo分层&lt;/h3&gt;&lt;p&gt;从大的范围来说，dubbo分为三层，business业务逻辑层由我们自己来提供接口和实现还</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试遇到的简单多线程编程题：线程交替打印的升级版</title>
    <link href="https://blog.elfred.top/posts/575b225b.html"/>
    <id>https://blog.elfred.top/posts/575b225b.html</id>
    <published>2020-03-26T07:34:00.000Z</published>
    <updated>2025-03-08T14:46:55.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近面试遇到一道简单的多线程编码题，线程交替打印的升级版，我们来研究下这道题怎么解决。  </p><h3 id="题目介绍："><a href="#题目介绍：" class="headerlink" title="题目介绍："></a>题目介绍：</h3><blockquote><p>线程A每次处理只能输出一个A<br>线程B每次输出只能输出一个B<br>主线程不能输出A或B<br>请尽可能不使用封装好的工具方法或类来调度线程，然后输出以下内容：<br>ABBBBABBBBABBBBABBBB….<br>加分项：增加线程B1，行为和B一样，要求B和B1负载均衡</p></blockquote><span id="more"></span><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>输出一个A然后输出4个B，以此类推，最简单的应该是使用synchronized，wait以及notify方法来实现，这里可以指定一个自增的整数，能被5整除时打印A，不能被5整除时打印B，话不多说我们来看代码。</p><h3 id="使用synchronized、wait、notify方法"><a href="#使用synchronized、wait、notify方法" class="headerlink" title="使用synchronized、wait、notify方法"></a>使用synchronized、wait、notify方法</h3><h4 id="非负载均衡"><a href="#非负载均衡" class="headerlink" title="非负载均衡"></a>非负载均衡</h4><p>这里我们先不考虑B1的负载均衡，简单实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="comment">// 递增的整数用来判断打印A还是B</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置一个打印上限，最多打印200个字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 对象锁（工具人）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 当index小于最大值max时一直循环</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt;= max) &#123;</span><br><span class="line">                <span class="comment">// 争夺锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 被5整除输出A</span></span><br><span class="line">                    <span class="keyword">if</span> (index % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                        <span class="comment">// index加一</span></span><br><span class="line">                        index++;</span><br><span class="line">                        <span class="comment">// 唤醒其他线程</span></span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 因为不能被5整除则释放锁，等待其他线程唤醒</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                            <span class="comment">// 如果被唤醒的话继续下次循环，此时获得锁</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (index &lt;= max) &#123;</span><br><span class="line">                <span class="comment">// 争夺锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 不能被5整除输出B</span></span><br><span class="line">                    <span class="keyword">if</span> (index % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                        index++;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 释放锁，等待其他线程唤醒</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们来看下输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBABBBBA</span><br></pre></td></tr></table></figure><h4 id="负载均衡如何实现？"><a href="#负载均衡如何实现？" class="headerlink" title="负载均衡如何实现？"></a>负载均衡如何实现？</h4><p>如果考虑题目里的负载均衡应该怎么做呢？其实也很简单，增加另一个标志位就可以了，判断index能否被5整除的时候顺便判断下标志位是否是当前线程的标志位即可（个人理解，如有错误还请指正），上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="comment">// 从0递增的整数用来判断打印A还是B</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置一个打印上限，最多打印200个字符，防止打印过多CPU扛不住</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 对象锁（工具人）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 负载标志位，0的时候B线程执行，1的时候B1执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">loadFlag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 当index小于最大值max时一直循环</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt;= max) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 被5整除输出A</span></span><br><span class="line">                    <span class="keyword">if</span> (index % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                        <span class="comment">// index加一</span></span><br><span class="line">                        index++;</span><br><span class="line">                        <span class="comment">// 唤醒其他线程</span></span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 因为不能被5整除则释放锁，等待其他线程唤醒</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                            <span class="comment">// 如果被唤醒的话继续下次循环，此时获得锁</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (index &lt;= max) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 不能被5整除输出B</span></span><br><span class="line">                    <span class="keyword">if</span> (index % <span class="number">5</span> != <span class="number">0</span> &amp;&amp; loadFlag == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 为了看出负载均衡效果，这里打印B0</span></span><br><span class="line">                        System.out.print(<span class="string">&quot;B0&quot;</span>);</span><br><span class="line">                        index++;</span><br><span class="line">                        <span class="comment">// 标志位设置为1，下次B1线程执行</span></span><br><span class="line">                        loadFlag = <span class="number">1</span>;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 释放锁，等待其他线程唤醒</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 新建线程B1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tB1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (index &lt;= max) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 如果不能被5整除且标志位是1则执行</span></span><br><span class="line">                    <span class="keyword">if</span> (index % <span class="number">5</span> != <span class="number">0</span> &amp;&amp; loadFlag == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 为了看出负载均衡效果，这里打印B1</span></span><br><span class="line">                        System.out.print(<span class="string">&quot;B1&quot;</span>);</span><br><span class="line">                        index++;</span><br><span class="line">                        <span class="comment">// 标志位设置为0，下次B线程执行</span></span><br><span class="line">                        loadFlag = <span class="number">0</span>;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 释放锁，等待其他线程唤醒</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line">        tB1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1AB0B1B0B1A</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近面试遇到一道简单的多线程编码题，线程交替打印的升级版，我们来研究下这道题怎么解决。  &lt;/p&gt;
&lt;h3 id=&quot;题目介绍：&quot;&gt;&lt;a href=&quot;#题目介绍：&quot; class=&quot;headerlink&quot; title=&quot;题目介绍：&quot;&gt;&lt;/a&gt;题目介绍：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;线程A每次处理只能输出一个A&lt;br&gt;线程B每次输出只能输出一个B&lt;br&gt;主线程不能输出A或B&lt;br&gt;请尽可能不使用封装好的工具方法或类来调度线程，然后输出以下内容：&lt;br&gt;ABBBBABBBBABBBBABBBB….&lt;br&gt;加分项：增加线程B1，行为和B一样，要求B和B1负载均衡&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="面试题" scheme="https://blog.elfred.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="多线程" scheme="https://blog.elfred.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring、SpringMvc、SpringBoot和SpringCloud的联系与区别</title>
    <link href="https://blog.elfred.top/posts/7e8f7b41.html"/>
    <id>https://blog.elfred.top/posts/7e8f7b41.html</id>
    <published>2020-02-29T06:19:07.000Z</published>
    <updated>2025-03-08T14:46:55.118Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试被问到了Spring、SpringMvc、SpringBoot和SpringCloud的关系和区别，以及各解决了什么问题，简单整理了下四者之间的区别和联系以及解决的问题：</p><span id="more"></span><h5 id="Spring和SpringMvc："><a href="#Spring和SpringMvc：" class="headerlink" title="Spring和SpringMvc："></a>Spring和SpringMvc：</h5><ol><li>Spring是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(SpringMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案；</li><li>SpringMvc是Spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于Spring框架中WEB层开发的一部分；</li></ol><h5 id="SpringMvc和SpringBoot："><a href="#SpringMvc和SpringBoot：" class="headerlink" title="SpringMvc和SpringBoot："></a>SpringMvc和SpringBoot：</h5><ol><li>SpringMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂；</li><li>SpringBoot框架相对于SpringMvc框架来说，更专注于开发微服务后台接口，不开发前端视图，同时遵循默认优于配置，简化了插件配置流程，不需要配置xml，相对Springmvc，大大简化了配置流程；</li></ol><h5 id="SpringBoot和SpringCloud："><a href="#SpringBoot和SpringCloud：" class="headerlink" title="SpringBoot和SpringCloud："></a>SpringBoot和SpringCloud：</h5><ol><li>Spring boot使用了默认大于配置的理念，集成了快速开发的Spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，能快速开发单个微服务；</li><li>Spring cloud大部分的功能插件都是基于SpringBoot去实现的，SpringCloud关注于全局的微服务整合和管理，将多个SpringBoot单体微服务进行整合以及管理；  SpringCloud依赖于SpringBoot开发，而SpringBoot可以独立开发；</li></ol><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol><li>Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring的ioc、aop等。 ioc 提供了依赖注入的容器， aop解决了面向横切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能；</li><li>SpringMvc是基于Servlet 的一个MVC框架主要解决WEB开发的问题，因为Spring的配置非常复杂，各种XML、JavaConfig、servlet处理起来比较繁琐；</li><li>为了简化开发者的使用，从而创造性地推出了SpringBoot框架，默认优于配置，简化了SpringMvc的配置流程；<br>但区别于SpringMvc的是，SpringBoot专注于微服务方面的接口开发，和前端解耦，虽然SpringBoot也可以做成SpringMvc前后台一起开发，但是这就有点不符合SpringBoot框架的初衷了；</li><li>对于SpringCloud框架来说，它和SpringBoot一样，注重的是微服务的开发，但是SpringCloud更关注的是全局微服务的整合和管理，相当于管理多个SpringBoot框架的单体微服务；</li></ol><p>参考：<a href="https://blog.csdn.net/alan_liuyue/article/details/80656687">https://blog.csdn.net/alan_liuyue/article/details/80656687</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近面试被问到了Spring、SpringMvc、SpringBoot和SpringCloud的关系和区别，以及各解决了什么问题，简单整理了下四者之间的区别和联系以及解决的问题：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot打包时复制指定配置文件到指定目录，并剔除jar包内所有配置文件</title>
    <link href="https://blog.elfred.top/posts/9ca55b1a.html"/>
    <id>https://blog.elfred.top/posts/9ca55b1a.html</id>
    <published>2020-02-24T03:04:27.000Z</published>
    <updated>2025-03-08T14:46:55.118Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个需求，把SpringBoot项目的配置文件放到Jar包外面，Jar包内不包含多余配置文件，Jar包运行时指定外部配置文件启动。我的配置文件放在src&#x2F;main&#x2F;resources&#x2F;config下，打包时拷贝到Jar包同级config目录下（SpringBoot默认支持读取Jar包同级config文件夹中的配置），具体解决方案如下：</p><ul><li><p>使用maven-jar-plugin插件移除配置文件将其不打包进jar包中</p></li><li><p>使用maven-resources-plugin插件将需要复制的文件复制到指定路径（例：将配置文件提取到指定路径）</p><p>Maven配置如下：</p><span id="more"></span></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明多环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 本地开发环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profiles.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profiles.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modifier</span>&gt;</span><span class="tag">&lt;/<span class="name">modifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 默认的，不加参数时执行这个profile --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 测试环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profiles.active</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profiles.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modifier</span>&gt;</span>-test<span class="tag">&lt;/<span class="name">modifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生产环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profiles.active</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">profiles.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modifier</span>&gt;</span>-prod<span class="tag">&lt;/<span class="name">modifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 复制指定环境配置文件到指定目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/config<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;profiles.active&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/config<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jar包内剔除所有配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不打入jar包的文件类型或者路径--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>config/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后执行<code>mvn clean package -P prod</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到一个需求，把SpringBoot项目的配置文件放到Jar包外面，Jar包内不包含多余配置文件，Jar包运行时指定外部配置文件启动。我的配置文件放在src&amp;#x2F;main&amp;#x2F;resources&amp;#x2F;config下，打包时拷贝到Jar包同级config目录下（SpringBoot默认支持读取Jar包同级config文件夹中的配置），具体解决方案如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用maven-jar-plugin插件移除配置文件将其不打包进jar包中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用maven-resources-plugin插件将需要复制的文件复制到指定路径（例：将配置文件提取到指定路径）&lt;/p&gt;
&lt;p&gt;Maven配置如下：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用gitlab-ci和docker自动化部署vue项目</title>
    <link href="https://blog.elfred.top/posts/1b05c064.html"/>
    <id>https://blog.elfred.top/posts/1b05c064.html</id>
    <published>2019-10-27T07:51:29.000Z</published>
    <updated>2025-03-08T14:46:55.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>之前用docker的时候想到gitlab可以直接提交代码触发docker编译部署，非常方便，于是试验了一个单体vue项目如何使用gitlab和docker的强大功能进行编译发布，此教程仅供参考，适用于公司或者个人测试。</p><span id="more"></span><h3 id="一、安装gitlab-runner，在runner机器上安装git等"><a href="#一、安装gitlab-runner，在runner机器上安装git等" class="headerlink" title="一、安装gitlab-runner，在runner机器上安装git等"></a>一、安装gitlab-runner，在runner机器上安装git等</h3><p>由于公司gitlab版本是8.x，比较老，只能安装1.x版本的gialab-runner，这里比较注意的是，一般runner和gitlab会分别安装到两台服务器上，具体安装步骤可以<a href="http://muchstudy.com/2018/07/13/Gitlab-8-x-runner%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/">参考这篇文章</a>。安装好之后创建两个runner：一个<code>docker</code>类型runner，打上CI标签；一个<code>shell</code>类型runner，打上CD标签。因为会使用到shell的runner，所以需要安装git，安装过程不再赘述，当然如果你runner不是这样用，可能还需要安装nodejs等环境。</p><h3 id="二、编写Dockerfile"><a href="#二、编写Dockerfile" class="headerlink" title="二、编写Dockerfile"></a>二、编写Dockerfile</h3><p>在项目根目录下新建docker目录，编写Dockerfile，注意相对路径问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 设置基础镜像</span><br><span class="line">FROM nginx</span><br><span class="line">#设置CTS时区</span><br><span class="line">RUN cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo &#x27;Asia/Shanghai&#x27; &gt;/etc/timezone</span><br><span class="line"># 将dist文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面</span><br><span class="line">COPY ./dist /usr/share/nginx/html/</span><br><span class="line">#用本地的 default.conf 配置来替换nginx镜像里的默认配置</span><br><span class="line">COPY docker/default.conf /etc/nginx/conf.d/default.conf</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><p>同样在docker目录下新增Nginx配置文件default.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line">    error_log  /var/log/nginx/error.log  error;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、在gitlab上添加已有runner，创建-gitlab-ci-yml文件"><a href="#三、在gitlab上添加已有runner，创建-gitlab-ci-yml文件" class="headerlink" title="三、在gitlab上添加已有runner，创建.gitlab-ci.yml文件"></a>三、在gitlab上添加已有runner，创建.gitlab-ci.yml文件</h3><p>以上工作准备就绪之后在gitlab上添加两个runner，分别对应第一步CI和CD标签的runner，顾名思义，CI用于编译打包，CD用于部署运行。没有.gitlab-ci.yml文件的在项目根目录新建该文件，内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job-build:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">node:alpine</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="comment"># ci是docker类型的runner</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ci</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">cnpm</span> <span class="string">--registry=https://registry.npm.taobao.org</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cnpm</span> <span class="string">install</span> <span class="string">--progress=false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cnpm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">expire_in:</span> <span class="number">1</span> <span class="string">week</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dist</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job-release:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">dependencies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">job-build</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="comment"># cd是shell类型的runner</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-f</span> <span class="string">docker/Dockerfile</span> <span class="string">-t</span> <span class="string">ngnix/app:v1.0.0</span> <span class="string">.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">if</span> [ <span class="string">$(docker</span> <span class="string">ps</span> <span class="string">-aq</span> <span class="string">--filter</span> <span class="string">name=app-test)</span> ]<span class="string">;</span> <span class="string">then</span> <span class="string">docker</span> <span class="string">rm</span> <span class="string">-f</span> <span class="string">rhea-cms;fi</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">run</span> <span class="string">-p</span> <span class="number">80</span><span class="string">:80</span> <span class="string">--name</span> <span class="string">app-test</span> <span class="string">-d</span> <span class="string">ngnix/app:v1.0.0</span></span><br></pre></td></tr></table></figure><p>这里使用到了gitlab的artifacts功能，感兴趣的可以去看官方文档，类似缓存的作用，第二步发布的时候就无需拉取代码编译直接使用上一步归档的dist和docker文件夹。提交所有更改之后所有master分支的提交就会触发一系列编译部署操作了。</p><h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><p>1.gitlab-runner执行docker命令的时候遇到一个问题，因为使用的是gitlab-runner用户权限不够，结果按照网上教程和更改用户分组都没用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><p>后来找到一个解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG docker gitlab-runner</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><p>完美解决。</p><p>2.使用gitlab-ci runner拉取git代码遇到这个问题，重新编译安装git都没用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to find remote helper for &#x27;http&#x27;</span><br></pre></td></tr></table></figure><p>后来发现是编译安装git的时候缺少了curl-devel的lib依赖，yum安装依赖再重新编译安装git就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ yum install curl-devel</span><br><span class="line">$ # cd to wherever the source for git is</span><br><span class="line">$ cd /usr/local/src/git-1.7.9  </span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;之前用docker的时候想到gitlab可以直接提交代码触发docker编译部署，非常方便，于是试验了一个单体vue项目如何使用gitlab和docker的强大功能进行编译发布，此教程仅供参考，适用于公司或者个人测试。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【转】CoreOS配置Docker API TLS认证</title>
    <link href="https://blog.elfred.top/posts/a623d7c5.html"/>
    <id>https://blog.elfred.top/posts/a623d7c5.html</id>
    <published>2019-10-19T15:43:00.000Z</published>
    <updated>2025-03-08T14:46:55.115Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会利用Portainer来管理docker环境，也经常会用Jenkins来自动构建和部署docker，远程管理都会使用到Docker API，通常我们只是开启了没有安全保护的2375（通常）端口，这个比较危险，会导致远程劫持攻击。那么我们就需要配置TLS认证的2376（通常）端口。</p><span id="more"></span><p>下面我们针对CoreOS系统进行配置：</p><h3 id="一、利用系统自带的openssl生成相应的服务端和客户端证书"><a href="#一、利用系统自带的openssl生成相应的服务端和客户端证书" class="headerlink" title="一、利用系统自带的openssl生成相应的服务端和客户端证书"></a>一、利用系统自带的openssl生成相应的服务端和客户端证书</h3><p>我们利用脚本自动生成，这样非常便捷，脚本（auto-tls-certs.sh）如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 自动创建 Docker TLS 证书</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是配置信息</span></span><br><span class="line"><span class="comment"># --[BEGIN]------------------------------</span></span><br><span class="line"></span><br><span class="line">CODE=<span class="string">&quot;dp&quot;</span></span><br><span class="line">IP=<span class="string">&quot;docker服务器ip&quot;</span></span><br><span class="line">PASSWORD=<span class="string">&quot;证书密码&quot;</span></span><br><span class="line">COUNTRY=<span class="string">&quot;CN&quot;</span></span><br><span class="line">STATE=<span class="string">&quot;BEIJING&quot;</span></span><br><span class="line">CITY=<span class="string">&quot;BEIJING&quot;</span></span><br><span class="line">ORGANIZATION=<span class="string">&quot;公司&quot;</span></span><br><span class="line">ORGANIZATIONAL_UNIT=<span class="string">&quot;Dev&quot;</span></span><br><span class="line">COMMON_NAME=<span class="string">&quot;<span class="variable">$IP</span>&quot;</span></span><br><span class="line">EMAIL=<span class="string">&quot;邮箱&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --[END]--</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate CA key</span></span><br><span class="line">openssl genrsa -aes256 -passout <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> -out <span class="string">&quot;ca-key-<span class="variable">$CODE</span>.pem&quot;</span> 4096</span><br><span class="line"><span class="comment"># Generate CA</span></span><br><span class="line">openssl req -new -x509 -days 365 -key <span class="string">&quot;ca-key-<span class="variable">$CODE</span>.pem&quot;</span> -sha256 -out <span class="string">&quot;ca-<span class="variable">$CODE</span>.pem&quot;</span> -passin <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> -subj <span class="string">&quot;/C=<span class="variable">$COUNTRY</span>/ST=<span class="variable">$STATE</span>/L=<span class="variable">$CITY</span>/O=<span class="variable">$ORGANIZATION</span>/OU=<span class="variable">$ORGANIZATIONAL_UNIT</span>/CN=<span class="variable">$COMMON_NAME</span>/emailAddress=<span class="variable">$EMAIL</span>&quot;</span></span><br><span class="line"><span class="comment"># Generate Server key</span></span><br><span class="line">openssl genrsa -out <span class="string">&quot;server-key-<span class="variable">$CODE</span>.pem&quot;</span> 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate Server Certs.</span></span><br><span class="line">openssl req -subj <span class="string">&quot;/CN=<span class="variable">$COMMON_NAME</span>&quot;</span> -sha256 -new -key <span class="string">&quot;server-key-<span class="variable">$CODE</span>.pem&quot;</span> -out server.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;subjectAltName = IP:<span class="variable">$IP</span>,IP:127.0.0.1&quot;</span> &gt;&gt; extfile.cnf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;extendedKeyUsage = serverAuth&quot;</span> &gt;&gt; extfile.cnf</span><br><span class="line"></span><br><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> server.csr -passin <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> -CA <span class="string">&quot;ca-<span class="variable">$CODE</span>.pem&quot;</span> -CAkey <span class="string">&quot;ca-key-<span class="variable">$CODE</span>.pem&quot;</span> -CAcreateserial -out <span class="string">&quot;server-cert-<span class="variable">$CODE</span>.pem&quot;</span> -extfile extfile.cnf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate Client Certs.</span></span><br><span class="line"><span class="built_in">rm</span> -f extfile.cnf</span><br><span class="line"></span><br><span class="line">openssl genrsa -out <span class="string">&quot;key-<span class="variable">$CODE</span>.pem&quot;</span> 4096</span><br><span class="line">openssl req -subj <span class="string">&#x27;/CN=client&#x27;</span> -new -key <span class="string">&quot;key-<span class="variable">$CODE</span>.pem&quot;</span> -out client.csr</span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf</span><br><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> client.csr -passin <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> -CA <span class="string">&quot;ca-<span class="variable">$CODE</span>.pem&quot;</span> -CAkey <span class="string">&quot;ca-key-<span class="variable">$CODE</span>.pem&quot;</span> -CAcreateserial -out <span class="string">&quot;cert-<span class="variable">$CODE</span>.pem&quot;</span> -extfile extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -vf client.csr server.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> -v 0400 <span class="string">&quot;ca-key-<span class="variable">$CODE</span>.pem&quot;</span> <span class="string">&quot;key-<span class="variable">$CODE</span>.pem&quot;</span> <span class="string">&quot;server-key-<span class="variable">$CODE</span>.pem&quot;</span></span><br><span class="line"><span class="built_in">chmod</span> -v 0444 <span class="string">&quot;ca-<span class="variable">$CODE</span>.pem&quot;</span> <span class="string">&quot;server-cert-<span class="variable">$CODE</span>.pem&quot;</span> <span class="string">&quot;cert-<span class="variable">$CODE</span>.pem&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包客户端证书</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;tls-client-certs-<span class="variable">$CODE</span>&quot;</span></span><br><span class="line"><span class="built_in">cp</span> -f <span class="string">&quot;ca-<span class="variable">$CODE</span>.pem&quot;</span> <span class="string">&quot;cert-<span class="variable">$CODE</span>.pem&quot;</span> <span class="string">&quot;key-<span class="variable">$CODE</span>.pem&quot;</span> <span class="string">&quot;tls-client-certs-<span class="variable">$CODE</span>/&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;tls-client-certs-<span class="variable">$CODE</span>&quot;</span></span><br><span class="line">tar zcf <span class="string">&quot;tls-client-certs-<span class="variable">$CODE</span>.tar.gz&quot;</span> *</span><br><span class="line"><span class="built_in">mv</span> <span class="string">&quot;tls-client-certs-<span class="variable">$CODE</span>.tar.gz&quot;</span> ../</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;tls-client-certs-<span class="variable">$CODE</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝服务端证书</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/docker/certs.d</span><br><span class="line"><span class="built_in">cp</span> <span class="string">&quot;ca-<span class="variable">$CODE</span>.pem&quot;</span> <span class="string">&quot;server-cert-<span class="variable">$CODE</span>.pem&quot;</span> <span class="string">&quot;server-key-<span class="variable">$CODE</span>.pem&quot;</span> /etc/docker/certs.d/</span><br></pre></td></tr></table></figure><p>对脚本中的变量进行修改后运行，自动会创建好tls证书，服务器的证书在&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;目录下:<br><img src="https://oscimg.oschina.net/oscnet/cf128d18f1e5494241522354509639ac476.jpg" alt="image"><br>客户端的证书在运行脚本的目录下，同时还自动打好了一个.tar.gz的包，很方便。<br><img src="https://oscimg.oschina.net/oscnet/a52727e6614faf2c2985912dd992a699ef8.jpg" alt="image"></p><h3 id="二、配置Docker服务（官方说明）"><a href="#二、配置Docker服务（官方说明）" class="headerlink" title="二、配置Docker服务（官方说明）"></a>二、配置Docker服务（官方说明）</h3><p>注意修改证书路径。</p><p>Enable the secure remote API on a new socket<br>Create a file called ++&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker-tls-tcp.socket++ to make Docker available on a secured TCP socket on port 2376.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Secured Socket for the API</span><br><span class="line"></span><br><span class="line">[Socket]</span><br><span class="line">ListenStream=2376</span><br><span class="line">BindIPv6Only=both</span><br><span class="line">Service=docker.service</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sockets.target</span><br></pre></td></tr></table></figure><p>Then enable this new socket:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker-tls-tcp.socket</span><br><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker-tls-tcp.socket</span><br></pre></td></tr></table></figure><h5 id="Drop-in-configuration"><a href="#Drop-in-configuration" class="headerlink" title="Drop-in configuration"></a>Drop-in configuration</h5><p>Create ++&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;10-tls-verify.conf++ drop-in for systemd Docker service:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;DOCKER_OPTS=--tlsverify --tlscacert=/etc/docker/ca.pem --tlscert=/etc/docker/server.pem --tlskey=/etc/docker/server-key.pem&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Reload systemd config files and restart docker service:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure><h3 id="三、配置Portainer远程TLS连接"><a href="#三、配置Portainer远程TLS连接" class="headerlink" title="三、配置Portainer远程TLS连接"></a>三、配置Portainer远程TLS连接</h3><p><img src="https://oscimg.oschina.net/oscnet/a42a8fc88e593b51007b357d9588cc7e37c.jpg" alt="image"></p><p>证书对应选择：</p><p>ca.pem<br>cert.pem<br>key.pem<br>这样就完成了。注意如果之前开启了未认证的2375端口，请关闭并禁用，重启docker服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 停止不安全的2375端口</span><br><span class="line">systemctl stop docker-tcp.socket</span><br><span class="line"></span><br><span class="line"># 禁用该端口</span><br><span class="line">systemctl disable docker-tcp.socket</span><br><span class="line"></span><br><span class="line"># 重启docker服务</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们经常会利用Portainer来管理docker环境，也经常会用Jenkins来自动构建和部署docker，远程管理都会使用到Docker API，通常我们只是开启了没有安全保护的2375（通常）端口，这个比较危险，会导致远程劫持攻击。那么我们就需要配置TLS认证的2376（通常）端口。&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="https://blog.elfred.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ORM框架对比</title>
    <link href="https://blog.elfred.top/posts/9eb10313.html"/>
    <id>https://blog.elfred.top/posts/9eb10313.html</id>
    <published>2019-10-13T14:16:00.000Z</published>
    <updated>2025-03-08T14:46:55.118Z</updated>
    
    <content type="html"><![CDATA[<p>　　因为项目需要选择数据持久化框架，看了一下主要几个流行的和不流行的框架，对于复杂业务系统，最终的结论是，JOOQ是总体上最好的，可惜不是完全免费，最终选择JDBC Template。</p><span id="more"></span><p>　　Hibernate和Mybatis是使用最多的两个主流框架，而JOOQ、Ebean等小众框架则知道的人不多，但也有很多独特的优点；而JPA则是一组Java持久层Api的规范，Spring Data JPA是JPA Repository的实现，本来和Hibernate、Mybatis、JOOQ之类的框架不在同一个层次上，但引入Spring Data JPA之类框架之后，我们会直接使用JPA的API查询更新数据库，就像我们使用Mybatis一样，所以这里也把JPA和其他框架放在一起进行比较。</p><p>　　同样，JDBC和其他框架也在同一层次，位于所有持久框架的底层，但我们有时候也会直接在项目中使用JDBC，而Spring JDBC Template部分消除了使用JDBC的繁琐细节，降低了使用成本，使得我们更加愿意在项目中直接使用JDBC。</p><h4 id="一、SQL封装和性能"><a href="#一、SQL封装和性能" class="headerlink" title="一、SQL封装和性能"></a>一、SQL封装和性能</h4><p>　　在使用Hibernate的时候，我们查询的是POJO实体类，而不再是数据库的表，例如hql语句 select count(*) from User，里面的User是一个Java类，而不是数据库表User。这符合ORM最初的理想，ORM认为Java程序员使用OO的思维方式，和关系数据库的思维方式差距巨大，为了填补对象和关系思维方式的鸿沟，必须做一个对象到关系的映射，然后在Java的对象世界中，程序员可以使用纯的对象的思维方式，查询POJO对象，查询条件是对象属性，不再需要有任何表、字段等关系的概念，这样java程序员就更容易做持久层的操作。</p><p>　　JPA可以视为Hibernate的儿子，也继承了这个思路，把SQL彻底封装起来，让Java程序员看不到关系的概念，用纯的面向对象思想，重新创造一个新的查询语言代替sql，比如hql，还有JPQL等。支持JPA的框架，例如Ebean都属于这种类型的框架。</p><p>　　但封装SQL，使用另一种纯的面向对象查询语言代替sql，真的能够让程序员更容易实现持久层操作吗？MyBatis的流行证明了事实并非如此，至少在大多数情况下，使用hql并不比使用sql简单。首先，从很多角度上看，hql&#x2F;JPQL等语言更加复杂和难以理解；其次就是性能上明显降低，速度更慢，内存占用巨大，而且还不好优化。最为恼火的是，当关系的概念被替换为对象的概念之后，查询语言的灵活性变得很差，表达能力也比sql弱很多。写查询语句的时候受到各种各样的限制，一个典型的例子就是多表关联查询。</p><p>　　不管是hibernate还是jpa，表之间的连接查询，被映射为实体类之间的关联关系，这样，如果两个实体类之间没有（实现）关联关系，你就不能把两个实体（或者表）join起来查询。这是很恼火的事情，因为我们很多时候并不需要显式定义两个实体类之间的关联关系就可以实现业务逻辑，如果使用hql，只是为了join我们就必须在两个实体类之间添加代码，而且还不能逆向工程，如果表里面没有定义外键约束的话，逆向工程会把我们添加的关联代码抹掉。</p><p>　　MyBatis则是另外一种类型的持久化框架，它没有封装SQL也没有创建一种新的面相对象的查询语言，而是直接使用SQL作为查询语言，只是把结果填入POJO对象而已。使用sql并不比hql和JPQL困难，查询速度快，可以灵活使用任意复杂的查询只要数据库支持。从SQL封装角度上看，MyBatis比Hibernate和JPA成功，SQL本不该被封装和隐藏，让Java程序员使用SQL既不麻烦也更容易学习和上手，这应该是MyBatis流行起来的重要原因。</p><p>　　轻量级持久层框架JOOQ也和MyBatis一样，直接使用SQL作为查询语言，比起MyBatis，JOOQ虽然知名度要低得多，但JOOQ不但和MyBatis一样可以利用SQL的灵活性和高效率，通过逆向工程，JOOQ还可以用Java代码来编写SQL语句，利用IDE的代码自动补全功能，自动提示表名和字段名，减少程序员记忆负担，还可以在元数据发生变化时发生编译错误，提示程序员修改相应的SQL语句。</p><p>　　Ebean作为一种基于JPA的框架，它也使用JPQL语言进行查询，多数情况下会让人很恼火。但据说Ebean不排斥SQL，可以直接用SQL查询，也可以用类似JOOQ的DSL方式在代码中构造SQL语句（还是JPQL语句？），但没用过Ebean，所以具体细节不清楚。</p><p>　　JDBC Template就不用说了，它根本没做ORM，当然是纯SQL查询。利用Spring框架，可以把JDBC Template和JPA结合起来使用，在JPA不好查询的地方，或者效率低不好优化的地方使用JDBC，缓解了Hibernate&#x2F;JPA封装SQL造成的麻烦，但我仍没看到任何封装SQL的必要性，除了给程序员带来一大堆麻烦和学习负担之外，没有太明显的好处。</p><h4 id="二、DSL和变化适应性"><a href="#二、DSL和变化适应性" class="headerlink" title="二、DSL和变化适应性"></a>二、DSL和变化适应性</h4><p>　　为了实现复杂的业务逻辑，不论是用SQL还是hql或者JPQL，我们都不得不写很多简单的或者复杂的查询语句，ORM无法减少这部分工作，最多是用另一种面向对象风格的语言去表达查询需求，如前所述，用面向对象风格的语言不见得比SQL更容易。通常业务系统中会有很多表，每个表都有很多字段，即便是编写最简单的查询语句也不是一件容易的事情，需要记住数据库中有哪些表，有哪些字段，记住有哪些函数等。写查询语句很多时候成为一件头疼的事情。</p><p>　　QueryDSL、JOOQ、Ebean甚至MyBatis和JPA都设计一些特性，帮助开发人员编写查询语句，有人称之为“DSL风格数据库编程”。最早实现这类功能的可能是QueryDSL，把数据库的表结构逆向工程为java的类，然后可以让java程序员能够用java的语法构造出一个复杂的查询语句，利用IDE的代码自动补全功能，可以自动提示表名、字段名、查询语句的关键字等，很成功的简化了查询语句的编写，免除了程序员记忆各种名字、函数和关键字的负担。</p><p>　　QueryDSL有很多版本，但用得多的是QueryDSL JPA，可以帮助开发人员编写JPQL语句，如前所述，JPQL语句有很多局限不如SQL灵活高效。后来的JOOQ和Ebean，基本上继承了QueryDSL的思路，Ebean基本上还是JPA风格的ORM框架，虽然也支持SQL，但不清楚其DSL特性是否支持SQL语句编写，在官网上看到的例子都是用于构造JPQL语句。</p><p>　　这里面最成功的应该是JOOQ，和QueryDSL不同，JOOQ的DSL编程是帮助开发人员编写SQL语句，抛弃累赘的ORM概念，JOOQ这个功能非常轻小，非常容易学习和使用，同时性能也非常好，不像QueryDSL和Ebean，需要了解复杂的JPA概念和各种奇异的限制，JOOQ编写的就是普通的SQL语句，只是把查询结果填充到实体类中（严格说JOOQ没有实体类，只是自动生成的Record对象），JOOQ甚至不一定要把结果转换为实体类，可以让开发人员按照字段取得结果的值，相对于JDBC，JOOQ会把结果值转换为合适的Java类型，用起来比JDBC更简单。</p><p>　　传统主流的框架对DSL风格支持得很少，Hibernate里面基本上没有看到有这方面的特性。MyBatis提供了”SQL语句构建器”来帮助开发人员构造SQL语句，但和QueryDSL&#x2F;JOOQ&#x2F;Ebean差很多，不能提示表名和字段名，语法也显得累赘不像SQL。</p><p>　　JPA给人的印象是复杂难懂，它的MetaModel Api继承了特点，MetaModel API+Criteria API，再配合Hibernate JPA 2 Metamodel Generator，让人有点QueryDSL JPA的感觉，只是绕了一个大大的弯，叠加了好几层技术，最后勉强实现了QueryDSL JPA的简单易懂的功能。很多人不推荐JPA+QueryDSL的用法，而是推荐JPA MetaModel API+Criteria API+Hibernate JPA 2 Metamodel Generator的用法，让人很难理解，也许是因为这个方案是纯的标准的JPA方案。</p><p>　　数据库DSL编程的另一个主要卖点是变化适应性强，数据库表结构在开发过程中通常会频繁发生变化，传统的非DSL编程，字段名只是一个字符串，如果字段名或者类型改变之后，查询语句没有相应修改，编译不会出错，也容易被开发人员忽略，是bug的一个主要来源。DSL编程里面，字段被逆向工程为一个java类的属性，数据库结构改变之后，作为java代码一部分的查询语句会发生编译错误，提示开发人员进行修改，可以减少大量bug，减轻测试的负担，提高软件的可靠性和质量。</p><h4 id="三、跨数据库移植"><a href="#三、跨数据库移植" class="headerlink" title="三、跨数据库移植"></a>三、跨数据库移植</h4><p>　　Hibernate和JPA使用hql和JPQL这类数据库无关的中间语言描述查询，可以在不同数据库中无缝移植，移植到一个SQL有巨大差别的数据库通常不需要修改代码或者只需要修改很少的代码。Ebean如果不使用原生SQL，而是使用JPA的方式开发，也能在不同数据库中平滑的移植。</p><p>　　MyBatis和JOOQ直接使用SQL，跨数据库移植时都难免要修改SQL语句。这方面MyBatis比较差，只有一个动态SQL提供的特性，对于不同的数据库编写不同的sql语句。</p><p>　　JOOQ虽然无法像Hibernate和JPA那样无缝移植，但比MyBatis好很多。JOOQ的DSL很大一部分是通用的，例如分页查询中，Mysql的limit&#x2F;offset关键字是很方便的描述方式，但Oracle和SQLServer的SQL不支持，如果我们用JOOQ的DSL的limit和offset方法构造SQL语句，不修改移植到不支持limit&#x2F;offset的Oracle和SQLServer上，我们会发现这些语句还能正常使用，因为JOOQ会把limit&#x2F;offset转换成等价的目标数据库的SQL语句。JOOQ根据目标数据库转换SQL语句的特性，使得在不同数据库之间移植的时候，只需要修改很少的代码，明显优于MyBatis。</p><p>　　JDBC Template应该最差，只能尽量使用标准sql语句来减少移植工作量。</p><h4 id="四、安全性"><a href="#四、安全性" class="headerlink" title="四、安全性"></a>四、安全性</h4><p>　　一般来说，拼接查询语句都会有安全隐患，容易被sql注入攻击。不论是jdbc，还是hql&#x2F;JPQL，只要使用拼接的查询语句都是不安全的。对于JDBC来说，使用参数化的sql语句代替拼接，可以解决问题。而JPA则应该使用Criteria API解决这个问题。</p><p>　　对于JOOQ之类的DSL风格框架，最终会被render为参数化的sql，天生免疫sql注入攻击。Ebean也支持DSL方式编程，也同样免疫sql注入攻击。</p><p>　　这是因为DSL风格编程参数化查询比拼接字符串查询更简单，没人会拼接字符串。而jdbc&#x2F;hql&#x2F;JPQL拼接字符串有时候比参数化查询更简单，特别是jdbc，很多人会偷懒使用不安全的方式。</p><h4 id="五、JOOQ的失败之处"><a href="#五、JOOQ的失败之处" class="headerlink" title="五、JOOQ的失败之处"></a>五、JOOQ的失败之处</h4><p>　　可能大部分人会不同意，虽然Hibernate、JPA仍然大行其道，是最主流的持久化框架，但其实这种封装SQL的纯正ORM已经过时，效益低于使用它们的代价，应该淘汰了。MyBatis虽然有很多优点，但它的优点JOOQ基本上都有，而且多数还更好。MyBatis最大的缺点是难以避免写xml文件，xml文件编写困难，容易出错，还不容易查找错误。相对于JOOQ，MyBatis在多数情况下没有任何优势。</p><p>　　Ebean同时具有很多不同框架的优点，但它是基于JPA的，难免有JPA的各种限制，这是致命的缺点。</p><p>　　JOOQ这个极端轻量级的框架技术上是最完美的，突然有一天几个Web系统同时崩了，最后发现是JOOQ试用期过期了，这是JOOQ的失败之处，它不是完全免费的，只是对MySql之类的开源数据库免费。</p><p>　　最终，我决定选择JDBC Template。</p><p><a href="https://zhuanlan.zhihu.com/p/59220248">转载自知乎，原文链接：https://zhuanlan.zhihu.com/p/59220248</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　因为项目需要选择数据持久化框架，看了一下主要几个流行的和不流行的框架，对于复杂业务系统，最终的结论是，JOOQ是总体上最好的，可惜不是完全免费，最终选择JDBC Template。&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA随笔" scheme="https://blog.elfred.top/categories/JAVA%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="框架" scheme="https://blog.elfred.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用JPA实现Specification规范规格模式</title>
    <link href="https://blog.elfred.top/posts/ea992500.html"/>
    <id>https://blog.elfred.top/posts/ea992500.html</id>
    <published>2019-10-13T13:55:32.000Z</published>
    <updated>2025-03-08T14:46:55.116Z</updated>
    
    <content type="html"><![CDATA[<p>　　由DDD之父 Eric Evans 和OO之父 Martin Fowler定义的规范(Specification也称规格模式)模式article 越来越受到广泛应用，本文介绍如何使用JavaEE 持久层规范JPA实现规格模式，其实现思想也适合其他持久层框架。案例源码见GitHub。</p><span id="more"></span><p>　　在这个文章中，我们将使用以下POLL类作为创建Specification为例实体。它代表了民意调查，有一个开始和结束日期。在这两个日期之间的时间内用户可以在不同的选择之间投票表决Poll，投票Poll可以在管理员的结束日期尚未到达前锁定。在这种情况下，一个锁日期将被设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poll</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> DateTime startDate;</span><br><span class="line">  <span class="keyword">private</span> DateTime endDate;</span><br><span class="line">  <span class="keyword">private</span> DateTime lockDate;</span><br><span class="line">  <span class="meta">@OneToMany(cascade = CascadeType.ALL)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">List</span> <span class="variable">votes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　现在我们有两个约束：</p><ul><li>一个投票poll如果满足<em><strong>startDate &lt; now &lt; endDate</strong></em>，那表示它在进行中。  </li><li>一个投票poll如果超过100个投票但是没有锁定，表示它很流行。</li></ul><p>　　我们可以通过在POLL投票添加适当的方法如：poll.isCurrentlyRunning（），另外，我们可以使用一个服务方法pollService.isCurrentlyRunning（进行轮询）。然而，我们也希望能够查询数据库获得所有当前正在运行的民意调查。因此，我们可以添加一个DAO或储存repository库的方法类似pollRepository.findAllCurrentlyRunningPolls（）。<br>　　如果我们想结合上述两个约束查询，例如我们想在数据库中查询当前正在运行的所有流行的调查名单？这时Specification模式派上用场。当使用Specification模式时，我们将业务规则转换为额外的类称为Specification。<br>　　创建Specification接口和抽象类如下：　　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Specification</span> &#123; </span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(T t)</span>; </span><br><span class="line">  Predicate <span class="title function_">toPredicate</span><span class="params">(Root root, CriteriaBuilder cb)</span>;</span><br><span class="line">  Class <span class="title function_">getType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractSpecification</span> <span class="keyword">implements</span> <span class="title class_">Specification</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotImplementedException</span>();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root poll, CriteriaBuilder cb)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotImplementedException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">type</span> <span class="operator">=</span> (ParameterizedType) <span class="built_in">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">    <span class="keyword">return</span> (Class) type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>specification的核心是isSatisfiedBy()方法,用于检查一个对象是否满足规范规格要求。<br>toPredicate()是一个附加的方法，我们在案例中使用它返回一个约束。<br>javax.persistence.criteria.Predicate 实例，它能被用于查询一个数据库。</p><p>　　检查一个poll是否正在运行的规范实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsCurrentlyRunning</span> <span class="keyword">extends</span> <span class="title class_">AbstractSpecification</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Poll poll)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> poll.getStartDate().isBeforeNow()</span><br><span class="line">        &amp;&amp; poll.getEndDate().isAfterNow()</span><br><span class="line">        &amp;&amp; poll.getLockDate() == <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root poll, CriteriaBuilder cb)</span> &#123;</span><br><span class="line">    <span class="type">DateTime</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTime</span>();</span><br><span class="line">    <span class="keyword">return</span> cb.and(</span><br><span class="line">      cb.lessThan(poll.get(Poll_.startDate), now),</span><br><span class="line">      cb.greaterThan(poll.get(Poll_.endDate), now),</span><br><span class="line">      cb.isNull(poll.get(Poll_.lockDate))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一个投票是否流行的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsPopular</span> <span class="keyword">extends</span> <span class="title class_">AbstractSpecification</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Poll poll)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> poll.getLockDate() == <span class="literal">null</span> &amp;&amp; poll.getVotes().size() &gt; <span class="number">100</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root poll, CriteriaBuilder cb)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cb.and(</span><br><span class="line">      cb.isNull(poll.get(Poll_.lockDate)),</span><br><span class="line">      cb.greaterThan(cb.size(poll.get(Poll_.votes)), <span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isPopular</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IsPopular</span>().isSatisfiedBy(poll);<span class="type">boolean</span> <span class="variable">isCurrentlyRunning</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IsCurrentlyRunning</span>().isSatisfiedBy(poll);</span><br></pre></td></tr></table></figure><p>为了查询数据库，我们需要继承扩展DAO&#x2F;Repository来支持规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PollRepository</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">EntityManager</span> <span class="variable">entityManager</span> <span class="operator">=</span> ...</span><br><span class="line">  <span class="keyword">public</span> List <span class="title function_">findAllBySpecification</span><span class="params">(Specification specification)</span> &#123;</span><br><span class="line">    <span class="type">CriteriaBuilder</span> <span class="variable">criteriaBuilder</span> <span class="operator">=</span> entityManager.getCriteriaBuilder();</span><br><span class="line">    <span class="comment">// use specification.getType() to create a Root instance</span></span><br><span class="line">    <span class="type">CriteriaQuery</span> <span class="variable">criteriaQuery</span> <span class="operator">=</span> criteriaBuilder.createQuery(specification.getType());</span><br><span class="line">    <span class="type">Root</span> <span class="variable">root</span> <span class="operator">=</span> criteriaQuery.from(specification.getType());</span><br><span class="line">    <span class="comment">// get predicate from specification</span></span><br><span class="line">    <span class="type">Predicate</span> <span class="variable">predicate</span> <span class="operator">=</span> specification.toPredicate(root, criteriaBuilder);</span><br><span class="line">    <span class="comment">// set predicate and execute query</span></span><br><span class="line">    criteriaQuery.where(predicate);</span><br><span class="line">    <span class="keyword">return</span> entityManager.createQuery(criteriaQuery).getResultList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　我们使用 AbstractSpecification的getType() 方法 创建CriteriaQuery 和 Root 实例. getType()返回的是一个 AbstractSpecification泛型，可以由子类定义. 对于流行IsPopular 且正在进行IsCurrentlyRunning它返回一个Poll class。<br>　　如果没有 getType()我们必须在每个规范的 toPredicate() 中实现创建 CriteriaQuery 和 Root实例。它只是减少烦人代码的帮助者。　　</p><p>使用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">popularPolls</span> <span class="operator">=</span> pollRepository.findAllBySpecification(<span class="keyword">new</span> <span class="title class_">IsPopular</span>());</span><br><span class="line"><span class="type">List</span> <span class="variable">currentlyRunningPolls</span> <span class="operator">=</span> pollRepository.findAllBySpecification(<span class="keyword">new</span> <span class="title class_">IsCurrentlyRunning</span>());</span><br></pre></td></tr></table></figure><p>下面问题是如何结合这两个规范，我们如何查询数据库所有流行且还在进行的投票呢？</p><p>使用组合模式实现组合规范模式。名称为AndSpecification：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndSpecification</span> <span class="keyword">extends</span> <span class="title class_">AbstractSpecification</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Specification first;</span><br><span class="line">  <span class="keyword">private</span> Specification second;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AndSpecification</span><span class="params">(Specification first, Specification second)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.first = first;</span><br><span class="line">    <span class="built_in">this</span>.second = second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> first.isSatisfiedBy(t) &amp;&amp; second.isSatisfiedBy(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root root, CriteriaBuilder cb)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cb.and(</span><br><span class="line">      first.toPredicate(root, cb),</span><br><span class="line">      second.toPredicate(root, cb)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> first.getType();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Specification</span> <span class="variable">popularAndRunning</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AndSpecification</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">IsPopular</span>(), <span class="keyword">new</span> <span class="title class_">IsCurrentlyRunning</span>());</span><br><span class="line"><span class="type">List</span> <span class="variable">polls</span> <span class="operator">=</span> myRepository.findAllBySpecification(popularAndRunning);</span><br></pre></td></tr></table></figure><p>为了提供可读性，我们增加and方法到规范接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Specification</span> &#123;</span><br><span class="line">  Specification <span class="title function_">and</span><span class="params">(Specification other)</span>;</span><br><span class="line">  <span class="comment">// other methods</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractSpecification</span> <span class="keyword">implements</span> <span class="title class_">Specification</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Specification <span class="title function_">and</span><span class="params">(Specification other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AndSpecification</span>&lt;&gt;(<span class="built_in">this</span>, other);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Specification</span> <span class="variable">popularAndRunning</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IsPopular</span>().and(<span class="keyword">new</span> <span class="title class_">IsCurrentlyRunning</span>());</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isPopularAndRunning</span> <span class="operator">=</span> popularAndRunning.isSatisfiedBy(poll);</span><br><span class="line"><span class="type">List</span> <span class="variable">polls</span> <span class="operator">=</span> myRepository.findAllBySpecification(popularAndRunning);</span><br></pre></td></tr></table></figure><p><a href="https://www.jdon.com/idea/javaee7/specification-pattern-with-jpa.html">转载自https://www.jdon.com/idea/javaee7/specification-pattern-with-jpa.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　由DDD之父 Eric Evans 和OO之父 Martin Fowler定义的规范(Specification也称规格模式)模式article 越来越受到广泛应用，本文介绍如何使用JavaEE 持久层规范JPA实现规格模式，其实现思想也适合其他持久层框架。案例源码见GitHub。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JPA OneToMany简单应用</title>
    <link href="https://blog.elfred.top/posts/c51a8252.html"/>
    <id>https://blog.elfred.top/posts/c51a8252.html</id>
    <published>2019-10-08T13:43:00.000Z</published>
    <updated>2025-03-08T14:46:55.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-单向-OneToMany"><a href="#1-单向-OneToMany" class="headerlink" title="1.单向@OneToMany"></a>1.单向@OneToMany</h3><ol><li>User实体类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(cascade = &#123;CascadeType.REMOVE&#125;)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;article_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Article&gt; articles;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>2.Article实体类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;article&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name = &quot;article_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long article_id;    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;title&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;content&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-单向-OneToMany&quot;&gt;&lt;a href=&quot;#1-单向-OneToMany&quot; class=&quot;headerlink&quot; title=&quot;1.单向@OneToMany&quot;&gt;&lt;/a&gt;1.单向@OneToMany&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;User实体类&lt;figure c</summary>
      
    
    
    
    <category term="Java随笔" scheme="https://blog.elfred.top/categories/Java%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="Spring" scheme="https://blog.elfred.top/tags/Spring/"/>
    
    <category term="JPA" scheme="https://blog.elfred.top/tags/JPA/"/>
    
    <category term="MapStruct" scheme="https://blog.elfred.top/tags/MapStruct/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="https://blog.elfred.top/posts/1e80ad29.html"/>
    <id>https://blog.elfred.top/posts/1e80ad29.html</id>
    <published>2019-10-06T07:16:00.000Z</published>
    <updated>2025-03-08T14:46:55.118Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><h3 id="工厂模式（Factory-Method）"><a href="#工厂模式（Factory-Method）" class="headerlink" title="工厂模式（Factory Method）"></a>工厂模式（Factory Method）</h3><h3 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h3><h3 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h3><h3 id="包装器（Decorator装饰模式）"><a href="#包装器（Decorator装饰模式）" class="headerlink" title="包装器（Decorator装饰模式）"></a>包装器（Decorator装饰模式）</h3><h3 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h3><h3 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h3><h3 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h3><h3 id="模板方法（Template-Method）"><a href="#模板方法（Template-Method）" class="headerlink" title="模板方法（Template Method）"></a>模板方法（Template Method）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂&quot;&gt;&lt;/a&gt;简单工厂&lt;/h3&gt;&lt;h3 id=&quot;工厂模式（Factory-Method）&quot;&gt;&lt;a href=&quot;#工厂模式（Factory-Method）</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Jhipster学习笔记</title>
    <link href="https://blog.elfred.top/posts/abc029f4.html"/>
    <id>https://blog.elfred.top/posts/abc029f4.html</id>
    <published>2019-10-04T12:50:00.000Z</published>
    <updated>2025-03-08T14:46:55.115Z</updated>
    
    <content type="html"><![CDATA[<h4 id="项目生成"><a href="#项目生成" class="headerlink" title="项目生成"></a>项目生成</h4><h5 id="1-使用Jhipster生成一个纯前端项目"><a href="#1-使用Jhipster生成一个纯前端项目" class="headerlink" title="1. 使用Jhipster生成一个纯前端项目"></a>1. 使用Jhipster生成一个纯前端项目</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将JH-Vuejs 模块符号链接至当前项目的依赖中 (ps:用管理员权限cmd运行)，这一步很重要，如果不这样做后面生成的代码都是NG框架</span></span><br><span class="line">npm <span class="built_in">link</span> generator-jhipster-vuejs</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash</span></span><br><span class="line">jhipster --skip-server --blueprints vuejs --db mysql --auth jwt</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">jhipster --skip-server --blueprints vuejs -d --db mysql --auth jwt</span><br><span class="line"></span><br><span class="line"><span class="comment">#前端项目生成实体命令，必须加--db（???）</span></span><br><span class="line">jhipster entity article --db mysql</span><br></pre></td></tr></table></figure><h5 id="2-使用Jhipster生成一个纯后端项目"><a href="#2-使用Jhipster生成一个纯后端项目" class="headerlink" title="2. 使用Jhipster生成一个纯后端项目"></a>2. 使用Jhipster生成一个纯后端项目</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhipster --skip-client</span><br></pre></td></tr></table></figure><h5 id="3-使用Jhipster生成一个非前后端分离项目"><a href="#3-使用Jhipster生成一个非前后端分离项目" class="headerlink" title="3. 使用Jhipster生成一个非前后端分离项目"></a>3. 使用Jhipster生成一个非前后端分离项目</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用vue作为前端框架生成一个前后端不分离的项目</span></span><br><span class="line">jhipster --blueprint vuejs</span><br></pre></td></tr></table></figure><h5 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导出jdl文件</span></span><br><span class="line">jhipster export-jdl &lt;FILE_NAME&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;项目生成&quot;&gt;&lt;a href=&quot;#项目生成&quot; class=&quot;headerlink&quot; title=&quot;项目生成&quot;&gt;&lt;/a&gt;项目生成&lt;/h4&gt;&lt;h5 id=&quot;1-使用Jhipster生成一个纯前端项目&quot;&gt;&lt;a href=&quot;#1-使用Jhipster生成一个纯前端项目&quot; c</summary>
      
    
    
    
    <category term="Jhipster" scheme="https://blog.elfred.top/categories/Jhipster/"/>
    
    
    <category term="Jhipster" scheme="https://blog.elfred.top/tags/Jhipster/"/>
    
  </entry>
  
  <entry>
    <title>为什么要用Spring</title>
    <link href="https://blog.elfred.top/posts/cf4d9cf.html"/>
    <id>https://blog.elfred.top/posts/cf4d9cf.html</id>
    <published>2019-10-04T12:50:00.000Z</published>
    <updated>2025-03-08T14:46:55.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><h4 id="依赖注入能做什么"><a href="#依赖注入能做什么" class="headerlink" title="依赖注入能做什么"></a>依赖注入能做什么</h4><ul><li>为什么要使用依赖注入<ul><li>传统的代码，每个对象负责管理与自己需要依赖的对象，导致如果需要切换依赖对象的实现类时，需要修改多处地方。同时，过度耦合也使得对象难以进行单元测试。</li><li>依赖注入把对象的创造交给外部去管理,很好的解决了代码紧耦合（tight couple）的问题，是一种让代码实现松耦合（loose couple）的机制。</li><li>松耦合让代码更具灵活性，能更好地应对需求变动，以及方便单元测试。</li></ul></li></ul><h4 id="什么是IOC容器"><a href="#什么是IOC容器" class="headerlink" title="什么是IOC容器"></a>什么是IOC容器</h4><h4 id="COC是什么"><a href="#COC是什么" class="headerlink" title="COC是什么"></a>COC是什么</h4><p>Convention over Configuration 约定优于配置</p><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><h3 id="Spring特点"><a href="#Spring特点" class="headerlink" title="Spring特点"></a>Spring特点</h3><h5 id="1-方便解耦，简化开发"><a href="#1-方便解耦，简化开发" class="headerlink" title="1. 方便解耦，简化开发"></a>1. 方便解耦，简化开发</h5><p>　　通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p><h5 id="2-AOP编程的支持"><a href="#2-AOP编程的支持" class="headerlink" title="2. AOP编程的支持"></a>2. AOP编程的支持</h5><p>通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</p><h5 id="3-声明式事务的支持"><a href="#3-声明式事务的支持" class="headerlink" title="3. 声明式事务的支持"></a>3. 声明式事务的支持</h5><p>　　在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</p><h5 id="4-方便程序的测试"><a href="#4-方便程序的测试" class="headerlink" title="4. 方便程序的测试"></a>4. 方便程序的测试</h5><p>　　可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p><h5 id="5-方便集成各种优秀框架"><a href="#5-方便集成各种优秀框架" class="headerlink" title="5. 方便集成各种优秀框架"></a>5. 方便集成各种优秀框架</h5><p>　　Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。</p><h5 id="6-降低Java-EE-API的使用难度"><a href="#6-降低Java-EE-API的使用难度" class="headerlink" title="6. 降低Java EE API的使用难度"></a>6. 降低Java EE API的使用难度</h5><p>　　Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。</p><h5 id="7-Java-源码是经典学习范例"><a href="#7-Java-源码是经典学习范例" class="headerlink" title="7. Java 源码是经典学习范例"></a>7. Java 源码是经典学习范例</h5><p>　　Spring的源码设计精妙、结构清晰、匠心独运，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。　　</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><h4 id="总结起来，使用Spring有如下优点："><a href="#总结起来，使用Spring有如下优点：" class="headerlink" title="总结起来，使用Spring有如下优点："></a>总结起来，使用Spring有如下优点：</h4><ol><li>低侵入式设计，代码污染极低</li><li>独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺</li><li>Spring的DI机制降低了业务对象替换的复杂性，提高了组件之间的解耦</li><li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用</li><li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问</li><li>Spring并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Spring-IOC&quot;&gt;&lt;a href=&quot;#Spring-IOC&quot; class=&quot;headerlink&quot; title=&quot;Spring IOC&quot;&gt;&lt;/a&gt;Spring IOC&lt;/h3&gt;&lt;h4 id=&quot;依赖注入能做什么&quot;&gt;&lt;a href=&quot;#依赖注入能做什么&quot; cla</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://blog.elfred.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.elfred.top/posts/4a17b156.html"/>
    <id>https://blog.elfred.top/posts/4a17b156.html</id>
    <published>2019-10-04T03:45:00.000Z</published>
    <updated>2025-03-08T14:46:55.117Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
